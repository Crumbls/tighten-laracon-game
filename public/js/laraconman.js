/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("{// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThELFlBQVk7QUFDMUU7QUFDQSw4REFBOEQsWUFBWTtBQUMxRTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYWNvbm1hbi8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzP2I5MTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/events/events.js\n\n}");

/***/ }),

/***/ "./node_modules/heap/index.js":
/*!************************************!*\
  !*** ./node_modules/heap/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{module.exports = __webpack_require__(/*! ./lib/heap */ \"./node_modules/heap/lib/heap.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGVhcC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5RkFBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhY29ubWFuLy4vbm9kZV9tb2R1bGVzL2hlYXAvaW5kZXguanM/YTlmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2hlYXAnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/heap/index.js\n\n}");

/***/ }),

/***/ "./node_modules/heap/lib/heap.js":
/*!***************************************!*\
  !*** ./node_modules/heap/lib/heap.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("{/* module decorator */ module = __webpack_require__.nmd(module);\n// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  if ( true && module !== null ? module.exports : void 0) {\n    module.exports = Heap;\n  } else {\n    window.Heap = Heap;\n  }\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YWNvbm1hbi8uL25vZGVfbW9kdWxlcy9oZWFwL2xpYi9oZWFwLmpzPzAxODIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjguMFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgSGVhcCwgZGVmYXVsdENtcCwgZmxvb3IsIGhlYXBpZnksIGhlYXBwb3AsIGhlYXBwdXNoLCBoZWFwcHVzaHBvcCwgaGVhcHJlcGxhY2UsIGluc29ydCwgbWluLCBubGFyZ2VzdCwgbnNtYWxsZXN0LCB1cGRhdGVJdGVtLCBfc2lmdGRvd24sIF9zaWZ0dXA7XG5cbiAgZmxvb3IgPSBNYXRoLmZsb29yLCBtaW4gPSBNYXRoLm1pbjtcblxuXG4gIC8qXG4gIERlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBiZSB1c2VkXG4gICAqL1xuXG4gIGRlZmF1bHRDbXAgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgaWYgKHggPCB5KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmICh4ID4geSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuXG5cbiAgLypcbiAgSW5zZXJ0IGl0ZW0geCBpbiBsaXN0IGEsIGFuZCBrZWVwIGl0IHNvcnRlZCBhc3N1bWluZyBhIGlzIHNvcnRlZC5cbiAgXG4gIElmIHggaXMgYWxyZWFkeSBpbiBhLCBpbnNlcnQgaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSByaWdodG1vc3QgeC5cbiAgXG4gIE9wdGlvbmFsIGFyZ3MgbG8gKGRlZmF1bHQgMCkgYW5kIGhpIChkZWZhdWx0IGEubGVuZ3RoKSBib3VuZCB0aGUgc2xpY2VcbiAgb2YgYSB0byBiZSBzZWFyY2hlZC5cbiAgICovXG5cbiAgaW5zb3J0ID0gZnVuY3Rpb24oYSwgeCwgbG8sIGhpLCBjbXApIHtcbiAgICB2YXIgbWlkO1xuICAgIGlmIChsbyA9PSBudWxsKSB7XG4gICAgICBsbyA9IDA7XG4gICAgfVxuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKGxvIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsbyBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpO1xuICAgIH1cbiAgICBpZiAoaGkgPT0gbnVsbCkge1xuICAgICAgaGkgPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgIG1pZCA9IGZsb29yKChsbyArIGhpKSAvIDIpO1xuICAgICAgaWYgKGNtcCh4LCBhW21pZF0pIDwgMCkge1xuICAgICAgICBoaSA9IG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChbXS5zcGxpY2UuYXBwbHkoYSwgW2xvLCBsbyAtIGxvXS5jb25jYXQoeCkpLCB4KTtcbiAgfTtcblxuXG4gIC8qXG4gIFB1c2ggaXRlbSBvbnRvIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cbiAgICovXG5cbiAgaGVhcHB1c2ggPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBhcnJheS5wdXNoKGl0ZW0pO1xuICAgIHJldHVybiBfc2lmdGRvd24oYXJyYXksIDAsIGFycmF5Lmxlbmd0aCAtIDEsIGNtcCk7XG4gIH07XG5cblxuICAvKlxuICBQb3AgdGhlIHNtYWxsZXN0IGl0ZW0gb2ZmIHRoZSBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICAqL1xuXG4gIGhlYXBwb3AgPSBmdW5jdGlvbihhcnJheSwgY21wKSB7XG4gICAgdmFyIGxhc3RlbHQsIHJldHVybml0ZW07XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBsYXN0ZWx0ID0gYXJyYXkucG9wKCk7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuaXRlbSA9IGFycmF5WzBdO1xuICAgICAgYXJyYXlbMF0gPSBsYXN0ZWx0O1xuICAgICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuaXRlbSA9IGxhc3RlbHQ7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5pdGVtO1xuICB9O1xuXG5cbiAgLypcbiAgUG9wIGFuZCByZXR1cm4gdGhlIGN1cnJlbnQgc21hbGxlc3QgdmFsdWUsIGFuZCBhZGQgdGhlIG5ldyBpdGVtLlxuICBcbiAgVGhpcyBpcyBtb3JlIGVmZmljaWVudCB0aGFuIGhlYXBwb3AoKSBmb2xsb3dlZCBieSBoZWFwcHVzaCgpLCBhbmQgY2FuIGJlXG4gIG1vcmUgYXBwcm9wcmlhdGUgd2hlbiB1c2luZyBhIGZpeGVkIHNpemUgaGVhcC4gTm90ZSB0aGF0IHRoZSB2YWx1ZVxuICByZXR1cm5lZCBtYXkgYmUgbGFyZ2VyIHRoYW4gaXRlbSEgVGhhdCBjb25zdHJhaW5zIHJlYXNvbmFibGUgdXNlIG9mXG4gIHRoaXMgcm91dGluZSB1bmxlc3Mgd3JpdHRlbiBhcyBwYXJ0IG9mIGEgY29uZGl0aW9uYWwgcmVwbGFjZW1lbnQ6XG4gICAgICBpZiBpdGVtID4gYXJyYXlbMF1cbiAgICAgICAgaXRlbSA9IGhlYXByZXBsYWNlKGFycmF5LCBpdGVtKVxuICAgKi9cblxuICBoZWFwcmVwbGFjZSA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICB2YXIgcmV0dXJuaXRlbTtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICBhcnJheVswXSA9IGl0ZW07XG4gICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIEZhc3QgdmVyc2lvbiBvZiBhIGhlYXBwdXNoIGZvbGxvd2VkIGJ5IGEgaGVhcHBvcC5cbiAgICovXG5cbiAgaGVhcHB1c2hwb3AgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIF9yZWY7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAoYXJyYXkubGVuZ3RoICYmIGNtcChhcnJheVswXSwgaXRlbSkgPCAwKSB7XG4gICAgICBfcmVmID0gW2FycmF5WzBdLCBpdGVtXSwgaXRlbSA9IF9yZWZbMF0sIGFycmF5WzBdID0gX3JlZlsxXTtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9O1xuXG5cbiAgLypcbiAgVHJhbnNmb3JtIGxpc3QgaW50byBhIGhlYXAsIGluLXBsYWNlLCBpbiBPKGFycmF5Lmxlbmd0aCkgdGltZS5cbiAgICovXG5cbiAgaGVhcGlmeSA9IGZ1bmN0aW9uKGFycmF5LCBjbXApIHtcbiAgICB2YXIgaSwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHMsIF9yZXN1bHRzMTtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIF9yZWYxID0gKGZ1bmN0aW9uKCkge1xuICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICBmb3IgKHZhciBfaiA9IDAsIF9yZWYgPSBmbG9vcihhcnJheS5sZW5ndGggLyAyKTsgMCA8PSBfcmVmID8gX2ogPCBfcmVmIDogX2ogPiBfcmVmOyAwIDw9IF9yZWYgPyBfaisrIDogX2otLSl7IF9yZXN1bHRzMS5wdXNoKF9qKTsgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICB9KS5hcHBseSh0aGlzKS5yZXZlcnNlKCk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBpID0gX3JlZjFbX2ldO1xuICAgICAgX3Jlc3VsdHMucHVzaChfc2lmdHVwKGFycmF5LCBpLCBjbXApKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG5cbiAgLypcbiAgVXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZ2l2ZW4gaXRlbSBpbiB0aGUgaGVhcC5cbiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIGl0ZW0gaXMgYmVpbmcgbW9kaWZpZWQuXG4gICAqL1xuXG4gIHVwZGF0ZUl0ZW0gPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIHBvcztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHBvcyA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX3NpZnRkb3duKGFycmF5LCAwLCBwb3MsIGNtcCk7XG4gICAgcmV0dXJuIF9zaWZ0dXAoYXJyYXksIHBvcywgY21wKTtcbiAgfTtcblxuXG4gIC8qXG4gIEZpbmQgdGhlIG4gbGFyZ2VzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXG4gICAqL1xuXG4gIG5sYXJnZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgIHZhciBlbGVtLCByZXN1bHQsIF9pLCBfbGVuLCBfcmVmO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbik7XG4gICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoZWFwaWZ5KHJlc3VsdCwgY21wKTtcbiAgICBfcmVmID0gYXJyYXkuc2xpY2Uobik7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBlbGVtID0gX3JlZltfaV07XG4gICAgICBoZWFwcHVzaHBvcChyZXN1bHQsIGVsZW0sIGNtcCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuc29ydChjbXApLnJldmVyc2UoKTtcbiAgfTtcblxuXG4gIC8qXG4gIEZpbmQgdGhlIG4gc21hbGxlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICAgKi9cblxuICBuc21hbGxlc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgY21wKSB7XG4gICAgdmFyIGVsZW0sIGksIGxvcywgcmVzdWx0LCBfaSwgX2osIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVzdWx0cztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChuICogMTAgPD0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBhcnJheS5zbGljZSgwLCBuKS5zb3J0KGNtcCk7XG4gICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICBfcmVmID0gYXJyYXkuc2xpY2Uobik7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuICAgICAgICBpZiAoY21wKGVsZW0sIGxvcykgPCAwKSB7XG4gICAgICAgICAgaW5zb3J0KHJlc3VsdCwgZWxlbSwgMCwgbnVsbCwgY21wKTtcbiAgICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICAgICAgbG9zID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGVhcGlmeShhcnJheSwgY21wKTtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoaSA9IF9qID0gMCwgX3JlZjEgPSBtaW4obiwgYXJyYXkubGVuZ3RoKTsgMCA8PSBfcmVmMSA/IF9qIDwgX3JlZjEgOiBfaiA+IF9yZWYxOyBpID0gMCA8PSBfcmVmMSA/ICsrX2ogOiAtLV9qKSB7XG4gICAgICBfcmVzdWx0cy5wdXNoKGhlYXBwb3AoYXJyYXksIGNtcCkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgX3NpZnRkb3duID0gZnVuY3Rpb24oYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCkge1xuICAgIHZhciBuZXdpdGVtLCBwYXJlbnQsIHBhcmVudHBvcztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIG5ld2l0ZW0gPSBhcnJheVtwb3NdO1xuICAgIHdoaWxlIChwb3MgPiBzdGFydHBvcykge1xuICAgICAgcGFyZW50cG9zID0gKHBvcyAtIDEpID4+IDE7XG4gICAgICBwYXJlbnQgPSBhcnJheVtwYXJlbnRwb3NdO1xuICAgICAgaWYgKGNtcChuZXdpdGVtLCBwYXJlbnQpIDwgMCkge1xuICAgICAgICBhcnJheVtwb3NdID0gcGFyZW50O1xuICAgICAgICBwb3MgPSBwYXJlbnRwb3M7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBhcnJheVtwb3NdID0gbmV3aXRlbTtcbiAgfTtcblxuICBfc2lmdHVwID0gZnVuY3Rpb24oYXJyYXksIHBvcywgY21wKSB7XG4gICAgdmFyIGNoaWxkcG9zLCBlbmRwb3MsIG5ld2l0ZW0sIHJpZ2h0cG9zLCBzdGFydHBvcztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGVuZHBvcyA9IGFycmF5Lmxlbmd0aDtcbiAgICBzdGFydHBvcyA9IHBvcztcbiAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcbiAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuICAgIHdoaWxlIChjaGlsZHBvcyA8IGVuZHBvcykge1xuICAgICAgcmlnaHRwb3MgPSBjaGlsZHBvcyArIDE7XG4gICAgICBpZiAocmlnaHRwb3MgPCBlbmRwb3MgJiYgIShjbXAoYXJyYXlbY2hpbGRwb3NdLCBhcnJheVtyaWdodHBvc10pIDwgMCkpIHtcbiAgICAgICAgY2hpbGRwb3MgPSByaWdodHBvcztcbiAgICAgIH1cbiAgICAgIGFycmF5W3Bvc10gPSBhcnJheVtjaGlsZHBvc107XG4gICAgICBwb3MgPSBjaGlsZHBvcztcbiAgICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gICAgfVxuICAgIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xuICAgIHJldHVybiBfc2lmdGRvd24oYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCk7XG4gIH07XG5cbiAgSGVhcCA9IChmdW5jdGlvbigpIHtcbiAgICBIZWFwLnB1c2ggPSBoZWFwcHVzaDtcblxuICAgIEhlYXAucG9wID0gaGVhcHBvcDtcblxuICAgIEhlYXAucmVwbGFjZSA9IGhlYXByZXBsYWNlO1xuXG4gICAgSGVhcC5wdXNocG9wID0gaGVhcHB1c2hwb3A7XG5cbiAgICBIZWFwLmhlYXBpZnkgPSBoZWFwaWZ5O1xuXG4gICAgSGVhcC51cGRhdGVJdGVtID0gdXBkYXRlSXRlbTtcblxuICAgIEhlYXAubmxhcmdlc3QgPSBubGFyZ2VzdDtcblxuICAgIEhlYXAubnNtYWxsZXN0ID0gbnNtYWxsZXN0O1xuXG4gICAgZnVuY3Rpb24gSGVhcChjbXApIHtcbiAgICAgIHRoaXMuY21wID0gY21wICE9IG51bGwgPyBjbXAgOiBkZWZhdWx0Q21wO1xuICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIH1cblxuICAgIEhlYXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaGVhcHB1c2godGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBoZWFwcG9wKHRoaXMubm9kZXMsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF07XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMuaW5kZXhPZih4KSAhPT0gLTE7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaGVhcHJlcGxhY2UodGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wdXNocG9wID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXBwdXNocG9wKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaGVhcGlmeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGhlYXBpZnkodGhpcy5ub2RlcywgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS51cGRhdGVJdGVtID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZUl0ZW0odGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhlYXA7XG4gICAgICBoZWFwID0gbmV3IEhlYXAoKTtcbiAgICAgIGhlYXAubm9kZXMgPSB0aGlzLm5vZGVzLnNsaWNlKDApO1xuICAgICAgcmV0dXJuIGhlYXA7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLnNsaWNlKDApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5pbnNlcnQgPSBIZWFwLnByb3RvdHlwZS5wdXNoO1xuXG4gICAgSGVhcC5wcm90b3R5cGUudG9wID0gSGVhcC5wcm90b3R5cGUucGVlaztcblxuICAgIEhlYXAucHJvdG90eXBlLmZyb250ID0gSGVhcC5wcm90b3R5cGUucGVlaztcblxuICAgIEhlYXAucHJvdG90eXBlLmhhcyA9IEhlYXAucHJvdG90eXBlLmNvbnRhaW5zO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY29weSA9IEhlYXAucHJvdG90eXBlLmNsb25lO1xuXG4gICAgcmV0dXJuIEhlYXA7XG5cbiAgfSkoKTtcblxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUgIT09IG51bGwgPyBtb2R1bGUuZXhwb3J0cyA6IHZvaWQgMCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gSGVhcDtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuSGVhcCA9IEhlYXA7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/heap/lib/heap.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/index.js":
/*!*******************************************!*\
  !*** ./node_modules/pathfinding/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{module.exports = __webpack_require__(/*! ./src/PathFinding */ \"./node_modules/pathfinding/src/PathFinding.js\");\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsOEdBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYWNvbm1hbi8uL25vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9pbmRleC5qcz84MDBlIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvUGF0aEZpbmRpbmcnKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/index.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/PathFinding.js":
/*!*****************************************************!*\
  !*** ./node_modules/pathfinding/src/PathFinding.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{module.exports = {\r\n    'Heap'                      : __webpack_require__(/*! heap */ \"./node_modules/heap/index.js\"),\r\n    'Node'                      : __webpack_require__(/*! ./core/Node */ \"./node_modules/pathfinding/src/core/Node.js\"),\r\n    'Grid'                      : __webpack_require__(/*! ./core/Grid */ \"./node_modules/pathfinding/src/core/Grid.js\"),\r\n    'Util'                      : __webpack_require__(/*! ./core/Util */ \"./node_modules/pathfinding/src/core/Util.js\"),\r\n    'DiagonalMovement'          : __webpack_require__(/*! ./core/DiagonalMovement */ \"./node_modules/pathfinding/src/core/DiagonalMovement.js\"),\r\n    'Heuristic'                 : __webpack_require__(/*! ./core/Heuristic */ \"./node_modules/pathfinding/src/core/Heuristic.js\"),\r\n    'AStarFinder'               : __webpack_require__(/*! ./finders/AStarFinder */ \"./node_modules/pathfinding/src/finders/AStarFinder.js\"),\r\n    'BestFirstFinder'           : __webpack_require__(/*! ./finders/BestFirstFinder */ \"./node_modules/pathfinding/src/finders/BestFirstFinder.js\"),\r\n    'BreadthFirstFinder'        : __webpack_require__(/*! ./finders/BreadthFirstFinder */ \"./node_modules/pathfinding/src/finders/BreadthFirstFinder.js\"),\r\n    'DijkstraFinder'            : __webpack_require__(/*! ./finders/DijkstraFinder */ \"./node_modules/pathfinding/src/finders/DijkstraFinder.js\"),\r\n    'BiAStarFinder'             : __webpack_require__(/*! ./finders/BiAStarFinder */ \"./node_modules/pathfinding/src/finders/BiAStarFinder.js\"),\r\n    'BiBestFirstFinder'         : __webpack_require__(/*! ./finders/BiBestFirstFinder */ \"./node_modules/pathfinding/src/finders/BiBestFirstFinder.js\"),\r\n    'BiBreadthFirstFinder'      : __webpack_require__(/*! ./finders/BiBreadthFirstFinder */ \"./node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js\"),\r\n    'BiDijkstraFinder'          : __webpack_require__(/*! ./finders/BiDijkstraFinder */ \"./node_modules/pathfinding/src/finders/BiDijkstraFinder.js\"),\r\n    'IDAStarFinder'             : __webpack_require__(/*! ./finders/IDAStarFinder */ \"./node_modules/pathfinding/src/finders/IDAStarFinder.js\"),\r\n    'JumpPointFinder'           : __webpack_require__(/*! ./finders/JumpPointFinder */ \"./node_modules/pathfinding/src/finders/JumpPointFinder.js\"),\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL1BhdGhGaW5kaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMsMENBQU07QUFDaEQsa0NBQWtDLG1CQUFPLENBQUMsZ0VBQWE7QUFDdkQsa0NBQWtDLG1CQUFPLENBQUMsZ0VBQWE7QUFDdkQsa0NBQWtDLG1CQUFPLENBQUMsZ0VBQWE7QUFDdkQsa0NBQWtDLG1CQUFPLENBQUMsd0ZBQXlCO0FBQ25FLGtDQUFrQyxtQkFBTyxDQUFDLDBFQUFrQjtBQUM1RCxrQ0FBa0MsbUJBQU8sQ0FBQyxvRkFBdUI7QUFDakUsa0NBQWtDLG1CQUFPLENBQUMsNEZBQTJCO0FBQ3JFLGtDQUFrQyxtQkFBTyxDQUFDLGtHQUE4QjtBQUN4RSxrQ0FBa0MsbUJBQU8sQ0FBQywwRkFBMEI7QUFDcEUsa0NBQWtDLG1CQUFPLENBQUMsd0ZBQXlCO0FBQ25FLGtDQUFrQyxtQkFBTyxDQUFDLGdHQUE2QjtBQUN2RSxrQ0FBa0MsbUJBQU8sQ0FBQyxzR0FBZ0M7QUFDMUUsa0NBQWtDLG1CQUFPLENBQUMsOEZBQTRCO0FBQ3RFLGtDQUFrQyxtQkFBTyxDQUFDLHdGQUF5QjtBQUNuRSxrQ0FBa0MsbUJBQU8sQ0FBQyw0RkFBMkI7QUFDckUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhY29ubWFuLy4vbm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9QYXRoRmluZGluZy5qcz83NTg3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgJ0hlYXAnICAgICAgICAgICAgICAgICAgICAgIDogcmVxdWlyZSgnaGVhcCcpLFxyXG4gICAgJ05vZGUnICAgICAgICAgICAgICAgICAgICAgIDogcmVxdWlyZSgnLi9jb3JlL05vZGUnKSxcclxuICAgICdHcmlkJyAgICAgICAgICAgICAgICAgICAgICA6IHJlcXVpcmUoJy4vY29yZS9HcmlkJyksXHJcbiAgICAnVXRpbCcgICAgICAgICAgICAgICAgICAgICAgOiByZXF1aXJlKCcuL2NvcmUvVXRpbCcpLFxyXG4gICAgJ0RpYWdvbmFsTW92ZW1lbnQnICAgICAgICAgIDogcmVxdWlyZSgnLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnQnKSxcclxuICAgICdIZXVyaXN0aWMnICAgICAgICAgICAgICAgICA6IHJlcXVpcmUoJy4vY29yZS9IZXVyaXN0aWMnKSxcclxuICAgICdBU3RhckZpbmRlcicgICAgICAgICAgICAgICA6IHJlcXVpcmUoJy4vZmluZGVycy9BU3RhckZpbmRlcicpLFxyXG4gICAgJ0Jlc3RGaXJzdEZpbmRlcicgICAgICAgICAgIDogcmVxdWlyZSgnLi9maW5kZXJzL0Jlc3RGaXJzdEZpbmRlcicpLFxyXG4gICAgJ0JyZWFkdGhGaXJzdEZpbmRlcicgICAgICAgIDogcmVxdWlyZSgnLi9maW5kZXJzL0JyZWFkdGhGaXJzdEZpbmRlcicpLFxyXG4gICAgJ0RpamtzdHJhRmluZGVyJyAgICAgICAgICAgIDogcmVxdWlyZSgnLi9maW5kZXJzL0RpamtzdHJhRmluZGVyJyksXHJcbiAgICAnQmlBU3RhckZpbmRlcicgICAgICAgICAgICAgOiByZXF1aXJlKCcuL2ZpbmRlcnMvQmlBU3RhckZpbmRlcicpLFxyXG4gICAgJ0JpQmVzdEZpcnN0RmluZGVyJyAgICAgICAgIDogcmVxdWlyZSgnLi9maW5kZXJzL0JpQmVzdEZpcnN0RmluZGVyJyksXHJcbiAgICAnQmlCcmVhZHRoRmlyc3RGaW5kZXInICAgICAgOiByZXF1aXJlKCcuL2ZpbmRlcnMvQmlCcmVhZHRoRmlyc3RGaW5kZXInKSxcclxuICAgICdCaURpamtzdHJhRmluZGVyJyAgICAgICAgICA6IHJlcXVpcmUoJy4vZmluZGVycy9CaURpamtzdHJhRmluZGVyJyksXHJcbiAgICAnSURBU3RhckZpbmRlcicgICAgICAgICAgICAgOiByZXF1aXJlKCcuL2ZpbmRlcnMvSURBU3RhckZpbmRlcicpLFxyXG4gICAgJ0p1bXBQb2ludEZpbmRlcicgICAgICAgICAgIDogcmVxdWlyZSgnLi9maW5kZXJzL0p1bXBQb2ludEZpbmRlcicpLFxyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/PathFinding.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/core/DiagonalMovement.js":
/*!***************************************************************!*\
  !*** ./node_modules/pathfinding/src/core/DiagonalMovement.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("{var DiagonalMovement = {\r\n    Always: 1,\r\n    Never: 2,\r\n    IfAtMostOneObstacle: 3,\r\n    OnlyWhenNoObstacles: 4\r\n};\r\n\r\nmodule.exports = DiagonalMovement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2NvcmUvRGlhZ29uYWxNb3ZlbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYWNvbm1hbi8uL25vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvY29yZS9EaWFnb25hbE1vdmVtZW50LmpzPzM5ZTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIERpYWdvbmFsTW92ZW1lbnQgPSB7XHJcbiAgICBBbHdheXM6IDEsXHJcbiAgICBOZXZlcjogMixcclxuICAgIElmQXRNb3N0T25lT2JzdGFjbGU6IDMsXHJcbiAgICBPbmx5V2hlbk5vT2JzdGFjbGVzOiA0XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERpYWdvbmFsTW92ZW1lbnQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/core/DiagonalMovement.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/core/Grid.js":
/*!***************************************************!*\
  !*** ./node_modules/pathfinding/src/core/Grid.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var Node = __webpack_require__(/*! ./Node */ \"./node_modules/pathfinding/src/core/Node.js\");\r\nvar DiagonalMovement = __webpack_require__(/*! ./DiagonalMovement */ \"./node_modules/pathfinding/src/core/DiagonalMovement.js\");\r\n\r\n/**\r\n * The Grid class, which serves as the encapsulation of the layout of the nodes.\r\n * @constructor\r\n * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix\r\n * @param {number} height Number of rows of the grid.\r\n * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix\r\n *     representing the walkable status of the nodes(0 or false for walkable).\r\n *     If the matrix is not supplied, all the nodes will be walkable.  */\r\nfunction Grid(width_or_matrix, height, matrix) {\r\n    var width;\r\n\r\n    if (typeof width_or_matrix !== 'object') {\r\n        width = width_or_matrix;\r\n    } else {\r\n        height = width_or_matrix.length;\r\n        width = width_or_matrix[0].length;\r\n        matrix = width_or_matrix;\r\n    }\r\n\r\n    /**\r\n     * The number of columns of the grid.\r\n     * @type number\r\n     */\r\n    this.width = width;\r\n    /**\r\n     * The number of rows of the grid.\r\n     * @type number\r\n     */\r\n    this.height = height;\r\n\r\n    /**\r\n     * A 2D array of nodes.\r\n     */\r\n    this.nodes = this._buildNodes(width, height, matrix);\r\n}\r\n\r\n/**\r\n * Build and return the nodes.\r\n * @private\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing\r\n *     the walkable status of the nodes.\r\n * @see Grid\r\n */\r\nGrid.prototype._buildNodes = function(width, height, matrix) {\r\n    var i, j,\r\n        nodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        nodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            nodes[i][j] = new Node(j, i);\r\n        }\r\n    }\r\n\r\n\r\n    if (matrix === undefined) {\r\n        return nodes;\r\n    }\r\n\r\n    if (matrix.length !== height || matrix[0].length !== width) {\r\n        throw new Error('Matrix size does not fit');\r\n    }\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        for (j = 0; j < width; ++j) {\r\n            if (matrix[i][j]) {\r\n                // 0, false, null will be walkable\r\n                // while others will be un-walkable\r\n                nodes[i][j].walkable = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n};\r\n\r\n\r\nGrid.prototype.getNodeAt = function(x, y) {\r\n    return this.nodes[y][x];\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the node at the given position is walkable.\r\n * (Also returns false if the position is outside the grid.)\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @return {boolean} - The walkability of the node.\r\n */\r\nGrid.prototype.isWalkableAt = function(x, y) {\r\n    return this.isInside(x, y) && this.nodes[y][x].walkable;\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the position is inside the grid.\r\n * XXX: `grid.isInside(x, y)` is wierd to read.\r\n * It should be `(x, y) is inside grid`, but I failed to find a better\r\n * name for this method.\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nGrid.prototype.isInside = function(x, y) {\r\n    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);\r\n};\r\n\r\n\r\n/**\r\n * Set whether the node on the given position is walkable.\r\n * NOTE: throws exception if the coordinate is not inside the grid.\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @param {boolean} walkable - Whether the position is walkable.\r\n */\r\nGrid.prototype.setWalkableAt = function(x, y, walkable) {\r\n    this.nodes[y][x].walkable = walkable;\r\n};\r\n\r\n\r\n/**\r\n * Get the neighbors of the given node.\r\n *\r\n *     offsets      diagonalOffsets:\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 0 |   |    | 0 |   | 1 |\r\n *  +---+---+---+    +---+---+---+\r\n *  | 3 |   | 1 |    |   |   |   |\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 2 |   |    | 3 |   | 2 |\r\n *  +---+---+---+    +---+---+---+\r\n *\r\n *  When allowDiagonal is true, if offsets[i] is valid, then\r\n *  diagonalOffsets[i] and\r\n *  diagonalOffsets[(i + 1) % 4] is valid.\r\n * @param {Node} node\r\n * @param {DiagonalMovement} diagonalMovement\r\n */\r\nGrid.prototype.getNeighbors = function(node, diagonalMovement) {\r\n    var x = node.x,\r\n        y = node.y,\r\n        neighbors = [],\r\n        s0 = false, d0 = false,\r\n        s1 = false, d1 = false,\r\n        s2 = false, d2 = false,\r\n        s3 = false, d3 = false,\r\n        nodes = this.nodes;\r\n\r\n    // \r\n    if (this.isWalkableAt(x, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x]);\r\n        s0 = true;\r\n    }\r\n    // \r\n    if (this.isWalkableAt(x + 1, y)) {\r\n        neighbors.push(nodes[y][x + 1]);\r\n        s1 = true;\r\n    }\r\n    // \r\n    if (this.isWalkableAt(x, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x]);\r\n        s2 = true;\r\n    }\r\n    // \r\n    if (this.isWalkableAt(x - 1, y)) {\r\n        neighbors.push(nodes[y][x - 1]);\r\n        s3 = true;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.Never) {\r\n        return neighbors;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        d0 = s3 && s0;\r\n        d1 = s0 && s1;\r\n        d2 = s1 && s2;\r\n        d3 = s2 && s3;\r\n    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {\r\n        d0 = s3 || s0;\r\n        d1 = s0 || s1;\r\n        d2 = s1 || s2;\r\n        d3 = s2 || s3;\r\n    } else if (diagonalMovement === DiagonalMovement.Always) {\r\n        d0 = true;\r\n        d1 = true;\r\n        d2 = true;\r\n        d3 = true;\r\n    } else {\r\n        throw new Error('Incorrect value of diagonalMovement');\r\n    }\r\n\r\n    // \r\n    if (d0 && this.isWalkableAt(x - 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x - 1]);\r\n    }\r\n    // \r\n    if (d1 && this.isWalkableAt(x + 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x + 1]);\r\n    }\r\n    // \r\n    if (d2 && this.isWalkableAt(x + 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x + 1]);\r\n    }\r\n    // \r\n    if (d3 && this.isWalkableAt(x - 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x - 1]);\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\n\r\n/**\r\n * Get a clone of this grid.\r\n * @return {Grid} Cloned grid.\r\n */\r\nGrid.prototype.clone = function() {\r\n    var i, j,\r\n\r\n        width = this.width,\r\n        height = this.height,\r\n        thisNodes = this.nodes,\r\n\r\n        newGrid = new Grid(width, height),\r\n        newNodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        newNodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);\r\n        }\r\n    }\r\n\r\n    newGrid.nodes = newNodes;\r\n\r\n    return newGrid;\r\n};\r\n\r\nmodule.exports = Grid;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2NvcmUvR3JpZC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsMkRBQVE7QUFDM0IsdUJBQXVCLG1CQUFPLENBQUMsbUZBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLDhCQUE4QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhY29ubWFuLy4vbm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9jb3JlL0dyaWQuanM/N2U1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xyXG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IHJlcXVpcmUoJy4vRGlhZ29uYWxNb3ZlbWVudCcpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBHcmlkIGNsYXNzLCB3aGljaCBzZXJ2ZXMgYXMgdGhlIGVuY2Fwc3VsYXRpb24gb2YgdGhlIGxheW91dCBvZiB0aGUgbm9kZXMuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge251bWJlcnxBcnJheTxBcnJheTwobnVtYmVyfGJvb2xlYW4pPj59IHdpZHRoX29yX21hdHJpeCBOdW1iZXIgb2YgY29sdW1ucyBvZiB0aGUgZ3JpZCwgb3IgbWF0cml4XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgTnVtYmVyIG9mIHJvd3Mgb2YgdGhlIGdyaWQuXHJcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8KG51bWJlcnxib29sZWFuKT4+fSBbbWF0cml4XSAtIEEgMC0xIG1hdHJpeFxyXG4gKiAgICAgcmVwcmVzZW50aW5nIHRoZSB3YWxrYWJsZSBzdGF0dXMgb2YgdGhlIG5vZGVzKDAgb3IgZmFsc2UgZm9yIHdhbGthYmxlKS5cclxuICogICAgIElmIHRoZSBtYXRyaXggaXMgbm90IHN1cHBsaWVkLCBhbGwgdGhlIG5vZGVzIHdpbGwgYmUgd2Fsa2FibGUuICAqL1xyXG5mdW5jdGlvbiBHcmlkKHdpZHRoX29yX21hdHJpeCwgaGVpZ2h0LCBtYXRyaXgpIHtcclxuICAgIHZhciB3aWR0aDtcclxuXHJcbiAgICBpZiAodHlwZW9mIHdpZHRoX29yX21hdHJpeCAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICB3aWR0aCA9IHdpZHRoX29yX21hdHJpeDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaGVpZ2h0ID0gd2lkdGhfb3JfbWF0cml4Lmxlbmd0aDtcclxuICAgICAgICB3aWR0aCA9IHdpZHRoX29yX21hdHJpeFswXS5sZW5ndGg7XHJcbiAgICAgICAgbWF0cml4ID0gd2lkdGhfb3JfbWF0cml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiBjb2x1bW5zIG9mIHRoZSBncmlkLlxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiByb3dzIG9mIHRoZSBncmlkLlxyXG4gICAgICogQHR5cGUgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSAyRCBhcnJheSBvZiBub2Rlcy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5ub2RlcyA9IHRoaXMuX2J1aWxkTm9kZXMod2lkdGgsIGhlaWdodCwgbWF0cml4KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkIGFuZCByZXR1cm4gdGhlIG5vZGVzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxyXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcnxib29sZWFuPj59IFttYXRyaXhdIC0gQSAwLTEgbWF0cml4IHJlcHJlc2VudGluZ1xyXG4gKiAgICAgdGhlIHdhbGthYmxlIHN0YXR1cyBvZiB0aGUgbm9kZXMuXHJcbiAqIEBzZWUgR3JpZFxyXG4gKi9cclxuR3JpZC5wcm90b3R5cGUuX2J1aWxkTm9kZXMgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBtYXRyaXgpIHtcclxuICAgIHZhciBpLCBqLFxyXG4gICAgICAgIG5vZGVzID0gbmV3IEFycmF5KGhlaWdodCk7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGhlaWdodDsgKytpKSB7XHJcbiAgICAgICAgbm9kZXNbaV0gPSBuZXcgQXJyYXkod2lkdGgpO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCB3aWR0aDsgKytqKSB7XHJcbiAgICAgICAgICAgIG5vZGVzW2ldW2pdID0gbmV3IE5vZGUoaiwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAobWF0cml4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1hdHJpeC5sZW5ndGggIT09IGhlaWdodCB8fCBtYXRyaXhbMF0ubGVuZ3RoICE9PSB3aWR0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWF0cml4IHNpemUgZG9lcyBub3QgZml0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGhlaWdodDsgKytpKSB7XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHdpZHRoOyArK2opIHtcclxuICAgICAgICAgICAgaWYgKG1hdHJpeFtpXVtqXSkge1xyXG4gICAgICAgICAgICAgICAgLy8gMCwgZmFsc2UsIG51bGwgd2lsbCBiZSB3YWxrYWJsZVxyXG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgb3RoZXJzIHdpbGwgYmUgdW4td2Fsa2FibGVcclxuICAgICAgICAgICAgICAgIG5vZGVzW2ldW2pdLndhbGthYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5vZGVzO1xyXG59O1xyXG5cclxuXHJcbkdyaWQucHJvdG90eXBlLmdldE5vZGVBdCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLm5vZGVzW3ldW3hdO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgd2Fsa2FibGUuXHJcbiAqIChBbHNvIHJldHVybnMgZmFsc2UgaWYgdGhlIHBvc2l0aW9uIGlzIG91dHNpZGUgdGhlIGdyaWQuKVxyXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIG5vZGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZS5cclxuICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgd2Fsa2FiaWxpdHkgb2YgdGhlIG5vZGUuXHJcbiAqL1xyXG5HcmlkLnByb3RvdHlwZS5pc1dhbGthYmxlQXQgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5pc0luc2lkZSh4LCB5KSAmJiB0aGlzLm5vZGVzW3ldW3hdLndhbGthYmxlO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgcG9zaXRpb24gaXMgaW5zaWRlIHRoZSBncmlkLlxyXG4gKiBYWFg6IGBncmlkLmlzSW5zaWRlKHgsIHkpYCBpcyB3aWVyZCB0byByZWFkLlxyXG4gKiBJdCBzaG91bGQgYmUgYCh4LCB5KSBpcyBpbnNpZGUgZ3JpZGAsIGJ1dCBJIGZhaWxlZCB0byBmaW5kIGEgYmV0dGVyXHJcbiAqIG5hbWUgZm9yIHRoaXMgbWV0aG9kLlxyXG4gKiBAcGFyYW0ge251bWJlcn0geFxyXG4gKiBAcGFyYW0ge251bWJlcn0geVxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKi9cclxuR3JpZC5wcm90b3R5cGUuaXNJbnNpZGUgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICByZXR1cm4gKHggPj0gMCAmJiB4IDwgdGhpcy53aWR0aCkgJiYgKHkgPj0gMCAmJiB5IDwgdGhpcy5oZWlnaHQpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXQgd2hldGhlciB0aGUgbm9kZSBvbiB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgd2Fsa2FibGUuXHJcbiAqIE5PVEU6IHRocm93cyBleGNlcHRpb24gaWYgdGhlIGNvb3JkaW5hdGUgaXMgbm90IGluc2lkZSB0aGUgZ3JpZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIG5vZGUuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gd2Fsa2FibGUgLSBXaGV0aGVyIHRoZSBwb3NpdGlvbiBpcyB3YWxrYWJsZS5cclxuICovXHJcbkdyaWQucHJvdG90eXBlLnNldFdhbGthYmxlQXQgPSBmdW5jdGlvbih4LCB5LCB3YWxrYWJsZSkge1xyXG4gICAgdGhpcy5ub2Rlc1t5XVt4XS53YWxrYWJsZSA9IHdhbGthYmxlO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIG5laWdoYm9ycyBvZiB0aGUgZ2l2ZW4gbm9kZS5cclxuICpcclxuICogICAgIG9mZnNldHMgICAgICBkaWFnb25hbE9mZnNldHM6XHJcbiAqICArLS0tKy0tLSstLS0rICAgICstLS0rLS0tKy0tLStcclxuICogIHwgICB8IDAgfCAgIHwgICAgfCAwIHwgICB8IDEgfFxyXG4gKiAgKy0tLSstLS0rLS0tKyAgICArLS0tKy0tLSstLS0rXHJcbiAqICB8IDMgfCAgIHwgMSB8ICAgIHwgICB8ICAgfCAgIHxcclxuICogICstLS0rLS0tKy0tLSsgICAgKy0tLSstLS0rLS0tK1xyXG4gKiAgfCAgIHwgMiB8ICAgfCAgICB8IDMgfCAgIHwgMiB8XHJcbiAqICArLS0tKy0tLSstLS0rICAgICstLS0rLS0tKy0tLStcclxuICpcclxuICogIFdoZW4gYWxsb3dEaWFnb25hbCBpcyB0cnVlLCBpZiBvZmZzZXRzW2ldIGlzIHZhbGlkLCB0aGVuXHJcbiAqICBkaWFnb25hbE9mZnNldHNbaV0gYW5kXHJcbiAqICBkaWFnb25hbE9mZnNldHNbKGkgKyAxKSAlIDRdIGlzIHZhbGlkLlxyXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICogQHBhcmFtIHtEaWFnb25hbE1vdmVtZW50fSBkaWFnb25hbE1vdmVtZW50XHJcbiAqL1xyXG5HcmlkLnByb3RvdHlwZS5nZXROZWlnaGJvcnMgPSBmdW5jdGlvbihub2RlLCBkaWFnb25hbE1vdmVtZW50KSB7XHJcbiAgICB2YXIgeCA9IG5vZGUueCxcclxuICAgICAgICB5ID0gbm9kZS55LFxyXG4gICAgICAgIG5laWdoYm9ycyA9IFtdLFxyXG4gICAgICAgIHMwID0gZmFsc2UsIGQwID0gZmFsc2UsXHJcbiAgICAgICAgczEgPSBmYWxzZSwgZDEgPSBmYWxzZSxcclxuICAgICAgICBzMiA9IGZhbHNlLCBkMiA9IGZhbHNlLFxyXG4gICAgICAgIHMzID0gZmFsc2UsIGQzID0gZmFsc2UsXHJcbiAgICAgICAgbm9kZXMgPSB0aGlzLm5vZGVzO1xyXG5cclxuICAgIC8vIOKGkVxyXG4gICAgaWYgKHRoaXMuaXNXYWxrYWJsZUF0KHgsIHkgLSAxKSkge1xyXG4gICAgICAgIG5laWdoYm9ycy5wdXNoKG5vZGVzW3kgLSAxXVt4XSk7XHJcbiAgICAgICAgczAgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8g4oaSXHJcbiAgICBpZiAodGhpcy5pc1dhbGthYmxlQXQoeCArIDEsIHkpKSB7XHJcbiAgICAgICAgbmVpZ2hib3JzLnB1c2gobm9kZXNbeV1beCArIDFdKTtcclxuICAgICAgICBzMSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyDihpNcclxuICAgIGlmICh0aGlzLmlzV2Fsa2FibGVBdCh4LCB5ICsgMSkpIHtcclxuICAgICAgICBuZWlnaGJvcnMucHVzaChub2Rlc1t5ICsgMV1beF0pO1xyXG4gICAgICAgIHMyID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIOKGkFxyXG4gICAgaWYgKHRoaXMuaXNXYWxrYWJsZUF0KHggLSAxLCB5KSkge1xyXG4gICAgICAgIG5laWdoYm9ycy5wdXNoKG5vZGVzW3ldW3ggLSAxXSk7XHJcbiAgICAgICAgczMgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkaWFnb25hbE1vdmVtZW50ID09PSBEaWFnb25hbE1vdmVtZW50Lk5ldmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5laWdoYm9ycztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGlhZ29uYWxNb3ZlbWVudCA9PT0gRGlhZ29uYWxNb3ZlbWVudC5Pbmx5V2hlbk5vT2JzdGFjbGVzKSB7XHJcbiAgICAgICAgZDAgPSBzMyAmJiBzMDtcclxuICAgICAgICBkMSA9IHMwICYmIHMxO1xyXG4gICAgICAgIGQyID0gczEgJiYgczI7XHJcbiAgICAgICAgZDMgPSBzMiAmJiBzMztcclxuICAgIH0gZWxzZSBpZiAoZGlhZ29uYWxNb3ZlbWVudCA9PT0gRGlhZ29uYWxNb3ZlbWVudC5JZkF0TW9zdE9uZU9ic3RhY2xlKSB7XHJcbiAgICAgICAgZDAgPSBzMyB8fCBzMDtcclxuICAgICAgICBkMSA9IHMwIHx8IHMxO1xyXG4gICAgICAgIGQyID0gczEgfHwgczI7XHJcbiAgICAgICAgZDMgPSBzMiB8fCBzMztcclxuICAgIH0gZWxzZSBpZiAoZGlhZ29uYWxNb3ZlbWVudCA9PT0gRGlhZ29uYWxNb3ZlbWVudC5BbHdheXMpIHtcclxuICAgICAgICBkMCA9IHRydWU7XHJcbiAgICAgICAgZDEgPSB0cnVlO1xyXG4gICAgICAgIGQyID0gdHJ1ZTtcclxuICAgICAgICBkMyA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IHZhbHVlIG9mIGRpYWdvbmFsTW92ZW1lbnQnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDihpZcclxuICAgIGlmIChkMCAmJiB0aGlzLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSAtIDEpKSB7XHJcbiAgICAgICAgbmVpZ2hib3JzLnB1c2gobm9kZXNbeSAtIDFdW3ggLSAxXSk7XHJcbiAgICB9XHJcbiAgICAvLyDihpdcclxuICAgIGlmIChkMSAmJiB0aGlzLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSAtIDEpKSB7XHJcbiAgICAgICAgbmVpZ2hib3JzLnB1c2gobm9kZXNbeSAtIDFdW3ggKyAxXSk7XHJcbiAgICB9XHJcbiAgICAvLyDihphcclxuICAgIGlmIChkMiAmJiB0aGlzLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSArIDEpKSB7XHJcbiAgICAgICAgbmVpZ2hib3JzLnB1c2gobm9kZXNbeSArIDFdW3ggKyAxXSk7XHJcbiAgICB9XHJcbiAgICAvLyDihplcclxuICAgIGlmIChkMyAmJiB0aGlzLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSArIDEpKSB7XHJcbiAgICAgICAgbmVpZ2hib3JzLnB1c2gobm9kZXNbeSArIDFdW3ggLSAxXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5laWdoYm9ycztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogR2V0IGEgY2xvbmUgb2YgdGhpcyBncmlkLlxyXG4gKiBAcmV0dXJuIHtHcmlkfSBDbG9uZWQgZ3JpZC5cclxuICovXHJcbkdyaWQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgaSwgaixcclxuXHJcbiAgICAgICAgd2lkdGggPSB0aGlzLndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgIHRoaXNOb2RlcyA9IHRoaXMubm9kZXMsXHJcblxyXG4gICAgICAgIG5ld0dyaWQgPSBuZXcgR3JpZCh3aWR0aCwgaGVpZ2h0KSxcclxuICAgICAgICBuZXdOb2RlcyA9IG5ldyBBcnJheShoZWlnaHQpO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBoZWlnaHQ7ICsraSkge1xyXG4gICAgICAgIG5ld05vZGVzW2ldID0gbmV3IEFycmF5KHdpZHRoKTtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgd2lkdGg7ICsraikge1xyXG4gICAgICAgICAgICBuZXdOb2Rlc1tpXVtqXSA9IG5ldyBOb2RlKGosIGksIHRoaXNOb2Rlc1tpXVtqXS53YWxrYWJsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG5ld0dyaWQubm9kZXMgPSBuZXdOb2RlcztcclxuXHJcbiAgICByZXR1cm4gbmV3R3JpZDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR3JpZDtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/core/Grid.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/core/Heuristic.js":
/*!********************************************************!*\
  !*** ./node_modules/pathfinding/src/core/Heuristic.js ***!
  \********************************************************/
/***/ ((module) => {

eval("{/**\r\n * @namespace PF.Heuristic\r\n * @description A collection of heuristic functions.\r\n */\r\nmodule.exports = {\r\n\r\n  /**\r\n   * Manhattan distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} dx + dy\r\n   */\r\n  manhattan: function(dx, dy) {\r\n      return dx + dy;\r\n  },\r\n\r\n  /**\r\n   * Euclidean distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy)\r\n   */\r\n  euclidean: function(dx, dy) {\r\n      return Math.sqrt(dx * dx + dy * dy);\r\n  },\r\n\r\n  /**\r\n   * Octile distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy) for grids\r\n   */\r\n  octile: function(dx, dy) {\r\n      var F = Math.SQRT2 - 1;\r\n      return (dx < dy) ? F * dx + dy : F * dy + dx;\r\n  },\r\n\r\n  /**\r\n   * Chebyshev distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} max(dx, dy)\r\n   */\r\n  chebyshev: function(dx, dy) {\r\n      return Math.max(dx, dy);\r\n  }\r\n\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2NvcmUvSGV1cmlzdGljLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmFjb25tYW4vLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2NvcmUvSGV1cmlzdGljLmpzPzAwYzUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBuYW1lc3BhY2UgUEYuSGV1cmlzdGljXHJcbiAqIEBkZXNjcmlwdGlvbiBBIGNvbGxlY3Rpb24gb2YgaGV1cmlzdGljIGZ1bmN0aW9ucy5cclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAvKipcclxuICAgKiBNYW5oYXR0YW4gZGlzdGFuY2UuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR4IC0gRGlmZmVyZW5jZSBpbiB4LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeSAtIERpZmZlcmVuY2UgaW4geS5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGR4ICsgZHlcclxuICAgKi9cclxuICBtYW5oYXR0YW46IGZ1bmN0aW9uKGR4LCBkeSkge1xyXG4gICAgICByZXR1cm4gZHggKyBkeTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBFdWNsaWRlYW4gZGlzdGFuY2UuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR4IC0gRGlmZmVyZW5jZSBpbiB4LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeSAtIERpZmZlcmVuY2UgaW4geS5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpXHJcbiAgICovXHJcbiAgZXVjbGlkZWFuOiBmdW5jdGlvbihkeCwgZHkpIHtcclxuICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogT2N0aWxlIGRpc3RhbmNlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeCAtIERpZmZlcmVuY2UgaW4geC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHkgLSBEaWZmZXJlbmNlIGluIHkuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBzcXJ0KGR4ICogZHggKyBkeSAqIGR5KSBmb3IgZ3JpZHNcclxuICAgKi9cclxuICBvY3RpbGU6IGZ1bmN0aW9uKGR4LCBkeSkge1xyXG4gICAgICB2YXIgRiA9IE1hdGguU1FSVDIgLSAxO1xyXG4gICAgICByZXR1cm4gKGR4IDwgZHkpID8gRiAqIGR4ICsgZHkgOiBGICogZHkgKyBkeDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBDaGVieXNoZXYgZGlzdGFuY2UuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR4IC0gRGlmZmVyZW5jZSBpbiB4LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeSAtIERpZmZlcmVuY2UgaW4geS5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IG1heChkeCwgZHkpXHJcbiAgICovXHJcbiAgY2hlYnlzaGV2OiBmdW5jdGlvbihkeCwgZHkpIHtcclxuICAgICAgcmV0dXJuIE1hdGgubWF4KGR4LCBkeSk7XHJcbiAgfVxyXG5cclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/core/Heuristic.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/core/Node.js":
/*!***************************************************!*\
  !*** ./node_modules/pathfinding/src/core/Node.js ***!
  \***************************************************/
/***/ ((module) => {

eval("{/**\r\n * A node in grid. \r\n * This class holds some basic information about a node and custom \r\n * attributes may be added, depending on the algorithms' needs.\r\n * @constructor\r\n * @param {number} x - The x coordinate of the node on the grid.\r\n * @param {number} y - The y coordinate of the node on the grid.\r\n * @param {boolean} [walkable] - Whether this node is walkable.\r\n */\r\nfunction Node(x, y, walkable) {\r\n    /**\r\n     * The x coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.x = x;\r\n    /**\r\n     * The y coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.y = y;\r\n    /**\r\n     * Whether this node can be walked through.\r\n     * @type boolean\r\n     */\r\n    this.walkable = (walkable === undefined ? true : walkable);\r\n}\r\n\r\nmodule.exports = Node;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2NvcmUvTm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmFjb25tYW4vLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2NvcmUvTm9kZS5qcz80ZDY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBBIG5vZGUgaW4gZ3JpZC4gXHJcbiAqIFRoaXMgY2xhc3MgaG9sZHMgc29tZSBiYXNpYyBpbmZvcm1hdGlvbiBhYm91dCBhIG5vZGUgYW5kIGN1c3RvbSBcclxuICogYXR0cmlidXRlcyBtYXkgYmUgYWRkZWQsIGRlcGVuZGluZyBvbiB0aGUgYWxnb3JpdGhtcycgbmVlZHMuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIG5vZGUgb24gdGhlIGdyaWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZSBvbiB0aGUgZ3JpZC5cclxuICogQHBhcmFtIHtib29sZWFufSBbd2Fsa2FibGVdIC0gV2hldGhlciB0aGlzIG5vZGUgaXMgd2Fsa2FibGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBOb2RlKHgsIHksIHdhbGthYmxlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIG5vZGUgb24gdGhlIGdyaWQuXHJcbiAgICAgKiBAdHlwZSBudW1iZXJcclxuICAgICAqL1xyXG4gICAgdGhpcy54ID0geDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZSBvbiB0aGUgZ3JpZC5cclxuICAgICAqIEB0eXBlIG51bWJlclxyXG4gICAgICovXHJcbiAgICB0aGlzLnkgPSB5O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgbm9kZSBjYW4gYmUgd2Fsa2VkIHRocm91Z2guXHJcbiAgICAgKiBAdHlwZSBib29sZWFuXHJcbiAgICAgKi9cclxuICAgIHRoaXMud2Fsa2FibGUgPSAod2Fsa2FibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiB3YWxrYWJsZSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTm9kZTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/core/Node.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/core/Util.js":
/*!***************************************************!*\
  !*** ./node_modules/pathfinding/src/core/Util.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("{/**\r\n * Backtrace according to the parent records and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node} node End node\r\n * @return {Array<Array<number>>} the path\r\n */\r\nfunction backtrace(node) {\r\n    var path = [[node.x, node.y]];\r\n    while (node.parent) {\r\n        node = node.parent;\r\n        path.push([node.x, node.y]);\r\n    }\r\n    return path.reverse();\r\n}\r\nexports.backtrace = backtrace;\r\n\r\n/**\r\n * Backtrace from start and end node, and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node}\r\n * @param {Node}\r\n */\r\nfunction biBacktrace(nodeA, nodeB) {\r\n    var pathA = backtrace(nodeA),\r\n        pathB = backtrace(nodeB);\r\n    return pathA.concat(pathB.reverse());\r\n}\r\nexports.biBacktrace = biBacktrace;\r\n\r\n/**\r\n * Compute the length of the path.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {number} The length of the path\r\n */\r\nfunction pathLength(path) {\r\n    var i, sum = 0, a, b, dx, dy;\r\n    for (i = 1; i < path.length; ++i) {\r\n        a = path[i - 1];\r\n        b = path[i];\r\n        dx = a[0] - b[0];\r\n        dy = a[1] - b[1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    return sum;\r\n}\r\nexports.pathLength = pathLength;\r\n\r\n\r\n/**\r\n * Given the start and end coordinates, return all the coordinates lying\r\n * on the line formed by these coordinates, based on Bresenham's algorithm.\r\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\r\n * @param {number} x0 Start x coordinate\r\n * @param {number} y0 Start y coordinate\r\n * @param {number} x1 End x coordinate\r\n * @param {number} y1 End y coordinate\r\n * @return {Array<Array<number>>} The coordinates on the line\r\n */\r\nfunction interpolate(x0, y0, x1, y1) {\r\n    var abs = Math.abs,\r\n        line = [],\r\n        sx, sy, dx, dy, err, e2;\r\n\r\n    dx = abs(x1 - x0);\r\n    dy = abs(y1 - y0);\r\n\r\n    sx = (x0 < x1) ? 1 : -1;\r\n    sy = (y0 < y1) ? 1 : -1;\r\n\r\n    err = dx - dy;\r\n\r\n    while (true) {\r\n        line.push([x0, y0]);\r\n\r\n        if (x0 === x1 && y0 === y1) {\r\n            break;\r\n        }\r\n        \r\n        e2 = 2 * err;\r\n        if (e2 > -dy) {\r\n            err = err - dy;\r\n            x0 = x0 + sx;\r\n        }\r\n        if (e2 < dx) {\r\n            err = err + dx;\r\n            y0 = y0 + sy;\r\n        }\r\n    }\r\n\r\n    return line;\r\n}\r\nexports.interpolate = interpolate;\r\n\r\n\r\n/**\r\n * Given a compressed path, return a new path that has all the segments\r\n * in it interpolated.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} expanded path\r\n */\r\nfunction expandPath(path) {\r\n    var expanded = [],\r\n        len = path.length,\r\n        coord0, coord1,\r\n        interpolated,\r\n        interpolatedLen,\r\n        i, j;\r\n\r\n    if (len < 2) {\r\n        return expanded;\r\n    }\r\n\r\n    for (i = 0; i < len - 1; ++i) {\r\n        coord0 = path[i];\r\n        coord1 = path[i + 1];\r\n\r\n        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\r\n        interpolatedLen = interpolated.length;\r\n        for (j = 0; j < interpolatedLen - 1; ++j) {\r\n            expanded.push(interpolated[j]);\r\n        }\r\n    }\r\n    expanded.push(path[len - 1]);\r\n\r\n    return expanded;\r\n}\r\nexports.expandPath = expandPath;\r\n\r\n\r\n/**\r\n * Smoothen the give path.\r\n * The original path will not be modified; a new path will be returned.\r\n * @param {PF.Grid} grid\r\n * @param {Array<Array<number>>} path The path\r\n */\r\nfunction smoothenPath(grid, path) {\r\n    var len = path.length,\r\n        x0 = path[0][0],        // path start x\r\n        y0 = path[0][1],        // path start y\r\n        x1 = path[len - 1][0],  // path end x\r\n        y1 = path[len - 1][1],  // path end y\r\n        sx, sy,                 // current start coordinate\r\n        ex, ey,                 // current end coordinate\r\n        newPath,\r\n        i, j, coord, line, testCoord, blocked;\r\n\r\n    sx = x0;\r\n    sy = y0;\r\n    newPath = [[sx, sy]];\r\n\r\n    for (i = 2; i < len; ++i) {\r\n        coord = path[i];\r\n        ex = coord[0];\r\n        ey = coord[1];\r\n        line = interpolate(sx, sy, ex, ey);\r\n\r\n        blocked = false;\r\n        for (j = 1; j < line.length; ++j) {\r\n            testCoord = line[j];\r\n\r\n            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\r\n                blocked = true;\r\n                break;\r\n            }\r\n        }\r\n        if (blocked) {\r\n            lastValidCoord = path[i - 1];\r\n            newPath.push(lastValidCoord);\r\n            sx = lastValidCoord[0];\r\n            sy = lastValidCoord[1];\r\n        }\r\n    }\r\n    newPath.push([x1, y1]);\r\n\r\n    return newPath;\r\n}\r\nexports.smoothenPath = smoothenPath;\r\n\r\n\r\n/**\r\n * Compress a path, remove redundant nodes without altering the shape\r\n * The original path is not modified\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} The compressed path\r\n */\r\nfunction compressPath(path) {\r\n\r\n    // nothing to compress\r\n    if(path.length < 3) {\r\n        return path;\r\n    }\r\n\r\n    var compressed = [],\r\n        sx = path[0][0], // start x\r\n        sy = path[0][1], // start y\r\n        px = path[1][0], // second point x\r\n        py = path[1][1], // second point y\r\n        dx = px - sx, // direction between the two points\r\n        dy = py - sy, // direction between the two points\r\n        lx, ly,\r\n        ldx, ldy,\r\n        sq, i;\r\n\r\n    // normalize the direction\r\n    sq = Math.sqrt(dx*dx + dy*dy);\r\n    dx /= sq;\r\n    dy /= sq;\r\n\r\n    // start the new path\r\n    compressed.push([sx,sy]);\r\n\r\n    for(i = 2; i < path.length; i++) {\r\n\r\n        // store the last point\r\n        lx = px;\r\n        ly = py;\r\n\r\n        // store the last direction\r\n        ldx = dx;\r\n        ldy = dy;\r\n\r\n        // next point\r\n        px = path[i][0];\r\n        py = path[i][1];\r\n\r\n        // next direction\r\n        dx = px - lx;\r\n        dy = py - ly;\r\n\r\n        // normalize\r\n        sq = Math.sqrt(dx*dx + dy*dy);\r\n        dx /= sq;\r\n        dy /= sq;\r\n\r\n        // if the direction has changed, store the point\r\n        if ( dx !== ldx || dy !== ldy ) {\r\n            compressed.push([lx,ly]);\r\n        }\r\n    }\r\n\r\n    // store the last point\r\n    compressed.push([px,py]);\r\n\r\n    return compressed;\r\n}\r\nexports.compressPath = compressPath;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2NvcmUvVXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmFjb25tYW4vLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2NvcmUvVXRpbC5qcz84M2JmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBCYWNrdHJhY2UgYWNjb3JkaW5nIHRvIHRoZSBwYXJlbnQgcmVjb3JkcyBhbmQgcmV0dXJuIHRoZSBwYXRoLlxyXG4gKiAoaW5jbHVkaW5nIGJvdGggc3RhcnQgYW5kIGVuZCBub2RlcylcclxuICogQHBhcmFtIHtOb2RlfSBub2RlIEVuZCBub2RlXHJcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSB0aGUgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gYmFja3RyYWNlKG5vZGUpIHtcclxuICAgIHZhciBwYXRoID0gW1tub2RlLngsIG5vZGUueV1dO1xyXG4gICAgd2hpbGUgKG5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xyXG4gICAgICAgIHBhdGgucHVzaChbbm9kZS54LCBub2RlLnldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoLnJldmVyc2UoKTtcclxufVxyXG5leHBvcnRzLmJhY2t0cmFjZSA9IGJhY2t0cmFjZTtcclxuXHJcbi8qKlxyXG4gKiBCYWNrdHJhY2UgZnJvbSBzdGFydCBhbmQgZW5kIG5vZGUsIGFuZCByZXR1cm4gdGhlIHBhdGguXHJcbiAqIChpbmNsdWRpbmcgYm90aCBzdGFydCBhbmQgZW5kIG5vZGVzKVxyXG4gKiBAcGFyYW0ge05vZGV9XHJcbiAqIEBwYXJhbSB7Tm9kZX1cclxuICovXHJcbmZ1bmN0aW9uIGJpQmFja3RyYWNlKG5vZGVBLCBub2RlQikge1xyXG4gICAgdmFyIHBhdGhBID0gYmFja3RyYWNlKG5vZGVBKSxcclxuICAgICAgICBwYXRoQiA9IGJhY2t0cmFjZShub2RlQik7XHJcbiAgICByZXR1cm4gcGF0aEEuY29uY2F0KHBhdGhCLnJldmVyc2UoKSk7XHJcbn1cclxuZXhwb3J0cy5iaUJhY2t0cmFjZSA9IGJpQmFja3RyYWNlO1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgdGhlIGxlbmd0aCBvZiB0aGUgcGF0aC5cclxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gcGF0aCBUaGUgcGF0aFxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsZW5ndGggb2YgdGhlIHBhdGhcclxuICovXHJcbmZ1bmN0aW9uIHBhdGhMZW5ndGgocGF0aCkge1xyXG4gICAgdmFyIGksIHN1bSA9IDAsIGEsIGIsIGR4LCBkeTtcclxuICAgIGZvciAoaSA9IDE7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgYSA9IHBhdGhbaSAtIDFdO1xyXG4gICAgICAgIGIgPSBwYXRoW2ldO1xyXG4gICAgICAgIGR4ID0gYVswXSAtIGJbMF07XHJcbiAgICAgICAgZHkgPSBhWzFdIC0gYlsxXTtcclxuICAgICAgICBzdW0gKz0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdW07XHJcbn1cclxuZXhwb3J0cy5wYXRoTGVuZ3RoID0gcGF0aExlbmd0aDtcclxuXHJcblxyXG4vKipcclxuICogR2l2ZW4gdGhlIHN0YXJ0IGFuZCBlbmQgY29vcmRpbmF0ZXMsIHJldHVybiBhbGwgdGhlIGNvb3JkaW5hdGVzIGx5aW5nXHJcbiAqIG9uIHRoZSBsaW5lIGZvcm1lZCBieSB0aGVzZSBjb29yZGluYXRlcywgYmFzZWQgb24gQnJlc2VuaGFtJ3MgYWxnb3JpdGhtLlxyXG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JyZXNlbmhhbSdzX2xpbmVfYWxnb3JpdGhtI1NpbXBsaWZpY2F0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MCBTdGFydCB4IGNvb3JkaW5hdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHkwIFN0YXJ0IHkgY29vcmRpbmF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0geDEgRW5kIHggY29vcmRpbmF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0geTEgRW5kIHkgY29vcmRpbmF0ZVxyXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gVGhlIGNvb3JkaW5hdGVzIG9uIHRoZSBsaW5lXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh4MCwgeTAsIHgxLCB5MSkge1xyXG4gICAgdmFyIGFicyA9IE1hdGguYWJzLFxyXG4gICAgICAgIGxpbmUgPSBbXSxcclxuICAgICAgICBzeCwgc3ksIGR4LCBkeSwgZXJyLCBlMjtcclxuXHJcbiAgICBkeCA9IGFicyh4MSAtIHgwKTtcclxuICAgIGR5ID0gYWJzKHkxIC0geTApO1xyXG5cclxuICAgIHN4ID0gKHgwIDwgeDEpID8gMSA6IC0xO1xyXG4gICAgc3kgPSAoeTAgPCB5MSkgPyAxIDogLTE7XHJcblxyXG4gICAgZXJyID0gZHggLSBkeTtcclxuXHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGxpbmUucHVzaChbeDAsIHkwXSk7XHJcblxyXG4gICAgICAgIGlmICh4MCA9PT0geDEgJiYgeTAgPT09IHkxKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBlMiA9IDIgKiBlcnI7XHJcbiAgICAgICAgaWYgKGUyID4gLWR5KSB7XHJcbiAgICAgICAgICAgIGVyciA9IGVyciAtIGR5O1xyXG4gICAgICAgICAgICB4MCA9IHgwICsgc3g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlMiA8IGR4KSB7XHJcbiAgICAgICAgICAgIGVyciA9IGVyciArIGR4O1xyXG4gICAgICAgICAgICB5MCA9IHkwICsgc3k7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsaW5lO1xyXG59XHJcbmV4cG9ydHMuaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZTtcclxuXHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBjb21wcmVzc2VkIHBhdGgsIHJldHVybiBhIG5ldyBwYXRoIHRoYXQgaGFzIGFsbCB0aGUgc2VnbWVudHNcclxuICogaW4gaXQgaW50ZXJwb2xhdGVkLlxyXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBwYXRoIFRoZSBwYXRoXHJcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBleHBhbmRlZCBwYXRoXHJcbiAqL1xyXG5mdW5jdGlvbiBleHBhbmRQYXRoKHBhdGgpIHtcclxuICAgIHZhciBleHBhbmRlZCA9IFtdLFxyXG4gICAgICAgIGxlbiA9IHBhdGgubGVuZ3RoLFxyXG4gICAgICAgIGNvb3JkMCwgY29vcmQxLFxyXG4gICAgICAgIGludGVycG9sYXRlZCxcclxuICAgICAgICBpbnRlcnBvbGF0ZWRMZW4sXHJcbiAgICAgICAgaSwgajtcclxuXHJcbiAgICBpZiAobGVuIDwgMikge1xyXG4gICAgICAgIHJldHVybiBleHBhbmRlZDtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgKytpKSB7XHJcbiAgICAgICAgY29vcmQwID0gcGF0aFtpXTtcclxuICAgICAgICBjb29yZDEgPSBwYXRoW2kgKyAxXTtcclxuXHJcbiAgICAgICAgaW50ZXJwb2xhdGVkID0gaW50ZXJwb2xhdGUoY29vcmQwWzBdLCBjb29yZDBbMV0sIGNvb3JkMVswXSwgY29vcmQxWzFdKTtcclxuICAgICAgICBpbnRlcnBvbGF0ZWRMZW4gPSBpbnRlcnBvbGF0ZWQubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBpbnRlcnBvbGF0ZWRMZW4gLSAxOyArK2opIHtcclxuICAgICAgICAgICAgZXhwYW5kZWQucHVzaChpbnRlcnBvbGF0ZWRbal0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4cGFuZGVkLnB1c2gocGF0aFtsZW4gLSAxXSk7XHJcblxyXG4gICAgcmV0dXJuIGV4cGFuZGVkO1xyXG59XHJcbmV4cG9ydHMuZXhwYW5kUGF0aCA9IGV4cGFuZFBhdGg7XHJcblxyXG5cclxuLyoqXHJcbiAqIFNtb290aGVuIHRoZSBnaXZlIHBhdGguXHJcbiAqIFRoZSBvcmlnaW5hbCBwYXRoIHdpbGwgbm90IGJlIG1vZGlmaWVkOyBhIG5ldyBwYXRoIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEBwYXJhbSB7UEYuR3JpZH0gZ3JpZFxyXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBwYXRoIFRoZSBwYXRoXHJcbiAqL1xyXG5mdW5jdGlvbiBzbW9vdGhlblBhdGgoZ3JpZCwgcGF0aCkge1xyXG4gICAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoLFxyXG4gICAgICAgIHgwID0gcGF0aFswXVswXSwgICAgICAgIC8vIHBhdGggc3RhcnQgeFxyXG4gICAgICAgIHkwID0gcGF0aFswXVsxXSwgICAgICAgIC8vIHBhdGggc3RhcnQgeVxyXG4gICAgICAgIHgxID0gcGF0aFtsZW4gLSAxXVswXSwgIC8vIHBhdGggZW5kIHhcclxuICAgICAgICB5MSA9IHBhdGhbbGVuIC0gMV1bMV0sICAvLyBwYXRoIGVuZCB5XHJcbiAgICAgICAgc3gsIHN5LCAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBzdGFydCBjb29yZGluYXRlXHJcbiAgICAgICAgZXgsIGV5LCAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBlbmQgY29vcmRpbmF0ZVxyXG4gICAgICAgIG5ld1BhdGgsXHJcbiAgICAgICAgaSwgaiwgY29vcmQsIGxpbmUsIHRlc3RDb29yZCwgYmxvY2tlZDtcclxuXHJcbiAgICBzeCA9IHgwO1xyXG4gICAgc3kgPSB5MDtcclxuICAgIG5ld1BhdGggPSBbW3N4LCBzeV1dO1xyXG5cclxuICAgIGZvciAoaSA9IDI7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgIGNvb3JkID0gcGF0aFtpXTtcclxuICAgICAgICBleCA9IGNvb3JkWzBdO1xyXG4gICAgICAgIGV5ID0gY29vcmRbMV07XHJcbiAgICAgICAgbGluZSA9IGludGVycG9sYXRlKHN4LCBzeSwgZXgsIGV5KTtcclxuXHJcbiAgICAgICAgYmxvY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBsaW5lLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgIHRlc3RDb29yZCA9IGxpbmVbal07XHJcblxyXG4gICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHRlc3RDb29yZFswXSwgdGVzdENvb3JkWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgYmxvY2tlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmxvY2tlZCkge1xyXG4gICAgICAgICAgICBsYXN0VmFsaWRDb29yZCA9IHBhdGhbaSAtIDFdO1xyXG4gICAgICAgICAgICBuZXdQYXRoLnB1c2gobGFzdFZhbGlkQ29vcmQpO1xyXG4gICAgICAgICAgICBzeCA9IGxhc3RWYWxpZENvb3JkWzBdO1xyXG4gICAgICAgICAgICBzeSA9IGxhc3RWYWxpZENvb3JkWzFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG5ld1BhdGgucHVzaChbeDEsIHkxXSk7XHJcblxyXG4gICAgcmV0dXJuIG5ld1BhdGg7XHJcbn1cclxuZXhwb3J0cy5zbW9vdGhlblBhdGggPSBzbW9vdGhlblBhdGg7XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbXByZXNzIGEgcGF0aCwgcmVtb3ZlIHJlZHVuZGFudCBub2RlcyB3aXRob3V0IGFsdGVyaW5nIHRoZSBzaGFwZVxyXG4gKiBUaGUgb3JpZ2luYWwgcGF0aCBpcyBub3QgbW9kaWZpZWRcclxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gcGF0aCBUaGUgcGF0aFxyXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gVGhlIGNvbXByZXNzZWQgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gY29tcHJlc3NQYXRoKHBhdGgpIHtcclxuXHJcbiAgICAvLyBub3RoaW5nIHRvIGNvbXByZXNzXHJcbiAgICBpZihwYXRoLmxlbmd0aCA8IDMpIHtcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29tcHJlc3NlZCA9IFtdLFxyXG4gICAgICAgIHN4ID0gcGF0aFswXVswXSwgLy8gc3RhcnQgeFxyXG4gICAgICAgIHN5ID0gcGF0aFswXVsxXSwgLy8gc3RhcnQgeVxyXG4gICAgICAgIHB4ID0gcGF0aFsxXVswXSwgLy8gc2Vjb25kIHBvaW50IHhcclxuICAgICAgICBweSA9IHBhdGhbMV1bMV0sIC8vIHNlY29uZCBwb2ludCB5XHJcbiAgICAgICAgZHggPSBweCAtIHN4LCAvLyBkaXJlY3Rpb24gYmV0d2VlbiB0aGUgdHdvIHBvaW50c1xyXG4gICAgICAgIGR5ID0gcHkgLSBzeSwgLy8gZGlyZWN0aW9uIGJldHdlZW4gdGhlIHR3byBwb2ludHNcclxuICAgICAgICBseCwgbHksXHJcbiAgICAgICAgbGR4LCBsZHksXHJcbiAgICAgICAgc3EsIGk7XHJcblxyXG4gICAgLy8gbm9ybWFsaXplIHRoZSBkaXJlY3Rpb25cclxuICAgIHNxID0gTWF0aC5zcXJ0KGR4KmR4ICsgZHkqZHkpO1xyXG4gICAgZHggLz0gc3E7XHJcbiAgICBkeSAvPSBzcTtcclxuXHJcbiAgICAvLyBzdGFydCB0aGUgbmV3IHBhdGhcclxuICAgIGNvbXByZXNzZWQucHVzaChbc3gsc3ldKTtcclxuXHJcbiAgICBmb3IoaSA9IDI7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgIC8vIHN0b3JlIHRoZSBsYXN0IHBvaW50XHJcbiAgICAgICAgbHggPSBweDtcclxuICAgICAgICBseSA9IHB5O1xyXG5cclxuICAgICAgICAvLyBzdG9yZSB0aGUgbGFzdCBkaXJlY3Rpb25cclxuICAgICAgICBsZHggPSBkeDtcclxuICAgICAgICBsZHkgPSBkeTtcclxuXHJcbiAgICAgICAgLy8gbmV4dCBwb2ludFxyXG4gICAgICAgIHB4ID0gcGF0aFtpXVswXTtcclxuICAgICAgICBweSA9IHBhdGhbaV1bMV07XHJcblxyXG4gICAgICAgIC8vIG5leHQgZGlyZWN0aW9uXHJcbiAgICAgICAgZHggPSBweCAtIGx4O1xyXG4gICAgICAgIGR5ID0gcHkgLSBseTtcclxuXHJcbiAgICAgICAgLy8gbm9ybWFsaXplXHJcbiAgICAgICAgc3EgPSBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSk7XHJcbiAgICAgICAgZHggLz0gc3E7XHJcbiAgICAgICAgZHkgLz0gc3E7XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZSBkaXJlY3Rpb24gaGFzIGNoYW5nZWQsIHN0b3JlIHRoZSBwb2ludFxyXG4gICAgICAgIGlmICggZHggIT09IGxkeCB8fCBkeSAhPT0gbGR5ICkge1xyXG4gICAgICAgICAgICBjb21wcmVzc2VkLnB1c2goW2x4LGx5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHN0b3JlIHRoZSBsYXN0IHBvaW50XHJcbiAgICBjb21wcmVzc2VkLnB1c2goW3B4LHB5XSk7XHJcblxyXG4gICAgcmV0dXJuIGNvbXByZXNzZWQ7XHJcbn1cclxuZXhwb3J0cy5jb21wcmVzc1BhdGggPSBjb21wcmVzc1BhdGg7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/core/Util.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/finders/AStarFinder.js":
/*!*************************************************************!*\
  !*** ./node_modules/pathfinding/src/finders/AStarFinder.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var Heap       = __webpack_require__(/*! heap */ \"./node_modules/heap/index.js\");\r\nvar Util       = __webpack_require__(/*! ../core/Util */ \"./node_modules/pathfinding/src/core/Util.js\");\r\nvar Heuristic  = __webpack_require__(/*! ../core/Heuristic */ \"./node_modules/pathfinding/src/core/Heuristic.js\");\r\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./node_modules/pathfinding/src/core/DiagonalMovement.js\");\r\n\r\n/**\r\n * A* path-finder. Based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching \r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction AStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    //admissible. It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        // if reached the end position, construct the path and return it\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    openList.push(neighbor);\r\n                    neighbor.opened = true;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    openList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = AStarFinder;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvQVN0YXJGaW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsMENBQU07QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsaUVBQWM7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsMkVBQW1CO0FBQzVDLHVCQUF1QixtQkFBTyxDQUFDLHlGQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYWNvbm1hbi8uL25vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9BU3RhckZpbmRlci5qcz82OGQ0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBIZWFwICAgICAgID0gcmVxdWlyZSgnaGVhcCcpO1xyXG52YXIgVXRpbCAgICAgICA9IHJlcXVpcmUoJy4uL2NvcmUvVXRpbCcpO1xyXG52YXIgSGV1cmlzdGljICA9IHJlcXVpcmUoJy4uL2NvcmUvSGV1cmlzdGljJyk7XHJcbnZhciBEaWFnb25hbE1vdmVtZW50ID0gcmVxdWlyZSgnLi4vY29yZS9EaWFnb25hbE1vdmVtZW50Jyk7XHJcblxyXG4vKipcclxuICogQSogcGF0aC1maW5kZXIuIEJhc2VkIHVwb24gaHR0cHM6Ly9naXRodWIuY29tL2Jncmlucy9qYXZhc2NyaXB0LWFzdGFyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmFsbG93RGlhZ29uYWwgV2hldGhlciBkaWFnb25hbCBtb3ZlbWVudCBpcyBhbGxvd2VkLlxyXG4gKiAgICAgRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuZG9udENyb3NzQ29ybmVycyBEaXNhbGxvdyBkaWFnb25hbCBtb3ZlbWVudCB0b3VjaGluZyBcclxuICogICAgIGJsb2NrIGNvcm5lcnMuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXHJcbiAqIEBwYXJhbSB7RGlhZ29uYWxNb3ZlbWVudH0gb3B0LmRpYWdvbmFsTW92ZW1lbnQgQWxsb3dlZCBkaWFnb25hbCBtb3ZlbWVudC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LmhldXJpc3RpYyBIZXVyaXN0aWMgZnVuY3Rpb24gdG8gZXN0aW1hdGUgdGhlIGRpc3RhbmNlXHJcbiAqICAgICAoZGVmYXVsdHMgdG8gbWFuaGF0dGFuKS5cclxuICogQHBhcmFtIHtudW1iZXJ9IG9wdC53ZWlnaHQgV2VpZ2h0IHRvIGFwcGx5IHRvIHRoZSBoZXVyaXN0aWMgdG8gYWxsb3cgZm9yXHJcbiAqICAgICBzdWJvcHRpbWFsIHBhdGhzLCBpbiBvcmRlciB0byBzcGVlZCB1cCB0aGUgc2VhcmNoLlxyXG4gKi9cclxuZnVuY3Rpb24gQVN0YXJGaW5kZXIob3B0KSB7XHJcbiAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICB0aGlzLmFsbG93RGlhZ29uYWwgPSBvcHQuYWxsb3dEaWFnb25hbDtcclxuICAgIHRoaXMuZG9udENyb3NzQ29ybmVycyA9IG9wdC5kb250Q3Jvc3NDb3JuZXJzO1xyXG4gICAgdGhpcy5oZXVyaXN0aWMgPSBvcHQuaGV1cmlzdGljIHx8IEhldXJpc3RpYy5tYW5oYXR0YW47XHJcbiAgICB0aGlzLndlaWdodCA9IG9wdC53ZWlnaHQgfHwgMTtcclxuICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IG9wdC5kaWFnb25hbE1vdmVtZW50O1xyXG5cclxuICAgIGlmICghdGhpcy5kaWFnb25hbE1vdmVtZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93RGlhZ29uYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5OZXZlcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kb250Q3Jvc3NDb3JuZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50Lk9ubHlXaGVuTm9PYnN0YWNsZXM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50LklmQXRNb3N0T25lT2JzdGFjbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2hlbiBkaWFnb25hbCBtb3ZlbWVudCBpcyBhbGxvd2VkIHRoZSBtYW5oYXR0YW4gaGV1cmlzdGljIGlzIG5vdFxyXG4gICAgLy9hZG1pc3NpYmxlLiBJdCBzaG91bGQgYmUgb2N0aWxlIGluc3RlYWRcclxuICAgIGlmICh0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPT09IERpYWdvbmFsTW92ZW1lbnQuTmV2ZXIpIHtcclxuICAgICAgICB0aGlzLmhldXJpc3RpYyA9IG9wdC5oZXVyaXN0aWMgfHwgSGV1cmlzdGljLm1hbmhhdHRhbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5oZXVyaXN0aWMgPSBvcHQuaGV1cmlzdGljIHx8IEhldXJpc3RpYy5vY3RpbGU7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaW5kIGFuZCByZXR1cm4gdGhlIHRoZSBwYXRoLlxyXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gVGhlIHBhdGgsIGluY2x1ZGluZyBib3RoIHN0YXJ0IGFuZFxyXG4gKiAgICAgZW5kIHBvc2l0aW9ucy5cclxuICovXHJcbkFTdGFyRmluZGVyLnByb3RvdHlwZS5maW5kUGF0aCA9IGZ1bmN0aW9uKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBncmlkKSB7XHJcbiAgICB2YXIgb3Blbkxpc3QgPSBuZXcgSGVhcChmdW5jdGlvbihub2RlQSwgbm9kZUIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGVBLmYgLSBub2RlQi5mO1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIHN0YXJ0Tm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KHN0YXJ0WCwgc3RhcnRZKSxcclxuICAgICAgICBlbmROb2RlID0gZ3JpZC5nZXROb2RlQXQoZW5kWCwgZW5kWSksXHJcbiAgICAgICAgaGV1cmlzdGljID0gdGhpcy5oZXVyaXN0aWMsXHJcbiAgICAgICAgZGlhZ29uYWxNb3ZlbWVudCA9IHRoaXMuZGlhZ29uYWxNb3ZlbWVudCxcclxuICAgICAgICB3ZWlnaHQgPSB0aGlzLndlaWdodCxcclxuICAgICAgICBhYnMgPSBNYXRoLmFicywgU1FSVDIgPSBNYXRoLlNRUlQyLFxyXG4gICAgICAgIG5vZGUsIG5laWdoYm9ycywgbmVpZ2hib3IsIGksIGwsIHgsIHksIG5nO1xyXG5cclxuICAgIC8vIHNldCB0aGUgYGdgIGFuZCBgZmAgdmFsdWUgb2YgdGhlIHN0YXJ0IG5vZGUgdG8gYmUgMFxyXG4gICAgc3RhcnROb2RlLmcgPSAwO1xyXG4gICAgc3RhcnROb2RlLmYgPSAwO1xyXG5cclxuICAgIC8vIHB1c2ggdGhlIHN0YXJ0IG5vZGUgaW50byB0aGUgb3BlbiBsaXN0XHJcbiAgICBvcGVuTGlzdC5wdXNoKHN0YXJ0Tm9kZSk7XHJcbiAgICBzdGFydE5vZGUub3BlbmVkID0gdHJ1ZTtcclxuXHJcbiAgICAvLyB3aGlsZSB0aGUgb3BlbiBsaXN0IGlzIG5vdCBlbXB0eVxyXG4gICAgd2hpbGUgKCFvcGVuTGlzdC5lbXB0eSgpKSB7XHJcbiAgICAgICAgLy8gcG9wIHRoZSBwb3NpdGlvbiBvZiBub2RlIHdoaWNoIGhhcyB0aGUgbWluaW11bSBgZmAgdmFsdWUuXHJcbiAgICAgICAgbm9kZSA9IG9wZW5MaXN0LnBvcCgpO1xyXG4gICAgICAgIG5vZGUuY2xvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gaWYgcmVhY2hlZCB0aGUgZW5kIHBvc2l0aW9uLCBjb25zdHJ1Y3QgdGhlIHBhdGggYW5kIHJldHVybiBpdFxyXG4gICAgICAgIGlmIChub2RlID09PSBlbmROb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBVdGlsLmJhY2t0cmFjZShlbmROb2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGdldCBuZWlnYm91cnMgb2YgdGhlIGN1cnJlbnQgbm9kZVxyXG4gICAgICAgIG5laWdoYm9ycyA9IGdyaWQuZ2V0TmVpZ2hib3JzKG5vZGUsIGRpYWdvbmFsTW92ZW1lbnQpO1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZWlnaGJvcnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XHJcbiAgICAgICAgICAgIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5laWdoYm9yLmNsb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHggPSBuZWlnaGJvci54O1xyXG4gICAgICAgICAgICB5ID0gbmVpZ2hib3IueTtcclxuXHJcbiAgICAgICAgICAgIC8vIGdldCB0aGUgZGlzdGFuY2UgYmV0d2VlbiBjdXJyZW50IG5vZGUgYW5kIHRoZSBuZWlnaGJvclxyXG4gICAgICAgICAgICAvLyBhbmQgY2FsY3VsYXRlIHRoZSBuZXh0IGcgc2NvcmVcclxuICAgICAgICAgICAgbmcgPSBub2RlLmcgKyAoKHggLSBub2RlLnggPT09IDAgfHwgeSAtIG5vZGUueSA9PT0gMCkgPyAxIDogU1FSVDIpO1xyXG5cclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5laWdoYm9yIGhhcyBub3QgYmVlbiBpbnNwZWN0ZWQgeWV0LCBvclxyXG4gICAgICAgICAgICAvLyBjYW4gYmUgcmVhY2hlZCB3aXRoIHNtYWxsZXIgY29zdCBmcm9tIHRoZSBjdXJyZW50IG5vZGVcclxuICAgICAgICAgICAgaWYgKCFuZWlnaGJvci5vcGVuZWQgfHwgbmcgPCBuZWlnaGJvci5nKSB7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5nID0gbmc7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5oID0gbmVpZ2hib3IuaCB8fCB3ZWlnaHQgKiBoZXVyaXN0aWMoYWJzKHggLSBlbmRYKSwgYWJzKHkgLSBlbmRZKSk7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5mID0gbmVpZ2hib3IuZyArIG5laWdoYm9yLmg7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5wYXJlbnQgPSBub2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghbmVpZ2hib3Iub3BlbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbkxpc3QucHVzaChuZWlnaGJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3Iub3BlbmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5laWdoYm9yIGNhbiBiZSByZWFjaGVkIHdpdGggc21hbGxlciBjb3N0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIGl0cyBmIHZhbHVlIGhhcyBiZWVuIHVwZGF0ZWQsIHdlIGhhdmUgdG9cclxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgaXRzIHBvc2l0aW9uIGluIHRoZSBvcGVuIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICBvcGVuTGlzdC51cGRhdGVJdGVtKG5laWdoYm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gLy8gZW5kIGZvciBlYWNoIG5laWdoYm9yXHJcbiAgICB9IC8vIGVuZCB3aGlsZSBub3Qgb3BlbiBsaXN0IGVtcHR5XHJcblxyXG4gICAgLy8gZmFpbCB0byBmaW5kIHRoZSBwYXRoXHJcbiAgICByZXR1cm4gW107XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFTdGFyRmluZGVyO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/finders/AStarFinder.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/finders/BestFirstFinder.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pathfinding/src/finders/BestFirstFinder.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var AStarFinder = __webpack_require__(/*! ./AStarFinder */ \"./node_modules/pathfinding/src/finders/AStarFinder.js\");\r\n\r\n/**\r\n * Best-First-Search path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BestFirstFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBestFirstFinder.prototype = new AStarFinder();\r\nBestFirstFinder.prototype.constructor = BestFirstFinder;\r\n\r\nmodule.exports = BestFirstFinder;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvQmVzdEZpcnN0RmluZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLGtCQUFrQixtQkFBTyxDQUFDLDRFQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmFjb25tYW4vLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvQmVzdEZpcnN0RmluZGVyLmpzPzU1ZDAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEFTdGFyRmluZGVyID0gcmVxdWlyZSgnLi9BU3RhckZpbmRlcicpO1xyXG5cclxuLyoqXHJcbiAqIEJlc3QtRmlyc3QtU2VhcmNoIHBhdGgtZmluZGVyLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgQVN0YXJGaW5kZXJcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5hbGxvd0RpYWdvbmFsIFdoZXRoZXIgZGlhZ29uYWwgbW92ZW1lbnQgaXMgYWxsb3dlZC5cclxuICogICAgIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmRvbnRDcm9zc0Nvcm5lcnMgRGlzYWxsb3cgZGlhZ29uYWwgbW92ZW1lbnQgdG91Y2hpbmdcclxuICogICAgIGJsb2NrIGNvcm5lcnMuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXHJcbiAqIEBwYXJhbSB7RGlhZ29uYWxNb3ZlbWVudH0gb3B0LmRpYWdvbmFsTW92ZW1lbnQgQWxsb3dlZCBkaWFnb25hbCBtb3ZlbWVudC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LmhldXJpc3RpYyBIZXVyaXN0aWMgZnVuY3Rpb24gdG8gZXN0aW1hdGUgdGhlIGRpc3RhbmNlXHJcbiAqICAgICAoZGVmYXVsdHMgdG8gbWFuaGF0dGFuKS5cclxuICovXHJcbmZ1bmN0aW9uIEJlc3RGaXJzdEZpbmRlcihvcHQpIHtcclxuICAgIEFTdGFyRmluZGVyLmNhbGwodGhpcywgb3B0KTtcclxuXHJcbiAgICB2YXIgb3JpZyA9IHRoaXMuaGV1cmlzdGljO1xyXG4gICAgdGhpcy5oZXVyaXN0aWMgPSBmdW5jdGlvbihkeCwgZHkpIHtcclxuICAgICAgICByZXR1cm4gb3JpZyhkeCwgZHkpICogMTAwMDAwMDtcclxuICAgIH07XHJcbn1cclxuXHJcbkJlc3RGaXJzdEZpbmRlci5wcm90b3R5cGUgPSBuZXcgQVN0YXJGaW5kZXIoKTtcclxuQmVzdEZpcnN0RmluZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJlc3RGaXJzdEZpbmRlcjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmVzdEZpcnN0RmluZGVyO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/finders/BestFirstFinder.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/finders/BiAStarFinder.js":
/*!***************************************************************!*\
  !*** ./node_modules/pathfinding/src/finders/BiAStarFinder.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var Heap       = __webpack_require__(/*! heap */ \"./node_modules/heap/index.js\");\r\nvar Util       = __webpack_require__(/*! ../core/Util */ \"./node_modules/pathfinding/src/core/Util.js\");\r\nvar Heuristic  = __webpack_require__(/*! ../core/Heuristic */ \"./node_modules/pathfinding/src/core/Heuristic.js\");\r\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./node_modules/pathfinding/src/core/DiagonalMovement.js\");\r\n\r\n/**\r\n * A* path-finder.\r\n * based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction BiAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\r\n    //It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var cmp = function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        },\r\n        startOpenList = new Heap(cmp),\r\n        endOpenList = new Heap(cmp),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng,\r\n        BY_START = 1, BY_END = 2;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    // and push it into the start open list\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n    startOpenList.push(startNode);\r\n    startNode.opened = BY_START;\r\n\r\n    // set the `g` and `f` value of the end node to be 0\r\n    // and push it into the open open list\r\n    endNode.g = 0;\r\n    endNode.f = 0;\r\n    endOpenList.push(endNode);\r\n    endNode.opened = BY_END;\r\n\r\n    // while both the open lists are not empty\r\n    while (!startOpenList.empty() && !endOpenList.empty()) {\r\n\r\n        // pop the position of start node which has the minimum `f` value.\r\n        node = startOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_END) {\r\n                return Util.biBacktrace(node, neighbor);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    startOpenList.push(neighbor);\r\n                    neighbor.opened = BY_START;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    startOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n\r\n\r\n        // pop the position of end node which has the minimum `f` value.\r\n        node = endOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_START) {\r\n                return Util.biBacktrace(neighbor, node);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - startX), abs(y - startY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    endOpenList.push(neighbor);\r\n                    neighbor.opened = BY_END;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    endOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiAStarFinder;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvQmlBU3RhckZpbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQywwQ0FBTTtBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyxpRUFBYztBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQywyRUFBbUI7QUFDNUMsdUJBQXVCLG1CQUFPLENBQUMseUZBQTBCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYWNvbm1hbi8uL25vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9CaUFTdGFyRmluZGVyLmpzPzk3ZWYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEhlYXAgICAgICAgPSByZXF1aXJlKCdoZWFwJyk7XHJcbnZhciBVdGlsICAgICAgID0gcmVxdWlyZSgnLi4vY29yZS9VdGlsJyk7XHJcbnZhciBIZXVyaXN0aWMgID0gcmVxdWlyZSgnLi4vY29yZS9IZXVyaXN0aWMnKTtcclxudmFyIERpYWdvbmFsTW92ZW1lbnQgPSByZXF1aXJlKCcuLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBBKiBwYXRoLWZpbmRlci5cclxuICogYmFzZWQgdXBvbiBodHRwczovL2dpdGh1Yi5jb20vYmdyaW5zL2phdmFzY3JpcHQtYXN0YXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuYWxsb3dEaWFnb25hbCBXaGV0aGVyIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQuXHJcbiAqICAgICBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5kb250Q3Jvc3NDb3JuZXJzIERpc2FsbG93IGRpYWdvbmFsIG1vdmVtZW50IHRvdWNoaW5nXHJcbiAqICAgICBibG9jayBjb3JuZXJzLiBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge0RpYWdvbmFsTW92ZW1lbnR9IG9wdC5kaWFnb25hbE1vdmVtZW50IEFsbG93ZWQgZGlhZ29uYWwgbW92ZW1lbnQuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdC5oZXVyaXN0aWMgSGV1cmlzdGljIGZ1bmN0aW9uIHRvIGVzdGltYXRlIHRoZSBkaXN0YW5jZVxyXG4gKiAgICAgKGRlZmF1bHRzIHRvIG1hbmhhdHRhbikuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHQud2VpZ2h0IFdlaWdodCB0byBhcHBseSB0byB0aGUgaGV1cmlzdGljIHRvIGFsbG93IGZvclxyXG4gKiAgICAgc3Vib3B0aW1hbCBwYXRocywgaW4gb3JkZXIgdG8gc3BlZWQgdXAgdGhlIHNlYXJjaC5cclxuICovXHJcbmZ1bmN0aW9uIEJpQVN0YXJGaW5kZXIob3B0KSB7XHJcbiAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICB0aGlzLmFsbG93RGlhZ29uYWwgPSBvcHQuYWxsb3dEaWFnb25hbDtcclxuICAgIHRoaXMuZG9udENyb3NzQ29ybmVycyA9IG9wdC5kb250Q3Jvc3NDb3JuZXJzO1xyXG4gICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gb3B0LmRpYWdvbmFsTW92ZW1lbnQ7XHJcbiAgICB0aGlzLmhldXJpc3RpYyA9IG9wdC5oZXVyaXN0aWMgfHwgSGV1cmlzdGljLm1hbmhhdHRhbjtcclxuICAgIHRoaXMud2VpZ2h0ID0gb3B0LndlaWdodCB8fCAxO1xyXG5cclxuICAgIGlmICghdGhpcy5kaWFnb25hbE1vdmVtZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93RGlhZ29uYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5OZXZlcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kb250Q3Jvc3NDb3JuZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50Lk9ubHlXaGVuTm9PYnN0YWNsZXM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50LklmQXRNb3N0T25lT2JzdGFjbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9XaGVuIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQgdGhlIG1hbmhhdHRhbiBoZXVyaXN0aWMgaXMgbm90IGFkbWlzc2libGVcclxuICAgIC8vSXQgc2hvdWxkIGJlIG9jdGlsZSBpbnN0ZWFkXHJcbiAgICBpZiAodGhpcy5kaWFnb25hbE1vdmVtZW50ID09PSBEaWFnb25hbE1vdmVtZW50Lk5ldmVyKSB7XHJcbiAgICAgICAgdGhpcy5oZXVyaXN0aWMgPSBvcHQuaGV1cmlzdGljIHx8IEhldXJpc3RpYy5tYW5oYXR0YW47XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuaGV1cmlzdGljID0gb3B0LmhldXJpc3RpYyB8fCBIZXVyaXN0aWMub2N0aWxlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmluZCBhbmQgcmV0dXJuIHRoZSB0aGUgcGF0aC5cclxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFRoZSBwYXRoLCBpbmNsdWRpbmcgYm90aCBzdGFydCBhbmRcclxuICogICAgIGVuZCBwb3NpdGlvbnMuXHJcbiAqL1xyXG5CaUFTdGFyRmluZGVyLnByb3RvdHlwZS5maW5kUGF0aCA9IGZ1bmN0aW9uKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBncmlkKSB7XHJcbiAgICB2YXIgY21wID0gZnVuY3Rpb24obm9kZUEsIG5vZGVCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlQS5mIC0gbm9kZUIuZjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0YXJ0T3Blbkxpc3QgPSBuZXcgSGVhcChjbXApLFxyXG4gICAgICAgIGVuZE9wZW5MaXN0ID0gbmV3IEhlYXAoY21wKSxcclxuICAgICAgICBzdGFydE5vZGUgPSBncmlkLmdldE5vZGVBdChzdGFydFgsIHN0YXJ0WSksXHJcbiAgICAgICAgZW5kTm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KGVuZFgsIGVuZFkpLFxyXG4gICAgICAgIGhldXJpc3RpYyA9IHRoaXMuaGV1cmlzdGljLFxyXG4gICAgICAgIGRpYWdvbmFsTW92ZW1lbnQgPSB0aGlzLmRpYWdvbmFsTW92ZW1lbnQsXHJcbiAgICAgICAgd2VpZ2h0ID0gdGhpcy53ZWlnaHQsXHJcbiAgICAgICAgYWJzID0gTWF0aC5hYnMsIFNRUlQyID0gTWF0aC5TUVJUMixcclxuICAgICAgICBub2RlLCBuZWlnaGJvcnMsIG5laWdoYm9yLCBpLCBsLCB4LCB5LCBuZyxcclxuICAgICAgICBCWV9TVEFSVCA9IDEsIEJZX0VORCA9IDI7XHJcblxyXG4gICAgLy8gc2V0IHRoZSBgZ2AgYW5kIGBmYCB2YWx1ZSBvZiB0aGUgc3RhcnQgbm9kZSB0byBiZSAwXHJcbiAgICAvLyBhbmQgcHVzaCBpdCBpbnRvIHRoZSBzdGFydCBvcGVuIGxpc3RcclxuICAgIHN0YXJ0Tm9kZS5nID0gMDtcclxuICAgIHN0YXJ0Tm9kZS5mID0gMDtcclxuICAgIHN0YXJ0T3Blbkxpc3QucHVzaChzdGFydE5vZGUpO1xyXG4gICAgc3RhcnROb2RlLm9wZW5lZCA9IEJZX1NUQVJUO1xyXG5cclxuICAgIC8vIHNldCB0aGUgYGdgIGFuZCBgZmAgdmFsdWUgb2YgdGhlIGVuZCBub2RlIHRvIGJlIDBcclxuICAgIC8vIGFuZCBwdXNoIGl0IGludG8gdGhlIG9wZW4gb3BlbiBsaXN0XHJcbiAgICBlbmROb2RlLmcgPSAwO1xyXG4gICAgZW5kTm9kZS5mID0gMDtcclxuICAgIGVuZE9wZW5MaXN0LnB1c2goZW5kTm9kZSk7XHJcbiAgICBlbmROb2RlLm9wZW5lZCA9IEJZX0VORDtcclxuXHJcbiAgICAvLyB3aGlsZSBib3RoIHRoZSBvcGVuIGxpc3RzIGFyZSBub3QgZW1wdHlcclxuICAgIHdoaWxlICghc3RhcnRPcGVuTGlzdC5lbXB0eSgpICYmICFlbmRPcGVuTGlzdC5lbXB0eSgpKSB7XHJcblxyXG4gICAgICAgIC8vIHBvcCB0aGUgcG9zaXRpb24gb2Ygc3RhcnQgbm9kZSB3aGljaCBoYXMgdGhlIG1pbmltdW0gYGZgIHZhbHVlLlxyXG4gICAgICAgIG5vZGUgPSBzdGFydE9wZW5MaXN0LnBvcCgpO1xyXG4gICAgICAgIG5vZGUuY2xvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IG5laWdib3VycyBvZiB0aGUgY3VycmVudCBub2RlXHJcbiAgICAgICAgbmVpZ2hib3JzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgZGlhZ29uYWxNb3ZlbWVudCk7XHJcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5laWdoYm9ycy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAobmVpZ2hib3IuY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmVpZ2hib3Iub3BlbmVkID09PSBCWV9FTkQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBVdGlsLmJpQmFja3RyYWNlKG5vZGUsIG5laWdoYm9yKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeCA9IG5laWdoYm9yLng7XHJcbiAgICAgICAgICAgIHkgPSBuZWlnaGJvci55O1xyXG5cclxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGN1cnJlbnQgbm9kZSBhbmQgdGhlIG5laWdoYm9yXHJcbiAgICAgICAgICAgIC8vIGFuZCBjYWxjdWxhdGUgdGhlIG5leHQgZyBzY29yZVxyXG4gICAgICAgICAgICBuZyA9IG5vZGUuZyArICgoeCAtIG5vZGUueCA9PT0gMCB8fCB5IC0gbm9kZS55ID09PSAwKSA/IDEgOiBTUVJUMik7XHJcblxyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbmVpZ2hib3IgaGFzIG5vdCBiZWVuIGluc3BlY3RlZCB5ZXQsIG9yXHJcbiAgICAgICAgICAgIC8vIGNhbiBiZSByZWFjaGVkIHdpdGggc21hbGxlciBjb3N0IGZyb20gdGhlIGN1cnJlbnQgbm9kZVxyXG4gICAgICAgICAgICBpZiAoIW5laWdoYm9yLm9wZW5lZCB8fCBuZyA8IG5laWdoYm9yLmcpIHtcclxuICAgICAgICAgICAgICAgIG5laWdoYm9yLmcgPSBuZztcclxuICAgICAgICAgICAgICAgIG5laWdoYm9yLmggPSBuZWlnaGJvci5oIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0ICogaGV1cmlzdGljKGFicyh4IC0gZW5kWCksIGFicyh5IC0gZW5kWSkpO1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3IuZiA9IG5laWdoYm9yLmcgKyBuZWlnaGJvci5oO1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3IucGFyZW50ID0gbm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIW5laWdoYm9yLm9wZW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T3Blbkxpc3QucHVzaChuZWlnaGJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3Iub3BlbmVkID0gQllfU1RBUlQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZWlnaGJvciBjYW4gYmUgcmVhY2hlZCB3aXRoIHNtYWxsZXIgY29zdC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSBpdHMgZiB2YWx1ZSBoYXMgYmVlbiB1cGRhdGVkLCB3ZSBoYXZlIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGl0cyBwb3NpdGlvbiBpbiB0aGUgb3BlbiBsaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPcGVuTGlzdC51cGRhdGVJdGVtKG5laWdoYm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gLy8gZW5kIGZvciBlYWNoIG5laWdoYm9yXHJcblxyXG5cclxuICAgICAgICAvLyBwb3AgdGhlIHBvc2l0aW9uIG9mIGVuZCBub2RlIHdoaWNoIGhhcyB0aGUgbWluaW11bSBgZmAgdmFsdWUuXHJcbiAgICAgICAgbm9kZSA9IGVuZE9wZW5MaXN0LnBvcCgpO1xyXG4gICAgICAgIG5vZGUuY2xvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IG5laWdib3VycyBvZiB0aGUgY3VycmVudCBub2RlXHJcbiAgICAgICAgbmVpZ2hib3JzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgZGlhZ29uYWxNb3ZlbWVudCk7XHJcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5laWdoYm9ycy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAobmVpZ2hib3IuY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmVpZ2hib3Iub3BlbmVkID09PSBCWV9TVEFSVCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWwuYmlCYWNrdHJhY2UobmVpZ2hib3IsIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB4ID0gbmVpZ2hib3IueDtcclxuICAgICAgICAgICAgeSA9IG5laWdoYm9yLnk7XHJcblxyXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gY3VycmVudCBub2RlIGFuZCB0aGUgbmVpZ2hib3JcclxuICAgICAgICAgICAgLy8gYW5kIGNhbGN1bGF0ZSB0aGUgbmV4dCBnIHNjb3JlXHJcbiAgICAgICAgICAgIG5nID0gbm9kZS5nICsgKCh4IC0gbm9kZS54ID09PSAwIHx8IHkgLSBub2RlLnkgPT09IDApID8gMSA6IFNRUlQyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBuZWlnaGJvciBoYXMgbm90IGJlZW4gaW5zcGVjdGVkIHlldCwgb3JcclxuICAgICAgICAgICAgLy8gY2FuIGJlIHJlYWNoZWQgd2l0aCBzbWFsbGVyIGNvc3QgZnJvbSB0aGUgY3VycmVudCBub2RlXHJcbiAgICAgICAgICAgIGlmICghbmVpZ2hib3Iub3BlbmVkIHx8IG5nIDwgbmVpZ2hib3IuZykge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3IuZyA9IG5nO1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3IuaCA9IG5laWdoYm9yLmggfHxcclxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQgKiBoZXVyaXN0aWMoYWJzKHggLSBzdGFydFgpLCBhYnMoeSAtIHN0YXJ0WSkpO1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3IuZiA9IG5laWdoYm9yLmcgKyBuZWlnaGJvci5oO1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3IucGFyZW50ID0gbm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIW5laWdoYm9yLm9wZW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZE9wZW5MaXN0LnB1c2gobmVpZ2hib3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLm9wZW5lZCA9IEJZX0VORDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5laWdoYm9yIGNhbiBiZSByZWFjaGVkIHdpdGggc21hbGxlciBjb3N0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIGl0cyBmIHZhbHVlIGhhcyBiZWVuIHVwZGF0ZWQsIHdlIGhhdmUgdG9cclxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgaXRzIHBvc2l0aW9uIGluIHRoZSBvcGVuIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICBlbmRPcGVuTGlzdC51cGRhdGVJdGVtKG5laWdoYm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gLy8gZW5kIGZvciBlYWNoIG5laWdoYm9yXHJcbiAgICB9IC8vIGVuZCB3aGlsZSBub3Qgb3BlbiBsaXN0IGVtcHR5XHJcblxyXG4gICAgLy8gZmFpbCB0byBmaW5kIHRoZSBwYXRoXHJcbiAgICByZXR1cm4gW107XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJpQVN0YXJGaW5kZXI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/finders/BiAStarFinder.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/finders/BiBestFirstFinder.js":
/*!*******************************************************************!*\
  !*** ./node_modules/pathfinding/src/finders/BiBestFirstFinder.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var BiAStarFinder = __webpack_require__(/*! ./BiAStarFinder */ \"./node_modules/pathfinding/src/finders/BiAStarFinder.js\");\r\n\r\n/**\r\n * Bi-direcitional Best-First-Search path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BiBestFirstFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBiBestFirstFinder.prototype = new BiAStarFinder();\r\nBiBestFirstFinder.prototype.constructor = BiBestFirstFinder;\r\n\r\nmodule.exports = BiBestFirstFinder;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvQmlCZXN0Rmlyc3RGaW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmFjb25tYW4vLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvQmlCZXN0Rmlyc3RGaW5kZXIuanM/NDc1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQmlBU3RhckZpbmRlciA9IHJlcXVpcmUoJy4vQmlBU3RhckZpbmRlcicpO1xyXG5cclxuLyoqXHJcbiAqIEJpLWRpcmVjaXRpb25hbCBCZXN0LUZpcnN0LVNlYXJjaCBwYXRoLWZpbmRlci5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBleHRlbmRzIEJpQVN0YXJGaW5kZXJcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5hbGxvd0RpYWdvbmFsIFdoZXRoZXIgZGlhZ29uYWwgbW92ZW1lbnQgaXMgYWxsb3dlZC5cclxuICogICAgIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmRvbnRDcm9zc0Nvcm5lcnMgRGlzYWxsb3cgZGlhZ29uYWwgbW92ZW1lbnQgdG91Y2hpbmdcclxuICogICAgIGJsb2NrIGNvcm5lcnMuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXHJcbiAqIEBwYXJhbSB7RGlhZ29uYWxNb3ZlbWVudH0gb3B0LmRpYWdvbmFsTW92ZW1lbnQgQWxsb3dlZCBkaWFnb25hbCBtb3ZlbWVudC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LmhldXJpc3RpYyBIZXVyaXN0aWMgZnVuY3Rpb24gdG8gZXN0aW1hdGUgdGhlIGRpc3RhbmNlXHJcbiAqICAgICAoZGVmYXVsdHMgdG8gbWFuaGF0dGFuKS5cclxuICovXHJcbmZ1bmN0aW9uIEJpQmVzdEZpcnN0RmluZGVyKG9wdCkge1xyXG4gICAgQmlBU3RhckZpbmRlci5jYWxsKHRoaXMsIG9wdCk7XHJcblxyXG4gICAgdmFyIG9yaWcgPSB0aGlzLmhldXJpc3RpYztcclxuICAgIHRoaXMuaGV1cmlzdGljID0gZnVuY3Rpb24oZHgsIGR5KSB7XHJcbiAgICAgICAgcmV0dXJuIG9yaWcoZHgsIGR5KSAqIDEwMDAwMDA7XHJcbiAgICB9O1xyXG59XHJcblxyXG5CaUJlc3RGaXJzdEZpbmRlci5wcm90b3R5cGUgPSBuZXcgQmlBU3RhckZpbmRlcigpO1xyXG5CaUJlc3RGaXJzdEZpbmRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCaUJlc3RGaXJzdEZpbmRlcjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmlCZXN0Rmlyc3RGaW5kZXI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/finders/BiBestFirstFinder.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var Util = __webpack_require__(/*! ../core/Util */ \"./node_modules/pathfinding/src/core/Util.js\");\r\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./node_modules/pathfinding/src/core/DiagonalMovement.js\");\r\n\r\n/**\r\n * Bi-directional Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiBreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        startOpenList = [], endOpenList = [],\r\n        neighbors, neighbor, node,\r\n        diagonalMovement = this.diagonalMovement,\r\n        BY_START = 0, BY_END = 1,\r\n        i, l;\r\n\r\n    // push the start and end nodes into the queues\r\n    startOpenList.push(startNode);\r\n    startNode.opened = true;\r\n    startNode.by = BY_START;\r\n\r\n    endOpenList.push(endNode);\r\n    endNode.opened = true;\r\n    endNode.by = BY_END;\r\n\r\n    // while both the queues are not empty\r\n    while (startOpenList.length && endOpenList.length) {\r\n\r\n        // expand start open list\r\n\r\n        node = startOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                // if this node has been inspected by the reversed search,\r\n                // then a path is found.\r\n                if (neighbor.by === BY_END) {\r\n                    return Util.biBacktrace(node, neighbor);\r\n                }\r\n                continue;\r\n            }\r\n            startOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_START;\r\n        }\r\n\r\n        // expand end open list\r\n\r\n        node = endOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                if (neighbor.by === BY_START) {\r\n                    return Util.biBacktrace(neighbor, node);\r\n                }\r\n                continue;\r\n            }\r\n            endOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_END;\r\n        }\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiBreadthFirstFinder;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvQmlCcmVhZHRoRmlyc3RGaW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxtQkFBTyxDQUFDLGlFQUFjO0FBQ2pDLHVCQUF1QixtQkFBTyxDQUFDLHlGQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhY29ubWFuLy4vbm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9maW5kZXJzL0JpQnJlYWR0aEZpcnN0RmluZGVyLmpzPzIwMTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL1V0aWwnKTtcclxudmFyIERpYWdvbmFsTW92ZW1lbnQgPSByZXF1aXJlKCcuLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnQnKTtcclxuXHJcbi8qKlxyXG4gKiBCaS1kaXJlY3Rpb25hbCBCcmVhZHRoLUZpcnN0LVNlYXJjaCBwYXRoIGZpbmRlci5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRcclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuYWxsb3dEaWFnb25hbCBXaGV0aGVyIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQuXHJcbiAqICAgICBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5kb250Q3Jvc3NDb3JuZXJzIERpc2FsbG93IGRpYWdvbmFsIG1vdmVtZW50IHRvdWNoaW5nXHJcbiAqICAgICBibG9jayBjb3JuZXJzLiBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge0RpYWdvbmFsTW92ZW1lbnR9IG9wdC5kaWFnb25hbE1vdmVtZW50IEFsbG93ZWQgZGlhZ29uYWwgbW92ZW1lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBCaUJyZWFkdGhGaXJzdEZpbmRlcihvcHQpIHtcclxuICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuICAgIHRoaXMuYWxsb3dEaWFnb25hbCA9IG9wdC5hbGxvd0RpYWdvbmFsO1xyXG4gICAgdGhpcy5kb250Q3Jvc3NDb3JuZXJzID0gb3B0LmRvbnRDcm9zc0Nvcm5lcnM7XHJcbiAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBvcHQuZGlhZ29uYWxNb3ZlbWVudDtcclxuXHJcbiAgICBpZiAoIXRoaXMuZGlhZ29uYWxNb3ZlbWVudCkge1xyXG4gICAgICAgIGlmICghdGhpcy5hbGxvd0RpYWdvbmFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuTmV2ZXI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZG9udENyb3NzQ29ybmVycykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5Pbmx5V2hlbk5vT2JzdGFjbGVzO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5JZkF0TW9zdE9uZU9ic3RhY2xlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEZpbmQgYW5kIHJldHVybiB0aGUgdGhlIHBhdGguXHJcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBUaGUgcGF0aCwgaW5jbHVkaW5nIGJvdGggc3RhcnQgYW5kXHJcbiAqICAgICBlbmQgcG9zaXRpb25zLlxyXG4gKi9cclxuQmlCcmVhZHRoRmlyc3RGaW5kZXIucHJvdG90eXBlLmZpbmRQYXRoID0gZnVuY3Rpb24oc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIGdyaWQpIHtcclxuICAgIHZhciBzdGFydE5vZGUgPSBncmlkLmdldE5vZGVBdChzdGFydFgsIHN0YXJ0WSksXHJcbiAgICAgICAgZW5kTm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KGVuZFgsIGVuZFkpLFxyXG4gICAgICAgIHN0YXJ0T3Blbkxpc3QgPSBbXSwgZW5kT3Blbkxpc3QgPSBbXSxcclxuICAgICAgICBuZWlnaGJvcnMsIG5laWdoYm9yLCBub2RlLFxyXG4gICAgICAgIGRpYWdvbmFsTW92ZW1lbnQgPSB0aGlzLmRpYWdvbmFsTW92ZW1lbnQsXHJcbiAgICAgICAgQllfU1RBUlQgPSAwLCBCWV9FTkQgPSAxLFxyXG4gICAgICAgIGksIGw7XHJcblxyXG4gICAgLy8gcHVzaCB0aGUgc3RhcnQgYW5kIGVuZCBub2RlcyBpbnRvIHRoZSBxdWV1ZXNcclxuICAgIHN0YXJ0T3Blbkxpc3QucHVzaChzdGFydE5vZGUpO1xyXG4gICAgc3RhcnROb2RlLm9wZW5lZCA9IHRydWU7XHJcbiAgICBzdGFydE5vZGUuYnkgPSBCWV9TVEFSVDtcclxuXHJcbiAgICBlbmRPcGVuTGlzdC5wdXNoKGVuZE5vZGUpO1xyXG4gICAgZW5kTm9kZS5vcGVuZWQgPSB0cnVlO1xyXG4gICAgZW5kTm9kZS5ieSA9IEJZX0VORDtcclxuXHJcbiAgICAvLyB3aGlsZSBib3RoIHRoZSBxdWV1ZXMgYXJlIG5vdCBlbXB0eVxyXG4gICAgd2hpbGUgKHN0YXJ0T3Blbkxpc3QubGVuZ3RoICYmIGVuZE9wZW5MaXN0Lmxlbmd0aCkge1xyXG5cclxuICAgICAgICAvLyBleHBhbmQgc3RhcnQgb3BlbiBsaXN0XHJcblxyXG4gICAgICAgIG5vZGUgPSBzdGFydE9wZW5MaXN0LnNoaWZ0KCk7XHJcbiAgICAgICAgbm9kZS5jbG9zZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICBuZWlnaGJvcnMgPSBncmlkLmdldE5laWdoYm9ycyhub2RlLCBkaWFnb25hbE1vdmVtZW50KTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xyXG4gICAgICAgICAgICBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuZWlnaGJvci5jbG9zZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZWlnaGJvci5vcGVuZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgbm9kZSBoYXMgYmVlbiBpbnNwZWN0ZWQgYnkgdGhlIHJldmVyc2VkIHNlYXJjaCxcclxuICAgICAgICAgICAgICAgIC8vIHRoZW4gYSBwYXRoIGlzIGZvdW5kLlxyXG4gICAgICAgICAgICAgICAgaWYgKG5laWdoYm9yLmJ5ID09PSBCWV9FTkQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbC5iaUJhY2t0cmFjZShub2RlLCBuZWlnaGJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdGFydE9wZW5MaXN0LnB1c2gobmVpZ2hib3IpO1xyXG4gICAgICAgICAgICBuZWlnaGJvci5wYXJlbnQgPSBub2RlO1xyXG4gICAgICAgICAgICBuZWlnaGJvci5vcGVuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBuZWlnaGJvci5ieSA9IEJZX1NUQVJUO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZXhwYW5kIGVuZCBvcGVuIGxpc3RcclxuXHJcbiAgICAgICAgbm9kZSA9IGVuZE9wZW5MaXN0LnNoaWZ0KCk7XHJcbiAgICAgICAgbm9kZS5jbG9zZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICBuZWlnaGJvcnMgPSBncmlkLmdldE5laWdoYm9ycyhub2RlLCBkaWFnb25hbE1vdmVtZW50KTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xyXG4gICAgICAgICAgICBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuZWlnaGJvci5jbG9zZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZWlnaGJvci5vcGVuZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZWlnaGJvci5ieSA9PT0gQllfU1RBUlQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbC5iaUJhY2t0cmFjZShuZWlnaGJvciwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbmRPcGVuTGlzdC5wdXNoKG5laWdoYm9yKTtcclxuICAgICAgICAgICAgbmVpZ2hib3IucGFyZW50ID0gbm9kZTtcclxuICAgICAgICAgICAgbmVpZ2hib3Iub3BlbmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgbmVpZ2hib3IuYnkgPSBCWV9FTkQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGZhaWwgdG8gZmluZCB0aGUgcGF0aFxyXG4gICAgcmV0dXJuIFtdO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCaUJyZWFkdGhGaXJzdEZpbmRlcjtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/finders/BiDijkstraFinder.js":
/*!******************************************************************!*\
  !*** ./node_modules/pathfinding/src/finders/BiDijkstraFinder.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var BiAStarFinder = __webpack_require__(/*! ./BiAStarFinder */ \"./node_modules/pathfinding/src/finders/BiAStarFinder.js\");\r\n\r\n/**\r\n * Bi-directional Dijkstra path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiDijkstraFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nBiDijkstraFinder.prototype = new BiAStarFinder();\r\nBiDijkstraFinder.prototype.constructor = BiDijkstraFinder;\r\n\r\nmodule.exports = BiDijkstraFinder;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvQmlEaWprc3RyYUZpbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhY29ubWFuLy4vbm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9maW5kZXJzL0JpRGlqa3N0cmFGaW5kZXIuanM/NDlhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQmlBU3RhckZpbmRlciA9IHJlcXVpcmUoJy4vQmlBU3RhckZpbmRlcicpO1xyXG5cclxuLyoqXHJcbiAqIEJpLWRpcmVjdGlvbmFsIERpamtzdHJhIHBhdGgtZmluZGVyLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgQmlBU3RhckZpbmRlclxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmFsbG93RGlhZ29uYWwgV2hldGhlciBkaWFnb25hbCBtb3ZlbWVudCBpcyBhbGxvd2VkLlxyXG4gKiAgICAgRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuZG9udENyb3NzQ29ybmVycyBEaXNhbGxvdyBkaWFnb25hbCBtb3ZlbWVudCB0b3VjaGluZ1xyXG4gKiAgICAgYmxvY2sgY29ybmVycy4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cclxuICogQHBhcmFtIHtEaWFnb25hbE1vdmVtZW50fSBvcHQuZGlhZ29uYWxNb3ZlbWVudCBBbGxvd2VkIGRpYWdvbmFsIG1vdmVtZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gQmlEaWprc3RyYUZpbmRlcihvcHQpIHtcclxuICAgIEJpQVN0YXJGaW5kZXIuY2FsbCh0aGlzLCBvcHQpO1xyXG4gICAgdGhpcy5oZXVyaXN0aWMgPSBmdW5jdGlvbihkeCwgZHkpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbn1cclxuXHJcbkJpRGlqa3N0cmFGaW5kZXIucHJvdG90eXBlID0gbmV3IEJpQVN0YXJGaW5kZXIoKTtcclxuQmlEaWprc3RyYUZpbmRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCaURpamtzdHJhRmluZGVyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCaURpamtzdHJhRmluZGVyO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/finders/BiDijkstraFinder.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/finders/BreadthFirstFinder.js":
/*!********************************************************************!*\
  !*** ./node_modules/pathfinding/src/finders/BreadthFirstFinder.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var Util = __webpack_require__(/*! ../core/Util */ \"./node_modules/pathfinding/src/core/Util.js\");\r\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./node_modules/pathfinding/src/core/DiagonalMovement.js\");\r\n\r\n/**\r\n * Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = [],\r\n        diagonalMovement = this.diagonalMovement,\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        neighbors, neighbor, node, i, l;\r\n\r\n    // push the start pos into the queue\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the queue is not empty\r\n    while (openList.length) {\r\n        // take the front node from the queue\r\n        node = openList.shift();\r\n        node.closed = true;\r\n\r\n        // reached the end position\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            // skip this neighbor if it has been inspected before\r\n            if (neighbor.closed || neighbor.opened) {\r\n                continue;\r\n            }\r\n\r\n            openList.push(neighbor);\r\n            neighbor.opened = true;\r\n            neighbor.parent = node;\r\n        }\r\n    }\r\n    \r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BreadthFirstFinder;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvQnJlYWR0aEZpcnN0RmluZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQyxpRUFBYztBQUNqQyx1QkFBdUIsbUJBQU8sQ0FBQyx5RkFBMEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhY29ubWFuLy4vbm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9maW5kZXJzL0JyZWFkdGhGaXJzdEZpbmRlci5qcz81OGM0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBVdGlsID0gcmVxdWlyZSgnLi4vY29yZS9VdGlsJyk7XHJcbnZhciBEaWFnb25hbE1vdmVtZW50ID0gcmVxdWlyZSgnLi4vY29yZS9EaWFnb25hbE1vdmVtZW50Jyk7XHJcblxyXG4vKipcclxuICogQnJlYWR0aC1GaXJzdC1TZWFyY2ggcGF0aCBmaW5kZXIuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmFsbG93RGlhZ29uYWwgV2hldGhlciBkaWFnb25hbCBtb3ZlbWVudCBpcyBhbGxvd2VkLlxyXG4gKiAgICAgRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuZG9udENyb3NzQ29ybmVycyBEaXNhbGxvdyBkaWFnb25hbCBtb3ZlbWVudCB0b3VjaGluZ1xyXG4gKiAgICAgYmxvY2sgY29ybmVycy4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cclxuICogQHBhcmFtIHtEaWFnb25hbE1vdmVtZW50fSBvcHQuZGlhZ29uYWxNb3ZlbWVudCBBbGxvd2VkIGRpYWdvbmFsIG1vdmVtZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gQnJlYWR0aEZpcnN0RmluZGVyKG9wdCkge1xyXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgdGhpcy5hbGxvd0RpYWdvbmFsID0gb3B0LmFsbG93RGlhZ29uYWw7XHJcbiAgICB0aGlzLmRvbnRDcm9zc0Nvcm5lcnMgPSBvcHQuZG9udENyb3NzQ29ybmVycztcclxuICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IG9wdC5kaWFnb25hbE1vdmVtZW50O1xyXG5cclxuICAgIGlmICghdGhpcy5kaWFnb25hbE1vdmVtZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93RGlhZ29uYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5OZXZlcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kb250Q3Jvc3NDb3JuZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50Lk9ubHlXaGVuTm9PYnN0YWNsZXM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50LklmQXRNb3N0T25lT2JzdGFjbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaW5kIGFuZCByZXR1cm4gdGhlIHRoZSBwYXRoLlxyXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gVGhlIHBhdGgsIGluY2x1ZGluZyBib3RoIHN0YXJ0IGFuZFxyXG4gKiAgICAgZW5kIHBvc2l0aW9ucy5cclxuICovXHJcbkJyZWFkdGhGaXJzdEZpbmRlci5wcm90b3R5cGUuZmluZFBhdGggPSBmdW5jdGlvbihzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgZ3JpZCkge1xyXG4gICAgdmFyIG9wZW5MaXN0ID0gW10sXHJcbiAgICAgICAgZGlhZ29uYWxNb3ZlbWVudCA9IHRoaXMuZGlhZ29uYWxNb3ZlbWVudCxcclxuICAgICAgICBzdGFydE5vZGUgPSBncmlkLmdldE5vZGVBdChzdGFydFgsIHN0YXJ0WSksXHJcbiAgICAgICAgZW5kTm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KGVuZFgsIGVuZFkpLFxyXG4gICAgICAgIG5laWdoYm9ycywgbmVpZ2hib3IsIG5vZGUsIGksIGw7XHJcblxyXG4gICAgLy8gcHVzaCB0aGUgc3RhcnQgcG9zIGludG8gdGhlIHF1ZXVlXHJcbiAgICBvcGVuTGlzdC5wdXNoKHN0YXJ0Tm9kZSk7XHJcbiAgICBzdGFydE5vZGUub3BlbmVkID0gdHJ1ZTtcclxuXHJcbiAgICAvLyB3aGlsZSB0aGUgcXVldWUgaXMgbm90IGVtcHR5XHJcbiAgICB3aGlsZSAob3Blbkxpc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gdGFrZSB0aGUgZnJvbnQgbm9kZSBmcm9tIHRoZSBxdWV1ZVxyXG4gICAgICAgIG5vZGUgPSBvcGVuTGlzdC5zaGlmdCgpO1xyXG4gICAgICAgIG5vZGUuY2xvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gcmVhY2hlZCB0aGUgZW5kIHBvc2l0aW9uXHJcbiAgICAgICAgaWYgKG5vZGUgPT09IGVuZE5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFV0aWwuYmFja3RyYWNlKGVuZE5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbmVpZ2hib3JzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgZGlhZ29uYWxNb3ZlbWVudCk7XHJcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5laWdoYm9ycy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XHJcblxyXG4gICAgICAgICAgICAvLyBza2lwIHRoaXMgbmVpZ2hib3IgaWYgaXQgaGFzIGJlZW4gaW5zcGVjdGVkIGJlZm9yZVxyXG4gICAgICAgICAgICBpZiAobmVpZ2hib3IuY2xvc2VkIHx8IG5laWdoYm9yLm9wZW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG9wZW5MaXN0LnB1c2gobmVpZ2hib3IpO1xyXG4gICAgICAgICAgICBuZWlnaGJvci5vcGVuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBuZWlnaGJvci5wYXJlbnQgPSBub2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gZmFpbCB0byBmaW5kIHRoZSBwYXRoXHJcbiAgICByZXR1cm4gW107XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEJyZWFkdGhGaXJzdEZpbmRlcjtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/finders/BreadthFirstFinder.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/finders/DijkstraFinder.js":
/*!****************************************************************!*\
  !*** ./node_modules/pathfinding/src/finders/DijkstraFinder.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var AStarFinder = __webpack_require__(/*! ./AStarFinder */ \"./node_modules/pathfinding/src/finders/AStarFinder.js\");\r\n\r\n/**\r\n * Dijkstra path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction DijkstraFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nDijkstraFinder.prototype = new AStarFinder();\r\nDijkstraFinder.prototype.constructor = DijkstraFinder;\r\n\r\nmodule.exports = DijkstraFinder;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvRGlqa3N0cmFGaW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsa0JBQWtCLG1CQUFPLENBQUMsNEVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhY29ubWFuLy4vbm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9maW5kZXJzL0RpamtzdHJhRmluZGVyLmpzP2E1OTEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEFTdGFyRmluZGVyID0gcmVxdWlyZSgnLi9BU3RhckZpbmRlcicpO1xyXG5cclxuLyoqXHJcbiAqIERpamtzdHJhIHBhdGgtZmluZGVyLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGV4dGVuZHMgQVN0YXJGaW5kZXJcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5hbGxvd0RpYWdvbmFsIFdoZXRoZXIgZGlhZ29uYWwgbW92ZW1lbnQgaXMgYWxsb3dlZC5cclxuICogICAgIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmRvbnRDcm9zc0Nvcm5lcnMgRGlzYWxsb3cgZGlhZ29uYWwgbW92ZW1lbnQgdG91Y2hpbmdcclxuICogICAgIGJsb2NrIGNvcm5lcnMuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXHJcbiAqIEBwYXJhbSB7RGlhZ29uYWxNb3ZlbWVudH0gb3B0LmRpYWdvbmFsTW92ZW1lbnQgQWxsb3dlZCBkaWFnb25hbCBtb3ZlbWVudC5cclxuICovXHJcbmZ1bmN0aW9uIERpamtzdHJhRmluZGVyKG9wdCkge1xyXG4gICAgQVN0YXJGaW5kZXIuY2FsbCh0aGlzLCBvcHQpO1xyXG4gICAgdGhpcy5oZXVyaXN0aWMgPSBmdW5jdGlvbihkeCwgZHkpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbn1cclxuXHJcbkRpamtzdHJhRmluZGVyLnByb3RvdHlwZSA9IG5ldyBBU3RhckZpbmRlcigpO1xyXG5EaWprc3RyYUZpbmRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaWprc3RyYUZpbmRlcjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGlqa3N0cmFGaW5kZXI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/finders/DijkstraFinder.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/finders/IDAStarFinder.js":
/*!***************************************************************!*\
  !*** ./node_modules/pathfinding/src/finders/IDAStarFinder.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var Util       = __webpack_require__(/*! ../core/Util */ \"./node_modules/pathfinding/src/core/Util.js\");\r\nvar Heuristic  = __webpack_require__(/*! ../core/Heuristic */ \"./node_modules/pathfinding/src/core/Heuristic.js\");\r\nvar Node       = __webpack_require__(/*! ../core/Node */ \"./node_modules/pathfinding/src/core/Node.js\");\r\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./node_modules/pathfinding/src/core/DiagonalMovement.js\");\r\n\r\n/**\r\n * Iterative Deeping A Star (IDA*) path-finder.\r\n *\r\n * Recursion based on:\r\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\r\n *\r\n * Path retracing based on:\r\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\r\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\r\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\r\n *\r\n * @author Gerard Meier (www.gerardmeier.com)\r\n *\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n * @param {boolean} opt.trackRecursion Whether to track recursion for\r\n *     statistical purposes.\r\n * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\r\n */\r\nfunction IDAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.trackRecursion = opt.trackRecursion || false;\r\n    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    // admissible, it should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path. When an empty array is returned, either\r\n * no path is possible, or the maximum execution time is reached.\r\n *\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nIDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    // Used for statistics:\r\n    var nodesVisited = 0;\r\n\r\n    // Execution time limitation:\r\n    var startTime = new Date().getTime();\r\n\r\n    // Heuristic helper:\r\n    var h = function(a, b) {\r\n        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\r\n    }.bind(this);\r\n\r\n    // Step cost from a to b:\r\n    var cost = function(a, b) {\r\n        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;\r\n    };\r\n\r\n    /**\r\n     * IDA* search implementation.\r\n     *\r\n     * @param {Node} The node currently expanding from.\r\n     * @param {number} Cost to reach the given node.\r\n     * @param {number} Maximum search depth (cut-off value).\r\n     * @param {Array<Array<number>>} The found route.\r\n     * @param {number} Recursion depth.\r\n     *\r\n     * @return {Object} either a number with the new optimal cut-off depth,\r\n     * or a valid node instance, in which case a path was found.\r\n     */\r\n    var search = function(node, g, cutoff, route, depth) {\r\n        nodesVisited++;\r\n\r\n        // Enforce timelimit:\r\n        if (this.timeLimit > 0 &&\r\n            new Date().getTime() - startTime > this.timeLimit * 1000) {\r\n            // Enforced as \"path-not-found\".\r\n            return Infinity;\r\n        }\r\n\r\n        var f = g + h(node, end) * this.weight;\r\n\r\n        // We've searched too deep for this iteration.\r\n        if (f > cutoff) {\r\n            return f;\r\n        }\r\n\r\n        if (node == end) {\r\n            route[depth] = [node.x, node.y];\r\n            return node;\r\n        }\r\n\r\n        var min, t, k, neighbour;\r\n\r\n        var neighbours = grid.getNeighbors(node, this.diagonalMovement);\r\n\r\n        // Sort the neighbours, gives nicer paths. But, this deviates\r\n        // from the original algorithm - so I left it out.\r\n        //neighbours.sort(function(a, b){\r\n        //    return h(a, end) - h(b, end);\r\n        //});\r\n\r\n        \r\n        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment\r\n        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\r\n        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment\r\n            if (this.trackRecursion) {\r\n                // Retain a copy for visualisation. Due to recursion, this\r\n                // node may be part of other paths too.\r\n                neighbour.retainCount = neighbour.retainCount + 1 || 1;\r\n\r\n                if(neighbour.tested !== true) {\r\n                    neighbour.tested = true;\r\n                }\r\n            }\r\n\r\n            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\r\n\r\n            if (t instanceof Node) {\r\n                route[depth] = [node.x, node.y];\r\n\r\n                // For a typical A* linked list, this would work:\r\n                // neighbour.parent = node;\r\n                return t;\r\n            }\r\n\r\n            // Decrement count, then determine whether it's actually closed.\r\n            if (this.trackRecursion && (--neighbour.retainCount) === 0) {\r\n                neighbour.tested = false;\r\n            }\r\n\r\n            if (t < min) {\r\n                min = t;\r\n            }\r\n        }\r\n\r\n        return min;\r\n\r\n    }.bind(this);\r\n\r\n    // Node instance lookups:\r\n    var start = grid.getNodeAt(startX, startY);\r\n    var end   = grid.getNodeAt(endX, endY);\r\n\r\n    // Initial search depth, given the typical heuristic contraints,\r\n    // there should be no cheaper route possible.\r\n    var cutOff = h(start, end);\r\n\r\n    var j, route, t;\r\n\r\n    // With an overflow protection.\r\n    for (j = 0; true; ++j) {\r\n\r\n        route = [];\r\n\r\n        // Search till cut-off depth:\r\n        t = search(start, 0, cutOff, route, 0);\r\n\r\n        // Route not possible, or not found in time limit.\r\n        if (t === Infinity) {\r\n            return [];\r\n        }\r\n\r\n        // If t is a node, it's also the end node. Route is now\r\n        // populated with a valid path to the end node.\r\n        if (t instanceof Node) {\r\n            return route;\r\n        }\r\n\r\n        // Try again, this time with a deeper cut-off. The t score\r\n        // is the closest we got to the end node.\r\n        cutOff = t;\r\n    }\r\n\r\n    // This _should_ never to be reached.\r\n    return [];\r\n};\r\n\r\nmodule.exports = IDAStarFinder;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvSURBU3RhckZpbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxpRUFBYztBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQywyRUFBbUI7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsaUVBQWM7QUFDdkMsdUJBQXVCLG1CQUFPLENBQUMseUZBQTBCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxzQkFBc0I7QUFDckMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkJBQTJCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhY29ubWFuLy4vbm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9maW5kZXJzL0lEQVN0YXJGaW5kZXIuanM/ZWVjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVXRpbCAgICAgICA9IHJlcXVpcmUoJy4uL2NvcmUvVXRpbCcpO1xyXG52YXIgSGV1cmlzdGljICA9IHJlcXVpcmUoJy4uL2NvcmUvSGV1cmlzdGljJyk7XHJcbnZhciBOb2RlICAgICAgID0gcmVxdWlyZSgnLi4vY29yZS9Ob2RlJyk7XHJcbnZhciBEaWFnb25hbE1vdmVtZW50ID0gcmVxdWlyZSgnLi4vY29yZS9EaWFnb25hbE1vdmVtZW50Jyk7XHJcblxyXG4vKipcclxuICogSXRlcmF0aXZlIERlZXBpbmcgQSBTdGFyIChJREEqKSBwYXRoLWZpbmRlci5cclxuICpcclxuICogUmVjdXJzaW9uIGJhc2VkIG9uOlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBsLmpodS5lZHUvfmhhbGwvQUktUHJvZ3JhbW1pbmcvSURBLVN0YXIuaHRtbFxyXG4gKlxyXG4gKiBQYXRoIHJldHJhY2luZyBiYXNlZCBvbjpcclxuICogIFYuIE5hZ2VzaHdhcmEgUmFvLCBWaXBpbiBLdW1hciBhbmQgSy4gUmFtZXNoXHJcbiAqICBcIkEgUGFyYWxsZWwgSW1wbGVtZW50YXRpb24gb2YgSXRlcmF0aXZlLURlZXBpbmctQSpcIiwgSmFudWFyeSAxOTg3LlxyXG4gKiAgZnRwOi8vZnRwLmNzLnV0ZXhhcy5lZHUvLnNuYXBzaG90L2hvdXJseS4xL3B1Yi9BSS1MYWIvdGVjaC1yZXBvcnRzL1VULUFJLVRSLTg3LTQ2LnBkZlxyXG4gKlxyXG4gKiBAYXV0aG9yIEdlcmFyZCBNZWllciAod3d3LmdlcmFyZG1laWVyLmNvbSlcclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuYWxsb3dEaWFnb25hbCBXaGV0aGVyIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQuXHJcbiAqICAgICBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5kb250Q3Jvc3NDb3JuZXJzIERpc2FsbG93IGRpYWdvbmFsIG1vdmVtZW50IHRvdWNoaW5nXHJcbiAqICAgICBibG9jayBjb3JuZXJzLiBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge0RpYWdvbmFsTW92ZW1lbnR9IG9wdC5kaWFnb25hbE1vdmVtZW50IEFsbG93ZWQgZGlhZ29uYWwgbW92ZW1lbnQuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdC5oZXVyaXN0aWMgSGV1cmlzdGljIGZ1bmN0aW9uIHRvIGVzdGltYXRlIHRoZSBkaXN0YW5jZVxyXG4gKiAgICAgKGRlZmF1bHRzIHRvIG1hbmhhdHRhbikuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHQud2VpZ2h0IFdlaWdodCB0byBhcHBseSB0byB0aGUgaGV1cmlzdGljIHRvIGFsbG93IGZvclxyXG4gKiAgICAgc3Vib3B0aW1hbCBwYXRocywgaW4gb3JkZXIgdG8gc3BlZWQgdXAgdGhlIHNlYXJjaC5cclxuICogQHBhcmFtIHtib29sZWFufSBvcHQudHJhY2tSZWN1cnNpb24gV2hldGhlciB0byB0cmFjayByZWN1cnNpb24gZm9yXHJcbiAqICAgICBzdGF0aXN0aWNhbCBwdXJwb3Nlcy5cclxuICogQHBhcmFtIHtudW1iZXJ9IG9wdC50aW1lTGltaXQgTWF4aW11bSBleGVjdXRpb24gdGltZS4gVXNlIDw9IDAgZm9yIGluZmluaXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gSURBU3RhckZpbmRlcihvcHQpIHtcclxuICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuICAgIHRoaXMuYWxsb3dEaWFnb25hbCA9IG9wdC5hbGxvd0RpYWdvbmFsO1xyXG4gICAgdGhpcy5kb250Q3Jvc3NDb3JuZXJzID0gb3B0LmRvbnRDcm9zc0Nvcm5lcnM7XHJcbiAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBvcHQuZGlhZ29uYWxNb3ZlbWVudDtcclxuICAgIHRoaXMuaGV1cmlzdGljID0gb3B0LmhldXJpc3RpYyB8fCBIZXVyaXN0aWMubWFuaGF0dGFuO1xyXG4gICAgdGhpcy53ZWlnaHQgPSBvcHQud2VpZ2h0IHx8IDE7XHJcbiAgICB0aGlzLnRyYWNrUmVjdXJzaW9uID0gb3B0LnRyYWNrUmVjdXJzaW9uIHx8IGZhbHNlO1xyXG4gICAgdGhpcy50aW1lTGltaXQgPSBvcHQudGltZUxpbWl0IHx8IEluZmluaXR5OyAvLyBEZWZhdWx0OiBubyB0aW1lIGxpbWl0LlxyXG5cclxuICAgIGlmICghdGhpcy5kaWFnb25hbE1vdmVtZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93RGlhZ29uYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5OZXZlcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kb250Q3Jvc3NDb3JuZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50Lk9ubHlXaGVuTm9PYnN0YWNsZXM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50LklmQXRNb3N0T25lT2JzdGFjbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2hlbiBkaWFnb25hbCBtb3ZlbWVudCBpcyBhbGxvd2VkIHRoZSBtYW5oYXR0YW4gaGV1cmlzdGljIGlzIG5vdFxyXG4gICAgLy8gYWRtaXNzaWJsZSwgaXQgc2hvdWxkIGJlIG9jdGlsZSBpbnN0ZWFkXHJcbiAgICBpZiAodGhpcy5kaWFnb25hbE1vdmVtZW50ID09PSBEaWFnb25hbE1vdmVtZW50Lk5ldmVyKSB7XHJcbiAgICAgICAgdGhpcy5oZXVyaXN0aWMgPSBvcHQuaGV1cmlzdGljIHx8IEhldXJpc3RpYy5tYW5oYXR0YW47XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuaGV1cmlzdGljID0gb3B0LmhldXJpc3RpYyB8fCBIZXVyaXN0aWMub2N0aWxlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmluZCBhbmQgcmV0dXJuIHRoZSB0aGUgcGF0aC4gV2hlbiBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZCwgZWl0aGVyXHJcbiAqIG5vIHBhdGggaXMgcG9zc2libGUsIG9yIHRoZSBtYXhpbXVtIGV4ZWN1dGlvbiB0aW1lIGlzIHJlYWNoZWQuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBUaGUgcGF0aCwgaW5jbHVkaW5nIGJvdGggc3RhcnQgYW5kXHJcbiAqICAgICBlbmQgcG9zaXRpb25zLlxyXG4gKi9cclxuSURBU3RhckZpbmRlci5wcm90b3R5cGUuZmluZFBhdGggPSBmdW5jdGlvbihzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgZ3JpZCkge1xyXG4gICAgLy8gVXNlZCBmb3Igc3RhdGlzdGljczpcclxuICAgIHZhciBub2Rlc1Zpc2l0ZWQgPSAwO1xyXG5cclxuICAgIC8vIEV4ZWN1dGlvbiB0aW1lIGxpbWl0YXRpb246XHJcbiAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgLy8gSGV1cmlzdGljIGhlbHBlcjpcclxuICAgIHZhciBoID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhldXJpc3RpYyhNYXRoLmFicyhiLnggLSBhLngpLCBNYXRoLmFicyhiLnkgLSBhLnkpKTtcclxuICAgIH0uYmluZCh0aGlzKTtcclxuXHJcbiAgICAvLyBTdGVwIGNvc3QgZnJvbSBhIHRvIGI6XHJcbiAgICB2YXIgY29zdCA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gKGEueCA9PT0gYi54IHx8IGEueSA9PT0gYi55KSA/IDEgOiBNYXRoLlNRUlQyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElEQSogc2VhcmNoIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gVGhlIG5vZGUgY3VycmVudGx5IGV4cGFuZGluZyBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IENvc3QgdG8gcmVhY2ggdGhlIGdpdmVuIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gTWF4aW11bSBzZWFyY2ggZGVwdGggKGN1dC1vZmYgdmFsdWUpLlxyXG4gICAgICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gVGhlIGZvdW5kIHJvdXRlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFJlY3Vyc2lvbiBkZXB0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGVpdGhlciBhIG51bWJlciB3aXRoIHRoZSBuZXcgb3B0aW1hbCBjdXQtb2ZmIGRlcHRoLFxyXG4gICAgICogb3IgYSB2YWxpZCBub2RlIGluc3RhbmNlLCBpbiB3aGljaCBjYXNlIGEgcGF0aCB3YXMgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIHZhciBzZWFyY2ggPSBmdW5jdGlvbihub2RlLCBnLCBjdXRvZmYsIHJvdXRlLCBkZXB0aCkge1xyXG4gICAgICAgIG5vZGVzVmlzaXRlZCsrO1xyXG5cclxuICAgICAgICAvLyBFbmZvcmNlIHRpbWVsaW1pdDpcclxuICAgICAgICBpZiAodGhpcy50aW1lTGltaXQgPiAwICYmXHJcbiAgICAgICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lID4gdGhpcy50aW1lTGltaXQgKiAxMDAwKSB7XHJcbiAgICAgICAgICAgIC8vIEVuZm9yY2VkIGFzIFwicGF0aC1ub3QtZm91bmRcIi5cclxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGYgPSBnICsgaChub2RlLCBlbmQpICogdGhpcy53ZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vIFdlJ3ZlIHNlYXJjaGVkIHRvbyBkZWVwIGZvciB0aGlzIGl0ZXJhdGlvbi5cclxuICAgICAgICBpZiAoZiA+IGN1dG9mZikge1xyXG4gICAgICAgICAgICByZXR1cm4gZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChub2RlID09IGVuZCkge1xyXG4gICAgICAgICAgICByb3V0ZVtkZXB0aF0gPSBbbm9kZS54LCBub2RlLnldO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtaW4sIHQsIGssIG5laWdoYm91cjtcclxuXHJcbiAgICAgICAgdmFyIG5laWdoYm91cnMgPSBncmlkLmdldE5laWdoYm9ycyhub2RlLCB0aGlzLmRpYWdvbmFsTW92ZW1lbnQpO1xyXG5cclxuICAgICAgICAvLyBTb3J0IHRoZSBuZWlnaGJvdXJzLCBnaXZlcyBuaWNlciBwYXRocy4gQnV0LCB0aGlzIGRldmlhdGVzXHJcbiAgICAgICAgLy8gZnJvbSB0aGUgb3JpZ2luYWwgYWxnb3JpdGhtIC0gc28gSSBsZWZ0IGl0IG91dC5cclxuICAgICAgICAvL25laWdoYm91cnMuc29ydChmdW5jdGlvbihhLCBiKXtcclxuICAgICAgICAvLyAgICByZXR1cm4gaChhLCBlbmQpIC0gaChiLCBlbmQpO1xyXG4gICAgICAgIC8vfSk7XHJcblxyXG4gICAgICAgIFxyXG4gICAgICAgIC8qanNoaW50IC1XMDg0ICovLy9EaXNhYmxlIHdhcm5pbmc6IEV4cGVjdGVkIGEgY29uZGl0aW9uYWwgZXhwcmVzc2lvbiBhbmQgaW5zdGVhZCBzYXcgYW4gYXNzaWdubWVudFxyXG4gICAgICAgIGZvciAoayA9IDAsIG1pbiA9IEluZmluaXR5OyBuZWlnaGJvdXIgPSBuZWlnaGJvdXJzW2tdOyArK2spIHtcclxuICAgICAgICAvKmpzaGludCArVzA4NCAqLy8vRW5hYmxlIHdhcm5pbmc6IEV4cGVjdGVkIGEgY29uZGl0aW9uYWwgZXhwcmVzc2lvbiBhbmQgaW5zdGVhZCBzYXcgYW4gYXNzaWdubWVudFxyXG4gICAgICAgICAgICBpZiAodGhpcy50cmFja1JlY3Vyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgLy8gUmV0YWluIGEgY29weSBmb3IgdmlzdWFsaXNhdGlvbi4gRHVlIHRvIHJlY3Vyc2lvbiwgdGhpc1xyXG4gICAgICAgICAgICAgICAgLy8gbm9kZSBtYXkgYmUgcGFydCBvZiBvdGhlciBwYXRocyB0b28uXHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvdXIucmV0YWluQ291bnQgPSBuZWlnaGJvdXIucmV0YWluQ291bnQgKyAxIHx8IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYobmVpZ2hib3VyLnRlc3RlZCAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm91ci50ZXN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0ID0gc2VhcmNoKG5laWdoYm91ciwgZyArIGNvc3Qobm9kZSwgbmVpZ2hib3VyKSwgY3V0b2ZmLCByb3V0ZSwgZGVwdGggKyAxKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0IGluc3RhbmNlb2YgTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcm91dGVbZGVwdGhdID0gW25vZGUueCwgbm9kZS55XTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgYSB0eXBpY2FsIEEqIGxpbmtlZCBsaXN0LCB0aGlzIHdvdWxkIHdvcms6XHJcbiAgICAgICAgICAgICAgICAvLyBuZWlnaGJvdXIucGFyZW50ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEZWNyZW1lbnQgY291bnQsIHRoZW4gZGV0ZXJtaW5lIHdoZXRoZXIgaXQncyBhY3R1YWxseSBjbG9zZWQuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrUmVjdXJzaW9uICYmICgtLW5laWdoYm91ci5yZXRhaW5Db3VudCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIG5laWdoYm91ci50ZXN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHQgPCBtaW4pIHtcclxuICAgICAgICAgICAgICAgIG1pbiA9IHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBtaW47XHJcblxyXG4gICAgfS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIC8vIE5vZGUgaW5zdGFuY2UgbG9va3VwczpcclxuICAgIHZhciBzdGFydCA9IGdyaWQuZ2V0Tm9kZUF0KHN0YXJ0WCwgc3RhcnRZKTtcclxuICAgIHZhciBlbmQgICA9IGdyaWQuZ2V0Tm9kZUF0KGVuZFgsIGVuZFkpO1xyXG5cclxuICAgIC8vIEluaXRpYWwgc2VhcmNoIGRlcHRoLCBnaXZlbiB0aGUgdHlwaWNhbCBoZXVyaXN0aWMgY29udHJhaW50cyxcclxuICAgIC8vIHRoZXJlIHNob3VsZCBiZSBubyBjaGVhcGVyIHJvdXRlIHBvc3NpYmxlLlxyXG4gICAgdmFyIGN1dE9mZiA9IGgoc3RhcnQsIGVuZCk7XHJcblxyXG4gICAgdmFyIGosIHJvdXRlLCB0O1xyXG5cclxuICAgIC8vIFdpdGggYW4gb3ZlcmZsb3cgcHJvdGVjdGlvbi5cclxuICAgIGZvciAoaiA9IDA7IHRydWU7ICsraikge1xyXG5cclxuICAgICAgICByb3V0ZSA9IFtdO1xyXG5cclxuICAgICAgICAvLyBTZWFyY2ggdGlsbCBjdXQtb2ZmIGRlcHRoOlxyXG4gICAgICAgIHQgPSBzZWFyY2goc3RhcnQsIDAsIGN1dE9mZiwgcm91dGUsIDApO1xyXG5cclxuICAgICAgICAvLyBSb3V0ZSBub3QgcG9zc2libGUsIG9yIG5vdCBmb3VuZCBpbiB0aW1lIGxpbWl0LlxyXG4gICAgICAgIGlmICh0ID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB0IGlzIGEgbm9kZSwgaXQncyBhbHNvIHRoZSBlbmQgbm9kZS4gUm91dGUgaXMgbm93XHJcbiAgICAgICAgLy8gcG9wdWxhdGVkIHdpdGggYSB2YWxpZCBwYXRoIHRvIHRoZSBlbmQgbm9kZS5cclxuICAgICAgICBpZiAodCBpbnN0YW5jZW9mIE5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJvdXRlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVHJ5IGFnYWluLCB0aGlzIHRpbWUgd2l0aCBhIGRlZXBlciBjdXQtb2ZmLiBUaGUgdCBzY29yZVxyXG4gICAgICAgIC8vIGlzIHRoZSBjbG9zZXN0IHdlIGdvdCB0byB0aGUgZW5kIG5vZGUuXHJcbiAgICAgICAgY3V0T2ZmID0gdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGlzIF9zaG91bGRfIG5ldmVyIHRvIGJlIHJlYWNoZWQuXHJcbiAgICByZXR1cm4gW107XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IElEQVN0YXJGaW5kZXI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/finders/IDAStarFinder.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js":
/*!*************************************************************************!*\
  !*** ./node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = __webpack_require__(/*! ./JumpPointFinderBase */ \"./node_modules/pathfinding/src/finders/JumpPointFinderBase.js\");\r\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./node_modules/pathfinding/src/core/DiagonalMovement.js\");\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which always moves\r\n * diagonally irrespective of the number of obstacles.\r\n */\r\nfunction JPFAlwaysMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y + dy)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x + 1, y)) {\r\n                    neighbors.push([x + 1, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x - 1, y)) {\r\n                    neighbors.push([x - 1, y + dy]);\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y + 1)) {\r\n                    neighbors.push([x + dx, y + 1]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y - 1)) {\r\n                    neighbors.push([x + dx, y - 1]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFAlwaysMoveDiagonally;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvSlBGQWx3YXlzTW92ZURpYWdvbmFsbHkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsNEZBQXVCO0FBQ3pELHVCQUF1QixtQkFBTyxDQUFDLHlGQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmFjb25tYW4vLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvSlBGQWx3YXlzTW92ZURpYWdvbmFsbHkuanM/YTM0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGF1dGhvciBpbW9yIC8gaHR0cHM6Ly9naXRodWIuY29tL2ltb3JcclxuICovXHJcbnZhciBKdW1wUG9pbnRGaW5kZXJCYXNlID0gcmVxdWlyZSgnLi9KdW1wUG9pbnRGaW5kZXJCYXNlJyk7XHJcbnZhciBEaWFnb25hbE1vdmVtZW50ID0gcmVxdWlyZSgnLi4vY29yZS9EaWFnb25hbE1vdmVtZW50Jyk7XHJcblxyXG4vKipcclxuICogUGF0aCBmaW5kZXIgdXNpbmcgdGhlIEp1bXAgUG9pbnQgU2VhcmNoIGFsZ29yaXRobSB3aGljaCBhbHdheXMgbW92ZXNcclxuICogZGlhZ29uYWxseSBpcnJlc3BlY3RpdmUgb2YgdGhlIG51bWJlciBvZiBvYnN0YWNsZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBKUEZBbHdheXNNb3ZlRGlhZ29uYWxseShvcHQpIHtcclxuICAgIEp1bXBQb2ludEZpbmRlckJhc2UuY2FsbCh0aGlzLCBvcHQpO1xyXG59XHJcblxyXG5KUEZBbHdheXNNb3ZlRGlhZ29uYWxseS5wcm90b3R5cGUgPSBuZXcgSnVtcFBvaW50RmluZGVyQmFzZSgpO1xyXG5KUEZBbHdheXNNb3ZlRGlhZ29uYWxseS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBKUEZBbHdheXNNb3ZlRGlhZ29uYWxseTtcclxuXHJcbi8qKlxyXG4gKiBTZWFyY2ggcmVjdXJzaXZlbHkgaW4gdGhlIGRpcmVjdGlvbiAocGFyZW50IC0+IGNoaWxkKSwgc3RvcHBpbmcgb25seSB3aGVuIGFcclxuICoganVtcCBwb2ludCBpcyBmb3VuZC5cclxuICogQHByb3RlY3RlZFxyXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gVGhlIHgsIHkgY29vcmRpbmF0ZSBvZiB0aGUganVtcCBwb2ludFxyXG4gKiAgICAgZm91bmQsIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAqL1xyXG5KUEZBbHdheXNNb3ZlRGlhZ29uYWxseS5wcm90b3R5cGUuX2p1bXAgPSBmdW5jdGlvbih4LCB5LCBweCwgcHkpIHtcclxuICAgIHZhciBncmlkID0gdGhpcy5ncmlkLFxyXG4gICAgICAgIGR4ID0geCAtIHB4LCBkeSA9IHkgLSBweTtcclxuXHJcbiAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkpKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy50cmFja0p1bXBSZWN1cnNpb24gPT09IHRydWUpIHtcclxuICAgICAgICBncmlkLmdldE5vZGVBdCh4LCB5KS50ZXN0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChncmlkLmdldE5vZGVBdCh4LCB5KSA9PT0gdGhpcy5lbmROb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjaGVjayBmb3IgZm9yY2VkIG5laWdoYm9yc1xyXG4gICAgLy8gYWxvbmcgdGhlIGRpYWdvbmFsXHJcbiAgICBpZiAoZHggIT09IDAgJiYgZHkgIT09IDApIHtcclxuICAgICAgICBpZiAoKGdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSArIGR5KSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCAtIGR4LCB5KSkgfHxcclxuICAgICAgICAgICAgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSAtIGR5KSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSAtIGR5KSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2hlbiBtb3ZpbmcgZGlhZ29uYWxseSwgbXVzdCBjaGVjayBmb3IgdmVydGljYWwvaG9yaXpvbnRhbCBqdW1wIHBvaW50c1xyXG4gICAgICAgIGlmICh0aGlzLl9qdW1wKHggKyBkeCwgeSwgeCwgeSkgfHwgdGhpcy5fanVtcCh4LCB5ICsgZHksIHgsIHkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gaG9yaXpvbnRhbGx5L3ZlcnRpY2FsbHlcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmKCBkeCAhPT0gMCApIHsgLy8gbW92aW5nIGFsb25nIHhcclxuICAgICAgICAgICAgaWYoKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSArIDEpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgMSkpIHx8XHJcbiAgICAgICAgICAgICAgIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkgLSAxKSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSAtIDEpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYoKGdyaWQuaXNXYWxrYWJsZUF0KHggKyAxLCB5ICsgZHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSkpIHx8XHJcbiAgICAgICAgICAgICAgIChncmlkLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSArIGR5KSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fanVtcCh4ICsgZHgsIHkgKyBkeSwgeCwgeSk7XHJcbn07XHJcblxyXG4vKipcclxuICogRmluZCB0aGUgbmVpZ2hib3JzIGZvciB0aGUgZ2l2ZW4gbm9kZS4gSWYgdGhlIG5vZGUgaGFzIGEgcGFyZW50LFxyXG4gKiBwcnVuZSB0aGUgbmVpZ2hib3JzIGJhc2VkIG9uIHRoZSBqdW1wIHBvaW50IHNlYXJjaCBhbGdvcml0aG0sIG90aGVyd2lzZVxyXG4gKiByZXR1cm4gYWxsIGF2YWlsYWJsZSBuZWlnaGJvcnMuXHJcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBUaGUgbmVpZ2hib3JzIGZvdW5kLlxyXG4gKi9cclxuSlBGQWx3YXlzTW92ZURpYWdvbmFsbHkucHJvdG90eXBlLl9maW5kTmVpZ2hib3JzID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50LFxyXG4gICAgICAgIHggPSBub2RlLngsIHkgPSBub2RlLnksXHJcbiAgICAgICAgZ3JpZCA9IHRoaXMuZ3JpZCxcclxuICAgICAgICBweCwgcHksIG54LCBueSwgZHgsIGR5LFxyXG4gICAgICAgIG5laWdoYm9ycyA9IFtdLCBuZWlnaGJvck5vZGVzLCBuZWlnaGJvck5vZGUsIGksIGw7XHJcblxyXG4gICAgLy8gZGlyZWN0ZWQgcHJ1bmluZzogY2FuIGlnbm9yZSBtb3N0IG5laWdoYm9ycywgdW5sZXNzIGZvcmNlZC5cclxuICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBweCA9IHBhcmVudC54O1xyXG4gICAgICAgIHB5ID0gcGFyZW50Lnk7XHJcbiAgICAgICAgLy8gZ2V0IHRoZSBub3JtYWxpemVkIGRpcmVjdGlvbiBvZiB0cmF2ZWxcclxuICAgICAgICBkeCA9ICh4IC0gcHgpIC8gTWF0aC5tYXgoTWF0aC5hYnMoeCAtIHB4KSwgMSk7XHJcbiAgICAgICAgZHkgPSAoeSAtIHB5KSAvIE1hdGgubWF4KE1hdGguYWJzKHkgLSBweSksIDEpO1xyXG5cclxuICAgICAgICAvLyBzZWFyY2ggZGlhZ29uYWxseVxyXG4gICAgICAgIGlmIChkeCAhPT0gMCAmJiBkeSAhPT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIGR5KSkge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgKyBkeV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkpKSB7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSArIGR5KSkge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSArIGR5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4IC0gZHgsIHkpKSB7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCAtIGR4LCB5ICsgZHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSBkeSkpIHtcclxuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHkgLSBkeV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNlYXJjaCBob3Jpem9udGFsbHkvdmVydGljYWxseVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZihkeCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSArIGR5XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHggKyAxLCB5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgMSwgeSArIGR5XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4IC0gMSwgeSArIGR5XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSArIDFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSAtIDFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHJldHVybiBhbGwgbmVpZ2hib3JzXHJcbiAgICBlbHNlIHtcclxuICAgICAgICBuZWlnaGJvck5vZGVzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgRGlhZ29uYWxNb3ZlbWVudC5BbHdheXMpO1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZWlnaGJvck5vZGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xyXG4gICAgICAgICAgICBuZWlnaGJvck5vZGUgPSBuZWlnaGJvck5vZGVzW2ldO1xyXG4gICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbbmVpZ2hib3JOb2RlLngsIG5laWdoYm9yTm9kZS55XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZWlnaGJvcnM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEpQRkFsd2F5c01vdmVEaWFnb25hbGx5O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = __webpack_require__(/*! ./JumpPointFinderBase */ \"./node_modules/pathfinding/src/finders/JumpPointFinderBase.js\");\r\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./node_modules/pathfinding/src/core/DiagonalMovement.js\");\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there is at most one obstacle.\r\n */\r\nfunction JPFMoveDiagonallyIfAtMostOneObstacle(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (!grid.isWalkableAt(x + 1, y)) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x - 1, y)) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (!grid.isWalkableAt(x, y + 1)) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x, y - 1)) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvSlBGTW92ZURpYWdvbmFsbHlJZkF0TW9zdE9uZU9ic3RhY2xlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLDRGQUF1QjtBQUN6RCx1QkFBdUIsbUJBQU8sQ0FBQyx5RkFBMEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmFjb25tYW4vLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvSlBGTW92ZURpYWdvbmFsbHlJZkF0TW9zdE9uZU9ic3RhY2xlLmpzP2VmNDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBhdXRob3IgaW1vciAvIGh0dHBzOi8vZ2l0aHViLmNvbS9pbW9yXHJcbiAqL1xyXG52YXIgSnVtcFBvaW50RmluZGVyQmFzZSA9IHJlcXVpcmUoJy4vSnVtcFBvaW50RmluZGVyQmFzZScpO1xyXG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IHJlcXVpcmUoJy4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudCcpO1xyXG5cclxuLyoqXHJcbiAqIFBhdGggZmluZGVyIHVzaW5nIHRoZSBKdW1wIFBvaW50IFNlYXJjaCBhbGdvcml0aG0gd2hpY2ggbW92ZXNcclxuICogZGlhZ29uYWxseSBvbmx5IHdoZW4gdGhlcmUgaXMgYXQgbW9zdCBvbmUgb2JzdGFjbGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBKUEZNb3ZlRGlhZ29uYWxseUlmQXRNb3N0T25lT2JzdGFjbGUob3B0KSB7XHJcbiAgICBKdW1wUG9pbnRGaW5kZXJCYXNlLmNhbGwodGhpcywgb3B0KTtcclxufVxyXG5cclxuSlBGTW92ZURpYWdvbmFsbHlJZkF0TW9zdE9uZU9ic3RhY2xlLnByb3RvdHlwZSA9IG5ldyBKdW1wUG9pbnRGaW5kZXJCYXNlKCk7XHJcbkpQRk1vdmVEaWFnb25hbGx5SWZBdE1vc3RPbmVPYnN0YWNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBKUEZNb3ZlRGlhZ29uYWxseUlmQXRNb3N0T25lT2JzdGFjbGU7XHJcblxyXG4vKipcclxuICogU2VhcmNoIHJlY3Vyc2l2ZWx5IGluIHRoZSBkaXJlY3Rpb24gKHBhcmVudCAtPiBjaGlsZCksIHN0b3BwaW5nIG9ubHkgd2hlbiBhXHJcbiAqIGp1bXAgcG9pbnQgaXMgZm91bmQuXHJcbiAqIEBwcm90ZWN0ZWRcclxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFRoZSB4LCB5IGNvb3JkaW5hdGUgb2YgdGhlIGp1bXAgcG9pbnRcclxuICogICAgIGZvdW5kLCBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gKi9cclxuSlBGTW92ZURpYWdvbmFsbHlJZkF0TW9zdE9uZU9ic3RhY2xlLnByb3RvdHlwZS5fanVtcCA9IGZ1bmN0aW9uKHgsIHksIHB4LCBweSkge1xyXG4gICAgdmFyIGdyaWQgPSB0aGlzLmdyaWQsXHJcbiAgICAgICAgZHggPSB4IC0gcHgsIGR5ID0geSAtIHB5O1xyXG5cclxuICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSkpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZih0aGlzLnRyYWNrSnVtcFJlY3Vyc2lvbiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIGdyaWQuZ2V0Tm9kZUF0KHgsIHkpLnRlc3RlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGdyaWQuZ2V0Tm9kZUF0KHgsIHkpID09PSB0aGlzLmVuZE5vZGUpIHtcclxuICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNoZWNrIGZvciBmb3JjZWQgbmVpZ2hib3JzXHJcbiAgICAvLyBhbG9uZyB0aGUgZGlhZ29uYWxcclxuICAgIGlmIChkeCAhPT0gMCAmJiBkeSAhPT0gMCkge1xyXG4gICAgICAgIGlmICgoZ3JpZC5pc1dhbGthYmxlQXQoeCAtIGR4LCB5ICsgZHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4IC0gZHgsIHkpKSB8fFxyXG4gICAgICAgICAgICAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5IC0gZHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gZHkpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3aGVuIG1vdmluZyBkaWFnb25hbGx5LCBtdXN0IGNoZWNrIGZvciB2ZXJ0aWNhbC9ob3Jpem9udGFsIGp1bXAgcG9pbnRzXHJcbiAgICAgICAgaWYgKHRoaXMuX2p1bXAoeCArIGR4LCB5LCB4LCB5KSB8fCB0aGlzLl9qdW1wKHgsIHkgKyBkeSwgeCwgeSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBob3Jpem9udGFsbHkvdmVydGljYWxseVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYoIGR4ICE9PSAwICkgeyAvLyBtb3ZpbmcgYWxvbmcgeFxyXG4gICAgICAgICAgICBpZigoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5ICsgMSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyAxKSkgfHxcclxuICAgICAgICAgICAgICAgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSAtIDEpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gMSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZigoZ3JpZC5pc1dhbGthYmxlQXQoeCArIDEsIHkgKyBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggKyAxLCB5KSkgfHxcclxuICAgICAgICAgICAgICAgKGdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5ICsgZHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIG1vdmluZyBkaWFnb25hbGx5LCBtdXN0IG1ha2Ugc3VyZSBvbmUgb2YgdGhlIHZlcnRpY2FsL2hvcml6b250YWxcclxuICAgIC8vIG5laWdoYm9ycyBpcyBvcGVuIHRvIGFsbG93IHRoZSBwYXRoXHJcbiAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KSB8fCBncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgZHkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p1bXAoeCArIGR4LCB5ICsgZHksIHgsIHkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBGaW5kIHRoZSBuZWlnaGJvcnMgZm9yIHRoZSBnaXZlbiBub2RlLiBJZiB0aGUgbm9kZSBoYXMgYSBwYXJlbnQsXHJcbiAqIHBydW5lIHRoZSBuZWlnaGJvcnMgYmFzZWQgb24gdGhlIGp1bXAgcG9pbnQgc2VhcmNoIGFsZ29yaXRobSwgb3RoZXJ3aXNlXHJcbiAqIHJldHVybiBhbGwgYXZhaWxhYmxlIG5laWdoYm9ycy5cclxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFRoZSBuZWlnaGJvcnMgZm91bmQuXHJcbiAqL1xyXG5KUEZNb3ZlRGlhZ29uYWxseUlmQXRNb3N0T25lT2JzdGFjbGUucHJvdG90eXBlLl9maW5kTmVpZ2hib3JzID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50LFxyXG4gICAgICAgIHggPSBub2RlLngsIHkgPSBub2RlLnksXHJcbiAgICAgICAgZ3JpZCA9IHRoaXMuZ3JpZCxcclxuICAgICAgICBweCwgcHksIG54LCBueSwgZHgsIGR5LFxyXG4gICAgICAgIG5laWdoYm9ycyA9IFtdLCBuZWlnaGJvck5vZGVzLCBuZWlnaGJvck5vZGUsIGksIGw7XHJcblxyXG4gICAgLy8gZGlyZWN0ZWQgcHJ1bmluZzogY2FuIGlnbm9yZSBtb3N0IG5laWdoYm9ycywgdW5sZXNzIGZvcmNlZC5cclxuICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBweCA9IHBhcmVudC54O1xyXG4gICAgICAgIHB5ID0gcGFyZW50Lnk7XHJcbiAgICAgICAgLy8gZ2V0IHRoZSBub3JtYWxpemVkIGRpcmVjdGlvbiBvZiB0cmF2ZWxcclxuICAgICAgICBkeCA9ICh4IC0gcHgpIC8gTWF0aC5tYXgoTWF0aC5hYnMoeCAtIHB4KSwgMSk7XHJcbiAgICAgICAgZHkgPSAoeSAtIHB5KSAvIE1hdGgubWF4KE1hdGguYWJzKHkgLSBweSksIDEpO1xyXG5cclxuICAgICAgICAvLyBzZWFyY2ggZGlhZ29uYWxseVxyXG4gICAgICAgIGlmIChkeCAhPT0gMCAmJiBkeSAhPT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIGR5KSkge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgKyBkeV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkpKSB7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSkgfHwgZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KSkge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSArIGR5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4IC0gZHgsIHkpICYmIGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSkpIHtcclxuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4IC0gZHgsIHkgKyBkeV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSAtIGR5KSAmJiBncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkpKSB7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5IC0gZHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZWFyY2ggaG9yaXpvbnRhbGx5L3ZlcnRpY2FsbHlcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYoZHggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgZHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgKyBkeV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQoeCArIDEsIHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgMSwgeSArIGR5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4IC0gMSwgeSArIGR5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSArIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSAtIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyByZXR1cm4gYWxsIG5laWdoYm9yc1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbmVpZ2hib3JOb2RlcyA9IGdyaWQuZ2V0TmVpZ2hib3JzKG5vZGUsIERpYWdvbmFsTW92ZW1lbnQuSWZBdE1vc3RPbmVPYnN0YWNsZSk7XHJcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5laWdoYm9yTm9kZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XHJcbiAgICAgICAgICAgIG5laWdoYm9yTm9kZSA9IG5laWdoYm9yTm9kZXNbaV07XHJcbiAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFtuZWlnaGJvck5vZGUueCwgbmVpZ2hib3JOb2RlLnldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5laWdoYm9ycztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSlBGTW92ZURpYWdvbmFsbHlJZkF0TW9zdE9uZU9ic3RhY2xlO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js":
/*!********************************************************************************!*\
  !*** ./node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = __webpack_require__(/*! ./JumpPointFinderBase */ \"./node_modules/pathfinding/src/finders/JumpPointFinderBase.js\");\r\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./node_modules/pathfinding/src/core/DiagonalMovement.js\");\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there are no obstacles.\r\n */\r\nfunction JPFMoveDiagonallyIfNoObstacles(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            // return [x, y];\r\n        // }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if (dx !== 0) {\r\n            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n                return [x, y];\r\n            }\r\n            // When moving vertically, must check for horizontal jump points\r\n            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n                // return [x, y];\r\n            // }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            var isNextWalkable;\r\n            if (dx !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x + dx, y);\r\n                var isTopWalkable = grid.isWalkableAt(x, y + 1);\r\n                var isBottomWalkable = grid.isWalkableAt(x, y - 1);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (isTopWalkable) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (isBottomWalkable) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n                if (isTopWalkable) {\r\n                    neighbors.push([x, y + 1]);\r\n                }\r\n                if (isBottomWalkable) {\r\n                    neighbors.push([x, y - 1]);\r\n                }\r\n            }\r\n            else if (dy !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x, y + dy);\r\n                var isRightWalkable = grid.isWalkableAt(x + 1, y);\r\n                var isLeftWalkable = grid.isWalkableAt(x - 1, y);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (isRightWalkable) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (isLeftWalkable) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n                if (isRightWalkable) {\r\n                    neighbors.push([x + 1, y]);\r\n                }\r\n                if (isLeftWalkable) {\r\n                    neighbors.push([x - 1, y]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfNoObstacles;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvSlBGTW92ZURpYWdvbmFsbHlJZk5vT2JzdGFjbGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLDRGQUF1QjtBQUN6RCx1QkFBdUIsbUJBQU8sQ0FBQyx5RkFBMEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmFjb25tYW4vLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvSlBGTW92ZURpYWdvbmFsbHlJZk5vT2JzdGFjbGVzLmpzPzAwMjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBhdXRob3IgaW1vciAvIGh0dHBzOi8vZ2l0aHViLmNvbS9pbW9yXHJcbiAqL1xyXG52YXIgSnVtcFBvaW50RmluZGVyQmFzZSA9IHJlcXVpcmUoJy4vSnVtcFBvaW50RmluZGVyQmFzZScpO1xyXG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IHJlcXVpcmUoJy4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudCcpO1xyXG5cclxuLyoqXHJcbiAqIFBhdGggZmluZGVyIHVzaW5nIHRoZSBKdW1wIFBvaW50IFNlYXJjaCBhbGdvcml0aG0gd2hpY2ggbW92ZXNcclxuICogZGlhZ29uYWxseSBvbmx5IHdoZW4gdGhlcmUgYXJlIG5vIG9ic3RhY2xlcy5cclxuICovXHJcbmZ1bmN0aW9uIEpQRk1vdmVEaWFnb25hbGx5SWZOb09ic3RhY2xlcyhvcHQpIHtcclxuICAgIEp1bXBQb2ludEZpbmRlckJhc2UuY2FsbCh0aGlzLCBvcHQpO1xyXG59XHJcblxyXG5KUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXMucHJvdG90eXBlID0gbmV3IEp1bXBQb2ludEZpbmRlckJhc2UoKTtcclxuSlBGTW92ZURpYWdvbmFsbHlJZk5vT2JzdGFjbGVzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEpQRk1vdmVEaWFnb25hbGx5SWZOb09ic3RhY2xlcztcclxuXHJcbi8qKlxyXG4gKiBTZWFyY2ggcmVjdXJzaXZlbHkgaW4gdGhlIGRpcmVjdGlvbiAocGFyZW50IC0+IGNoaWxkKSwgc3RvcHBpbmcgb25seSB3aGVuIGFcclxuICoganVtcCBwb2ludCBpcyBmb3VuZC5cclxuICogQHByb3RlY3RlZFxyXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gVGhlIHgsIHkgY29vcmRpbmF0ZSBvZiB0aGUganVtcCBwb2ludFxyXG4gKiAgICAgZm91bmQsIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAqL1xyXG5KUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXMucHJvdG90eXBlLl9qdW1wID0gZnVuY3Rpb24oeCwgeSwgcHgsIHB5KSB7XHJcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcclxuICAgICAgICBkeCA9IHggLSBweCwgZHkgPSB5IC0gcHk7XHJcblxyXG4gICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5KSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMudHJhY2tKdW1wUmVjdXJzaW9uID09PSB0cnVlKSB7XHJcbiAgICAgICAgZ3JpZC5nZXROb2RlQXQoeCwgeSkudGVzdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZ3JpZC5nZXROb2RlQXQoeCwgeSkgPT09IHRoaXMuZW5kTm9kZSkge1xyXG4gICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2hlY2sgZm9yIGZvcmNlZCBuZWlnaGJvcnNcclxuICAgIC8vIGFsb25nIHRoZSBkaWFnb25hbFxyXG4gICAgaWYgKGR4ICE9PSAwICYmIGR5ICE9PSAwKSB7XHJcbiAgICAgICAgLy8gaWYgKChncmlkLmlzV2Fsa2FibGVBdCh4IC0gZHgsIHkgKyBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSkpIHx8XHJcbiAgICAgICAgICAgIC8vIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkgLSBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSBkeSkpKSB7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiBbeCwgeV07XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIHdoZW4gbW92aW5nIGRpYWdvbmFsbHksIG11c3QgY2hlY2sgZm9yIHZlcnRpY2FsL2hvcml6b250YWwganVtcCBwb2ludHNcclxuICAgICAgICBpZiAodGhpcy5fanVtcCh4ICsgZHgsIHksIHgsIHkpIHx8IHRoaXMuX2p1bXAoeCwgeSArIGR5LCB4LCB5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGhvcml6b250YWxseS92ZXJ0aWNhbGx5XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoZHggIT09IDApIHtcclxuICAgICAgICAgICAgaWYgKChncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gMSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSAtIDEpKSB8fFxyXG4gICAgICAgICAgICAgICAgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyAxKSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCAtIGR4LCB5ICsgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGR5ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGlmICgoZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSAtIGR5KSkgfHxcclxuICAgICAgICAgICAgICAgIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggKyAxLCB5IC0gZHkpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBXaGVuIG1vdmluZyB2ZXJ0aWNhbGx5LCBtdXN0IGNoZWNrIGZvciBob3Jpem9udGFsIGp1bXAgcG9pbnRzXHJcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLl9qdW1wKHggKyAxLCB5LCB4LCB5KSB8fCB0aGlzLl9qdW1wKHggLSAxLCB5LCB4LCB5KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIFt4LCB5XTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBtb3ZpbmcgZGlhZ29uYWxseSwgbXVzdCBtYWtlIHN1cmUgb25lIG9mIHRoZSB2ZXJ0aWNhbC9ob3Jpem9udGFsXHJcbiAgICAvLyBuZWlnaGJvcnMgaXMgb3BlbiB0byBhbGxvdyB0aGUgcGF0aFxyXG4gICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkgJiYgZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIGR5KSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9qdW1wKHggKyBkeCwgeSArIGR5LCB4LCB5KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRmluZCB0aGUgbmVpZ2hib3JzIGZvciB0aGUgZ2l2ZW4gbm9kZS4gSWYgdGhlIG5vZGUgaGFzIGEgcGFyZW50LFxyXG4gKiBwcnVuZSB0aGUgbmVpZ2hib3JzIGJhc2VkIG9uIHRoZSBqdW1wIHBvaW50IHNlYXJjaCBhbGdvcml0aG0sIG90aGVyd2lzZVxyXG4gKiByZXR1cm4gYWxsIGF2YWlsYWJsZSBuZWlnaGJvcnMuXHJcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBUaGUgbmVpZ2hib3JzIGZvdW5kLlxyXG4gKi9cclxuSlBGTW92ZURpYWdvbmFsbHlJZk5vT2JzdGFjbGVzLnByb3RvdHlwZS5fZmluZE5laWdoYm9ycyA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudCxcclxuICAgICAgICB4ID0gbm9kZS54LCB5ID0gbm9kZS55LFxyXG4gICAgICAgIGdyaWQgPSB0aGlzLmdyaWQsXHJcbiAgICAgICAgcHgsIHB5LCBueCwgbnksIGR4LCBkeSxcclxuICAgICAgICBuZWlnaGJvcnMgPSBbXSwgbmVpZ2hib3JOb2RlcywgbmVpZ2hib3JOb2RlLCBpLCBsO1xyXG5cclxuICAgIC8vIGRpcmVjdGVkIHBydW5pbmc6IGNhbiBpZ25vcmUgbW9zdCBuZWlnaGJvcnMsIHVubGVzcyBmb3JjZWQuXHJcbiAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgcHggPSBwYXJlbnQueDtcclxuICAgICAgICBweSA9IHBhcmVudC55O1xyXG4gICAgICAgIC8vIGdldCB0aGUgbm9ybWFsaXplZCBkaXJlY3Rpb24gb2YgdHJhdmVsXHJcbiAgICAgICAgZHggPSAoeCAtIHB4KSAvIE1hdGgubWF4KE1hdGguYWJzKHggLSBweCksIDEpO1xyXG4gICAgICAgIGR5ID0gKHkgLSBweSkgLyBNYXRoLm1heChNYXRoLmFicyh5IC0gcHkpLCAxKTtcclxuXHJcbiAgICAgICAgLy8gc2VhcmNoIGRpYWdvbmFsbHlcclxuICAgICAgICBpZiAoZHggIT09IDAgJiYgZHkgIT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSkpIHtcclxuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4LCB5ICsgZHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KSkge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgZHkpICYmIGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkpIHtcclxuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHkgKyBkeV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNlYXJjaCBob3Jpem9udGFsbHkvdmVydGljYWxseVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaXNOZXh0V2Fsa2FibGU7XHJcbiAgICAgICAgICAgIGlmIChkeCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaXNOZXh0V2Fsa2FibGUgPSBncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzVG9wV2Fsa2FibGUgPSBncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgMSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNCb3R0b21XYWxrYWJsZSA9IGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOZXh0V2Fsa2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVG9wV2Fsa2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSArIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQm90dG9tV2Fsa2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSAtIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUb3BXYWxrYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4LCB5ICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQm90dG9tV2Fsa2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSAtIDFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkeSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaXNOZXh0V2Fsa2FibGUgPSBncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgZHkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzUmlnaHRXYWxrYWJsZSA9IGdyaWQuaXNXYWxrYWJsZUF0KHggKyAxLCB5KTtcclxuICAgICAgICAgICAgICAgIHZhciBpc0xlZnRXYWxrYWJsZSA9IGdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOZXh0V2Fsa2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSArIGR5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmlnaHRXYWxrYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIDEsIHkgKyBkeV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0V2Fsa2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggLSAxLCB5ICsgZHldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSaWdodFdhbGthYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyAxLCB5XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0V2Fsa2FibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCAtIDEsIHldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHJldHVybiBhbGwgbmVpZ2hib3JzXHJcbiAgICBlbHNlIHtcclxuICAgICAgICBuZWlnaGJvck5vZGVzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgRGlhZ29uYWxNb3ZlbWVudC5Pbmx5V2hlbk5vT2JzdGFjbGVzKTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JOb2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3JOb2RlID0gbmVpZ2hib3JOb2Rlc1tpXTtcclxuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW25laWdoYm9yTm9kZS54LCBuZWlnaGJvck5vZGUueV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmVpZ2hib3JzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXM7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js":
/*!************************************************************************!*\
  !*** ./node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = __webpack_require__(/*! ./JumpPointFinderBase */ \"./node_modules/pathfinding/src/finders/JumpPointFinderBase.js\");\r\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./node_modules/pathfinding/src/core/DiagonalMovement.js\");\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm allowing only horizontal\r\n * or vertical movements.\r\n */\r\nfunction JPFNeverMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    if (dx !== 0) {\r\n        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else if (dy !== 0) {\r\n        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        //When moving vertically, must check for horizontal jump points\r\n        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(\"Only horizontal and vertical movements are allowed\");\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        if (dx !== 0) {\r\n            if (grid.isWalkableAt(x, y - 1)) {\r\n                neighbors.push([x, y - 1]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + 1)) {\r\n                neighbors.push([x, y + 1]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if (grid.isWalkableAt(x - 1, y)) {\r\n                neighbors.push([x - 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + 1, y)) {\r\n                neighbors.push([x + 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFNeverMoveDiagonally;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvSlBGTmV2ZXJNb3ZlRGlhZ29uYWxseS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyw0RkFBdUI7QUFDekQsdUJBQXVCLG1CQUFPLENBQUMseUZBQTBCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYWNvbm1hbi8uL25vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9KUEZOZXZlck1vdmVEaWFnb25hbGx5LmpzP2I2MzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBhdXRob3IgaW1vciAvIGh0dHBzOi8vZ2l0aHViLmNvbS9pbW9yXHJcbiAqL1xyXG52YXIgSnVtcFBvaW50RmluZGVyQmFzZSA9IHJlcXVpcmUoJy4vSnVtcFBvaW50RmluZGVyQmFzZScpO1xyXG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IHJlcXVpcmUoJy4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudCcpO1xyXG5cclxuLyoqXHJcbiAqIFBhdGggZmluZGVyIHVzaW5nIHRoZSBKdW1wIFBvaW50IFNlYXJjaCBhbGdvcml0aG0gYWxsb3dpbmcgb25seSBob3Jpem9udGFsXHJcbiAqIG9yIHZlcnRpY2FsIG1vdmVtZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIEpQRk5ldmVyTW92ZURpYWdvbmFsbHkob3B0KSB7XHJcbiAgICBKdW1wUG9pbnRGaW5kZXJCYXNlLmNhbGwodGhpcywgb3B0KTtcclxufVxyXG5cclxuSlBGTmV2ZXJNb3ZlRGlhZ29uYWxseS5wcm90b3R5cGUgPSBuZXcgSnVtcFBvaW50RmluZGVyQmFzZSgpO1xyXG5KUEZOZXZlck1vdmVEaWFnb25hbGx5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEpQRk5ldmVyTW92ZURpYWdvbmFsbHk7XHJcblxyXG4vKipcclxuICogU2VhcmNoIHJlY3Vyc2l2ZWx5IGluIHRoZSBkaXJlY3Rpb24gKHBhcmVudCAtPiBjaGlsZCksIHN0b3BwaW5nIG9ubHkgd2hlbiBhXHJcbiAqIGp1bXAgcG9pbnQgaXMgZm91bmQuXHJcbiAqIEBwcm90ZWN0ZWRcclxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IFRoZSB4LCB5IGNvb3JkaW5hdGUgb2YgdGhlIGp1bXAgcG9pbnRcclxuICogICAgIGZvdW5kLCBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gKi9cclxuSlBGTmV2ZXJNb3ZlRGlhZ29uYWxseS5wcm90b3R5cGUuX2p1bXAgPSBmdW5jdGlvbih4LCB5LCBweCwgcHkpIHtcclxuICAgIHZhciBncmlkID0gdGhpcy5ncmlkLFxyXG4gICAgICAgIGR4ID0geCAtIHB4LCBkeSA9IHkgLSBweTtcclxuXHJcbiAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkpKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy50cmFja0p1bXBSZWN1cnNpb24gPT09IHRydWUpIHtcclxuICAgICAgICBncmlkLmdldE5vZGVBdCh4LCB5KS50ZXN0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChncmlkLmdldE5vZGVBdCh4LCB5KSA9PT0gdGhpcy5lbmROb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZHggIT09IDApIHtcclxuICAgICAgICBpZiAoKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSAxKSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCAtIGR4LCB5IC0gMSkpIHx8XHJcbiAgICAgICAgICAgIChncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgMSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSArIDEpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGR5ICE9PSAwKSB7XHJcbiAgICAgICAgaWYgKChncmlkLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5IC0gZHkpKSB8fFxyXG4gICAgICAgICAgICAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIDEsIHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSAtIGR5KSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9XaGVuIG1vdmluZyB2ZXJ0aWNhbGx5LCBtdXN0IGNoZWNrIGZvciBob3Jpem9udGFsIGp1bXAgcG9pbnRzXHJcbiAgICAgICAgaWYgKHRoaXMuX2p1bXAoeCArIDEsIHksIHgsIHkpIHx8IHRoaXMuX2p1bXAoeCAtIDEsIHksIHgsIHkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBtb3ZlbWVudHMgYXJlIGFsbG93ZWRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2p1bXAoeCArIGR4LCB5ICsgZHksIHgsIHkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZpbmQgdGhlIG5laWdoYm9ycyBmb3IgdGhlIGdpdmVuIG5vZGUuIElmIHRoZSBub2RlIGhhcyBhIHBhcmVudCxcclxuICogcHJ1bmUgdGhlIG5laWdoYm9ycyBiYXNlZCBvbiB0aGUganVtcCBwb2ludCBzZWFyY2ggYWxnb3JpdGhtLCBvdGhlcndpc2VcclxuICogcmV0dXJuIGFsbCBhdmFpbGFibGUgbmVpZ2hib3JzLlxyXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gVGhlIG5laWdoYm9ycyBmb3VuZC5cclxuICovXHJcbkpQRk5ldmVyTW92ZURpYWdvbmFsbHkucHJvdG90eXBlLl9maW5kTmVpZ2hib3JzID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50LFxyXG4gICAgICAgIHggPSBub2RlLngsIHkgPSBub2RlLnksXHJcbiAgICAgICAgZ3JpZCA9IHRoaXMuZ3JpZCxcclxuICAgICAgICBweCwgcHksIG54LCBueSwgZHgsIGR5LFxyXG4gICAgICAgIG5laWdoYm9ycyA9IFtdLCBuZWlnaGJvck5vZGVzLCBuZWlnaGJvck5vZGUsIGksIGw7XHJcblxyXG4gICAgLy8gZGlyZWN0ZWQgcHJ1bmluZzogY2FuIGlnbm9yZSBtb3N0IG5laWdoYm9ycywgdW5sZXNzIGZvcmNlZC5cclxuICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBweCA9IHBhcmVudC54O1xyXG4gICAgICAgIHB5ID0gcGFyZW50Lnk7XHJcbiAgICAgICAgLy8gZ2V0IHRoZSBub3JtYWxpemVkIGRpcmVjdGlvbiBvZiB0cmF2ZWxcclxuICAgICAgICBkeCA9ICh4IC0gcHgpIC8gTWF0aC5tYXgoTWF0aC5hYnMoeCAtIHB4KSwgMSk7XHJcbiAgICAgICAgZHkgPSAoeSAtIHB5KSAvIE1hdGgubWF4KE1hdGguYWJzKHkgLSBweSksIDEpO1xyXG5cclxuICAgICAgICBpZiAoZHggIT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSAxKSkge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgLSAxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyAxKSkge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgKyAxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkpIHtcclxuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkeSAhPT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkpKSB7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCAtIDEsIHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIDEsIHkpKSB7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIDEsIHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIGR5KSkge1xyXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgKyBkeV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gcmV0dXJuIGFsbCBuZWlnaGJvcnNcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG5laWdoYm9yTm9kZXMgPSBncmlkLmdldE5laWdoYm9ycyhub2RlLCBEaWFnb25hbE1vdmVtZW50Lk5ldmVyKTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JOb2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgICAgbmVpZ2hib3JOb2RlID0gbmVpZ2hib3JOb2Rlc1tpXTtcclxuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW25laWdoYm9yTm9kZS54LCBuZWlnaGJvck5vZGUueV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmVpZ2hib3JzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKUEZOZXZlck1vdmVEaWFnb25hbGx5O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/finders/JumpPointFinder.js":
/*!*****************************************************************!*\
  !*** ./node_modules/pathfinding/src/finders/JumpPointFinder.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{/**\r\n * @author aniero / https://github.com/aniero\r\n */\r\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./node_modules/pathfinding/src/core/DiagonalMovement.js\");\r\nvar JPFNeverMoveDiagonally = __webpack_require__(/*! ./JPFNeverMoveDiagonally */ \"./node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js\");\r\nvar JPFAlwaysMoveDiagonally = __webpack_require__(/*! ./JPFAlwaysMoveDiagonally */ \"./node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js\");\r\nvar JPFMoveDiagonallyIfNoObstacles = __webpack_require__(/*! ./JPFMoveDiagonallyIfNoObstacles */ \"./node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js\");\r\nvar JPFMoveDiagonallyIfAtMostOneObstacle = __webpack_require__(/*! ./JPFMoveDiagonallyIfAtMostOneObstacle */ \"./node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js\");\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm\r\n * @param {Object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal\r\n *      movement will be allowed.\r\n */\r\nfunction JumpPointFinder(opt) {\r\n    opt = opt || {};\r\n    if (opt.diagonalMovement === DiagonalMovement.Never) {\r\n        return new JPFNeverMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.Always) {\r\n        return new JPFAlwaysMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        return new JPFMoveDiagonallyIfNoObstacles(opt);\r\n    } else {\r\n        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);\r\n    }\r\n}\r\n\r\nmodule.exports = JumpPointFinder;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvSnVtcFBvaW50RmluZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLHlGQUEwQjtBQUN6RCw2QkFBNkIsbUJBQU8sQ0FBQyxrR0FBMEI7QUFDL0QsOEJBQThCLG1CQUFPLENBQUMsb0dBQTJCO0FBQ2pFLHFDQUFxQyxtQkFBTyxDQUFDLGtIQUFrQztBQUMvRSwyQ0FBMkMsbUJBQU8sQ0FBQyw4SEFBd0M7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYWNvbm1hbi8uL25vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9KdW1wUG9pbnRGaW5kZXIuanM/NGM2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGF1dGhvciBhbmllcm8gLyBodHRwczovL2dpdGh1Yi5jb20vYW5pZXJvXHJcbiAqL1xyXG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IHJlcXVpcmUoJy4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudCcpO1xyXG52YXIgSlBGTmV2ZXJNb3ZlRGlhZ29uYWxseSA9IHJlcXVpcmUoJy4vSlBGTmV2ZXJNb3ZlRGlhZ29uYWxseScpO1xyXG52YXIgSlBGQWx3YXlzTW92ZURpYWdvbmFsbHkgPSByZXF1aXJlKCcuL0pQRkFsd2F5c01vdmVEaWFnb25hbGx5Jyk7XHJcbnZhciBKUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXMgPSByZXF1aXJlKCcuL0pQRk1vdmVEaWFnb25hbGx5SWZOb09ic3RhY2xlcycpO1xyXG52YXIgSlBGTW92ZURpYWdvbmFsbHlJZkF0TW9zdE9uZU9ic3RhY2xlID0gcmVxdWlyZSgnLi9KUEZNb3ZlRGlhZ29uYWxseUlmQXRNb3N0T25lT2JzdGFjbGUnKTtcclxuXHJcbi8qKlxyXG4gKiBQYXRoIGZpbmRlciB1c2luZyB0aGUgSnVtcCBQb2ludCBTZWFyY2ggYWxnb3JpdGhtXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LmhldXJpc3RpYyBIZXVyaXN0aWMgZnVuY3Rpb24gdG8gZXN0aW1hdGUgdGhlIGRpc3RhbmNlXHJcbiAqICAgICAoZGVmYXVsdHMgdG8gbWFuaGF0dGFuKS5cclxuICogQHBhcmFtIHtEaWFnb25hbE1vdmVtZW50fSBvcHQuZGlhZ29uYWxNb3ZlbWVudCBDb25kaXRpb24gdW5kZXIgd2hpY2ggZGlhZ29uYWxcclxuICogICAgICBtb3ZlbWVudCB3aWxsIGJlIGFsbG93ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBKdW1wUG9pbnRGaW5kZXIob3B0KSB7XHJcbiAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICBpZiAob3B0LmRpYWdvbmFsTW92ZW1lbnQgPT09IERpYWdvbmFsTW92ZW1lbnQuTmV2ZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEpQRk5ldmVyTW92ZURpYWdvbmFsbHkob3B0KTtcclxuICAgIH0gZWxzZSBpZiAob3B0LmRpYWdvbmFsTW92ZW1lbnQgPT09IERpYWdvbmFsTW92ZW1lbnQuQWx3YXlzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBKUEZBbHdheXNNb3ZlRGlhZ29uYWxseShvcHQpO1xyXG4gICAgfSBlbHNlIGlmIChvcHQuZGlhZ29uYWxNb3ZlbWVudCA9PT0gRGlhZ29uYWxNb3ZlbWVudC5Pbmx5V2hlbk5vT2JzdGFjbGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBKUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXMob3B0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBKUEZNb3ZlRGlhZ29uYWxseUlmQXRNb3N0T25lT2JzdGFjbGUob3B0KTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKdW1wUG9pbnRGaW5kZXI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/finders/JumpPointFinder.js\n\n}");

/***/ }),

/***/ "./node_modules/pathfinding/src/finders/JumpPointFinderBase.js":
/*!*********************************************************************!*\
  !*** ./node_modules/pathfinding/src/finders/JumpPointFinderBase.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar Heap       = __webpack_require__(/*! heap */ \"./node_modules/heap/index.js\");\r\nvar Util       = __webpack_require__(/*! ../core/Util */ \"./node_modules/pathfinding/src/core/Util.js\");\r\nvar Heuristic  = __webpack_require__(/*! ../core/Heuristic */ \"./node_modules/pathfinding/src/core/Heuristic.js\");\r\nvar DiagonalMovement = __webpack_require__(/*! ../core/DiagonalMovement */ \"./node_modules/pathfinding/src/core/DiagonalMovement.js\");\r\n\r\n/**\r\n * Base class for the Jump Point Search algorithm\r\n * @param {object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction JumpPointFinderBase(opt) {\r\n    opt = opt || {};\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.trackJumpRecursion = opt.trackJumpRecursion || false;\r\n}\r\n\r\n/**\r\n * Find and return the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nJumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = this.openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = this.startNode = grid.getNodeAt(startX, startY),\r\n        endNode = this.endNode = grid.getNodeAt(endX, endY), node;\r\n\r\n    this.grid = grid;\r\n\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        if (node === endNode) {\r\n            return Util.expandPath(Util.backtrace(endNode));\r\n        }\r\n\r\n        this._identifySuccessors(node);\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\n/**\r\n * Identify successors for the given node. Runs a jump point search in the\r\n * direction of each available neighbor, adding any points found to the open\r\n * list.\r\n * @protected\r\n */\r\nJumpPointFinderBase.prototype._identifySuccessors = function(node) {\r\n    var grid = this.grid,\r\n        heuristic = this.heuristic,\r\n        openList = this.openList,\r\n        endX = this.endNode.x,\r\n        endY = this.endNode.y,\r\n        neighbors, neighbor,\r\n        jumpPoint, i, l,\r\n        x = node.x, y = node.y,\r\n        jx, jy, dx, dy, d, ng, jumpNode,\r\n        abs = Math.abs, max = Math.max;\r\n\r\n    neighbors = this._findNeighbors(node);\r\n    for(i = 0, l = neighbors.length; i < l; ++i) {\r\n        neighbor = neighbors[i];\r\n        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\r\n        if (jumpPoint) {\r\n\r\n            jx = jumpPoint[0];\r\n            jy = jumpPoint[1];\r\n            jumpNode = grid.getNodeAt(jx, jy);\r\n\r\n            if (jumpNode.closed) {\r\n                continue;\r\n            }\r\n\r\n            // include distance, as parent may not be immediately adjacent:\r\n            d = Heuristic.octile(abs(jx - x), abs(jy - y));\r\n            ng = node.g + d; // next `g` value\r\n\r\n            if (!jumpNode.opened || ng < jumpNode.g) {\r\n                jumpNode.g = ng;\r\n                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\r\n                jumpNode.f = jumpNode.g + jumpNode.h;\r\n                jumpNode.parent = node;\r\n\r\n                if (!jumpNode.opened) {\r\n                    openList.push(jumpNode);\r\n                    jumpNode.opened = true;\r\n                } else {\r\n                    openList.updateItem(jumpNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = JumpPointFinderBase;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvSnVtcFBvaW50RmluZGVyQmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQywwQ0FBTTtBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyxpRUFBYztBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQywyRUFBbUI7QUFDNUMsdUJBQXVCLG1CQUFPLENBQUMseUZBQTBCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhY29ubWFuLy4vbm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9maW5kZXJzL0p1bXBQb2ludEZpbmRlckJhc2UuanM/MzA0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGF1dGhvciBpbW9yIC8gaHR0cHM6Ly9naXRodWIuY29tL2ltb3JcclxuICovXHJcbnZhciBIZWFwICAgICAgID0gcmVxdWlyZSgnaGVhcCcpO1xyXG52YXIgVXRpbCAgICAgICA9IHJlcXVpcmUoJy4uL2NvcmUvVXRpbCcpO1xyXG52YXIgSGV1cmlzdGljICA9IHJlcXVpcmUoJy4uL2NvcmUvSGV1cmlzdGljJyk7XHJcbnZhciBEaWFnb25hbE1vdmVtZW50ID0gcmVxdWlyZSgnLi4vY29yZS9EaWFnb25hbE1vdmVtZW50Jyk7XHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgdGhlIEp1bXAgUG9pbnQgU2VhcmNoIGFsZ29yaXRobVxyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0XHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdC5oZXVyaXN0aWMgSGV1cmlzdGljIGZ1bmN0aW9uIHRvIGVzdGltYXRlIHRoZSBkaXN0YW5jZVxyXG4gKiAgICAgKGRlZmF1bHRzIHRvIG1hbmhhdHRhbikuXHJcbiAqL1xyXG5mdW5jdGlvbiBKdW1wUG9pbnRGaW5kZXJCYXNlKG9wdCkge1xyXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgdGhpcy5oZXVyaXN0aWMgPSBvcHQuaGV1cmlzdGljIHx8IEhldXJpc3RpYy5tYW5oYXR0YW47XHJcbiAgICB0aGlzLnRyYWNrSnVtcFJlY3Vyc2lvbiA9IG9wdC50cmFja0p1bXBSZWN1cnNpb24gfHwgZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaW5kIGFuZCByZXR1cm4gdGhlIHBhdGguXHJcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBUaGUgcGF0aCwgaW5jbHVkaW5nIGJvdGggc3RhcnQgYW5kXHJcbiAqICAgICBlbmQgcG9zaXRpb25zLlxyXG4gKi9cclxuSnVtcFBvaW50RmluZGVyQmFzZS5wcm90b3R5cGUuZmluZFBhdGggPSBmdW5jdGlvbihzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgZ3JpZCkge1xyXG4gICAgdmFyIG9wZW5MaXN0ID0gdGhpcy5vcGVuTGlzdCA9IG5ldyBIZWFwKGZ1bmN0aW9uKG5vZGVBLCBub2RlQikge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZUEuZiAtIG5vZGVCLmY7XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgc3RhcnROb2RlID0gdGhpcy5zdGFydE5vZGUgPSBncmlkLmdldE5vZGVBdChzdGFydFgsIHN0YXJ0WSksXHJcbiAgICAgICAgZW5kTm9kZSA9IHRoaXMuZW5kTm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KGVuZFgsIGVuZFkpLCBub2RlO1xyXG5cclxuICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XHJcblxyXG5cclxuICAgIC8vIHNldCB0aGUgYGdgIGFuZCBgZmAgdmFsdWUgb2YgdGhlIHN0YXJ0IG5vZGUgdG8gYmUgMFxyXG4gICAgc3RhcnROb2RlLmcgPSAwO1xyXG4gICAgc3RhcnROb2RlLmYgPSAwO1xyXG5cclxuICAgIC8vIHB1c2ggdGhlIHN0YXJ0IG5vZGUgaW50byB0aGUgb3BlbiBsaXN0XHJcbiAgICBvcGVuTGlzdC5wdXNoKHN0YXJ0Tm9kZSk7XHJcbiAgICBzdGFydE5vZGUub3BlbmVkID0gdHJ1ZTtcclxuXHJcbiAgICAvLyB3aGlsZSB0aGUgb3BlbiBsaXN0IGlzIG5vdCBlbXB0eVxyXG4gICAgd2hpbGUgKCFvcGVuTGlzdC5lbXB0eSgpKSB7XHJcbiAgICAgICAgLy8gcG9wIHRoZSBwb3NpdGlvbiBvZiBub2RlIHdoaWNoIGhhcyB0aGUgbWluaW11bSBgZmAgdmFsdWUuXHJcbiAgICAgICAgbm9kZSA9IG9wZW5MaXN0LnBvcCgpO1xyXG4gICAgICAgIG5vZGUuY2xvc2VkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKG5vZGUgPT09IGVuZE5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFV0aWwuZXhwYW5kUGF0aChVdGlsLmJhY2t0cmFjZShlbmROb2RlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9pZGVudGlmeVN1Y2Nlc3NvcnMobm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZmFpbCB0byBmaW5kIHRoZSBwYXRoXHJcbiAgICByZXR1cm4gW107XHJcbn07XHJcblxyXG4vKipcclxuICogSWRlbnRpZnkgc3VjY2Vzc29ycyBmb3IgdGhlIGdpdmVuIG5vZGUuIFJ1bnMgYSBqdW1wIHBvaW50IHNlYXJjaCBpbiB0aGVcclxuICogZGlyZWN0aW9uIG9mIGVhY2ggYXZhaWxhYmxlIG5laWdoYm9yLCBhZGRpbmcgYW55IHBvaW50cyBmb3VuZCB0byB0aGUgb3BlblxyXG4gKiBsaXN0LlxyXG4gKiBAcHJvdGVjdGVkXHJcbiAqL1xyXG5KdW1wUG9pbnRGaW5kZXJCYXNlLnByb3RvdHlwZS5faWRlbnRpZnlTdWNjZXNzb3JzID0gZnVuY3Rpb24obm9kZSkge1xyXG4gICAgdmFyIGdyaWQgPSB0aGlzLmdyaWQsXHJcbiAgICAgICAgaGV1cmlzdGljID0gdGhpcy5oZXVyaXN0aWMsXHJcbiAgICAgICAgb3Blbkxpc3QgPSB0aGlzLm9wZW5MaXN0LFxyXG4gICAgICAgIGVuZFggPSB0aGlzLmVuZE5vZGUueCxcclxuICAgICAgICBlbmRZID0gdGhpcy5lbmROb2RlLnksXHJcbiAgICAgICAgbmVpZ2hib3JzLCBuZWlnaGJvcixcclxuICAgICAgICBqdW1wUG9pbnQsIGksIGwsXHJcbiAgICAgICAgeCA9IG5vZGUueCwgeSA9IG5vZGUueSxcclxuICAgICAgICBqeCwganksIGR4LCBkeSwgZCwgbmcsIGp1bXBOb2RlLFxyXG4gICAgICAgIGFicyA9IE1hdGguYWJzLCBtYXggPSBNYXRoLm1heDtcclxuXHJcbiAgICBuZWlnaGJvcnMgPSB0aGlzLl9maW5kTmVpZ2hib3JzKG5vZGUpO1xyXG4gICAgZm9yKGkgPSAwLCBsID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xyXG4gICAgICAgIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xyXG4gICAgICAgIGp1bXBQb2ludCA9IHRoaXMuX2p1bXAobmVpZ2hib3JbMF0sIG5laWdoYm9yWzFdLCB4LCB5KTtcclxuICAgICAgICBpZiAoanVtcFBvaW50KSB7XHJcblxyXG4gICAgICAgICAgICBqeCA9IGp1bXBQb2ludFswXTtcclxuICAgICAgICAgICAgankgPSBqdW1wUG9pbnRbMV07XHJcbiAgICAgICAgICAgIGp1bXBOb2RlID0gZ3JpZC5nZXROb2RlQXQoangsIGp5KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChqdW1wTm9kZS5jbG9zZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpbmNsdWRlIGRpc3RhbmNlLCBhcyBwYXJlbnQgbWF5IG5vdCBiZSBpbW1lZGlhdGVseSBhZGphY2VudDpcclxuICAgICAgICAgICAgZCA9IEhldXJpc3RpYy5vY3RpbGUoYWJzKGp4IC0geCksIGFicyhqeSAtIHkpKTtcclxuICAgICAgICAgICAgbmcgPSBub2RlLmcgKyBkOyAvLyBuZXh0IGBnYCB2YWx1ZVxyXG5cclxuICAgICAgICAgICAgaWYgKCFqdW1wTm9kZS5vcGVuZWQgfHwgbmcgPCBqdW1wTm9kZS5nKSB7XHJcbiAgICAgICAgICAgICAgICBqdW1wTm9kZS5nID0gbmc7XHJcbiAgICAgICAgICAgICAgICBqdW1wTm9kZS5oID0ganVtcE5vZGUuaCB8fCBoZXVyaXN0aWMoYWJzKGp4IC0gZW5kWCksIGFicyhqeSAtIGVuZFkpKTtcclxuICAgICAgICAgICAgICAgIGp1bXBOb2RlLmYgPSBqdW1wTm9kZS5nICsganVtcE5vZGUuaDtcclxuICAgICAgICAgICAgICAgIGp1bXBOb2RlLnBhcmVudCA9IG5vZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFqdW1wTm9kZS5vcGVuZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVuTGlzdC5wdXNoKGp1bXBOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBqdW1wTm9kZS5vcGVuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVuTGlzdC51cGRhdGVJdGVtKGp1bXBOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSnVtcFBvaW50RmluZGVyQmFzZTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pathfinding/src/finders/JumpPointFinderBase.js\n\n}");

/***/ }),

/***/ "./resources/assets/css/game.css":
/*!***************************************!*\
  !*** ./resources/assets/css/game.css ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL2Nzcy9nYW1lLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhY29ubWFuLy4vcmVzb3VyY2VzL2Fzc2V0cy9jc3MvZ2FtZS5jc3M/OGE4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/assets/css/game.css\n\n}");

/***/ }),

/***/ "./resources/assets/js/collectible-entity.js":
/*!***************************************************!*\
  !*** ./resources/assets/js/collectible-entity.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CollectibleEntity)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// CollectibleEntity: base class for dots and fruit\nvar CollectibleEntity = /*#__PURE__*/function () {\n  function CollectibleEntity(col, row) {\n    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'dot';\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    _classCallCheck(this, CollectibleEntity);\n    this.col = col;\n    this.row = row;\n    this.type = type; // 'dot', 'superdot', 'fruit', etc.\n    this.active = true;\n    this.options = options; // e.g., fruit type, points, image\n  }\n  return _createClass(CollectibleEntity, [{\n    key: \"render\",\n    value: function render(ctx, tileSize, art) {\n      if (!this.active) return;\n      if (this.type === 'dot') {\n        ctx.save();\n        ctx.fillStyle = '#fff';\n        ctx.beginPath();\n        ctx.arc(this.col * tileSize + tileSize / 2, this.row * tileSize + tileSize / 2, tileSize / 8, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.restore();\n      } else if (this.type === 'superdot') {\n        ctx.save();\n        ctx.fillStyle = '#ffd700';\n        ctx.beginPath();\n        ctx.arc(this.col * tileSize + tileSize / 2, this.row * tileSize + tileSize / 2, tileSize / 4, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.restore();\n      } else if (this.type === 'fruit') {\n        ctx.save();\n        if (art && art.fruit && art.fruit.image) {\n          ctx.drawImage(art.fruit.image, this.col * tileSize, this.row * tileSize, tileSize, tileSize);\n        } else {\n          ctx.fillStyle = '#f00';\n          ctx.beginPath();\n          ctx.arc(this.col * tileSize + tileSize / 2, this.row * tileSize + tileSize / 2, tileSize / 3, 0, 2 * Math.PI);\n          ctx.fill();\n        }\n        ctx.restore();\n      }\n    }\n  }]);\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbGxlY3RpYmxlLWVudGl0eS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFBQSxJQUNxQkEsaUJBQWlCO0VBQ2xDLFNBQUFBLGtCQUFZQyxHQUFHLEVBQUVDLEdBQUcsRUFBOEI7SUFBQSxJQUE1QkMsSUFBSSxHQUFBQyxTQUFBLENBQUFDLE1BQUEsUUFBQUQsU0FBQSxRQUFBRSxTQUFBLEdBQUFGLFNBQUEsTUFBRyxLQUFLO0lBQUEsSUFBRUcsT0FBTyxHQUFBSCxTQUFBLENBQUFDLE1BQUEsUUFBQUQsU0FBQSxRQUFBRSxTQUFBLEdBQUFGLFNBQUEsTUFBRyxDQUFDLENBQUM7SUFBQUksZUFBQSxPQUFBUixpQkFBQTtJQUM1QyxJQUFJLENBQUNDLEdBQUcsR0FBR0EsR0FBRztJQUNkLElBQUksQ0FBQ0MsR0FBRyxHQUFHQSxHQUFHO0lBQ2QsSUFBSSxDQUFDQyxJQUFJLEdBQUdBLElBQUksQ0FBQyxDQUFDO0lBQ2xCLElBQUksQ0FBQ00sTUFBTSxHQUFHLElBQUk7SUFDbEIsSUFBSSxDQUFDRixPQUFPLEdBQUdBLE9BQU8sQ0FBQyxDQUFDO0VBQzVCO0VBQUMsT0FBQUcsWUFBQSxDQUFBVixpQkFBQTtJQUFBVyxHQUFBO0lBQUFDLEtBQUEsRUFFRCxTQUFBQyxNQUFNQSxDQUFDQyxHQUFHLEVBQUVDLFFBQVEsRUFBRUMsR0FBRyxFQUFFO01BQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUNQLE1BQU0sRUFBRTtNQUNsQixJQUFJLElBQUksQ0FBQ04sSUFBSSxLQUFLLEtBQUssRUFBRTtRQUNyQlcsR0FBRyxDQUFDRyxJQUFJLENBQUMsQ0FBQztRQUNWSCxHQUFHLENBQUNJLFNBQVMsR0FBRyxNQUFNO1FBQ3RCSixHQUFHLENBQUNLLFNBQVMsQ0FBQyxDQUFDO1FBQ2ZMLEdBQUcsQ0FBQ00sR0FBRyxDQUNILElBQUksQ0FBQ25CLEdBQUcsR0FBR2MsUUFBUSxHQUFHQSxRQUFRLEdBQUcsQ0FBQyxFQUNsQyxJQUFJLENBQUNiLEdBQUcsR0FBR2EsUUFBUSxHQUFHQSxRQUFRLEdBQUcsQ0FBQyxFQUNsQ0EsUUFBUSxHQUFHLENBQUMsRUFDWixDQUFDLEVBQUUsQ0FBQyxHQUFHTSxJQUFJLENBQUNDLEVBQ2hCLENBQUM7UUFDRFIsR0FBRyxDQUFDUyxJQUFJLENBQUMsQ0FBQztRQUNWVCxHQUFHLENBQUNVLE9BQU8sQ0FBQyxDQUFDO01BQ2pCLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQ3JCLElBQUksS0FBSyxVQUFVLEVBQUU7UUFDakNXLEdBQUcsQ0FBQ0csSUFBSSxDQUFDLENBQUM7UUFDVkgsR0FBRyxDQUFDSSxTQUFTLEdBQUcsU0FBUztRQUN6QkosR0FBRyxDQUFDSyxTQUFTLENBQUMsQ0FBQztRQUNmTCxHQUFHLENBQUNNLEdBQUcsQ0FDSCxJQUFJLENBQUNuQixHQUFHLEdBQUdjLFFBQVEsR0FBR0EsUUFBUSxHQUFHLENBQUMsRUFDbEMsSUFBSSxDQUFDYixHQUFHLEdBQUdhLFFBQVEsR0FBR0EsUUFBUSxHQUFHLENBQUMsRUFDbENBLFFBQVEsR0FBRyxDQUFDLEVBQ1osQ0FBQyxFQUFFLENBQUMsR0FBR00sSUFBSSxDQUFDQyxFQUNoQixDQUFDO1FBQ0RSLEdBQUcsQ0FBQ1MsSUFBSSxDQUFDLENBQUM7UUFDVlQsR0FBRyxDQUFDVSxPQUFPLENBQUMsQ0FBQztNQUNqQixDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUNyQixJQUFJLEtBQUssT0FBTyxFQUFFO1FBQzlCVyxHQUFHLENBQUNHLElBQUksQ0FBQyxDQUFDO1FBQ1YsSUFBSUQsR0FBRyxJQUFJQSxHQUFHLENBQUNTLEtBQUssSUFBSVQsR0FBRyxDQUFDUyxLQUFLLENBQUNDLEtBQUssRUFBRTtVQUNyQ1osR0FBRyxDQUFDYSxTQUFTLENBQ1RYLEdBQUcsQ0FBQ1MsS0FBSyxDQUFDQyxLQUFLLEVBQ2YsSUFBSSxDQUFDekIsR0FBRyxHQUFHYyxRQUFRLEVBQ25CLElBQUksQ0FBQ2IsR0FBRyxHQUFHYSxRQUFRLEVBQ25CQSxRQUFRLEVBQUVBLFFBQ2QsQ0FBQztRQUNMLENBQUMsTUFBTTtVQUNIRCxHQUFHLENBQUNJLFNBQVMsR0FBRyxNQUFNO1VBQ3RCSixHQUFHLENBQUNLLFNBQVMsQ0FBQyxDQUFDO1VBQ2ZMLEdBQUcsQ0FBQ00sR0FBRyxDQUNILElBQUksQ0FBQ25CLEdBQUcsR0FBR2MsUUFBUSxHQUFHQSxRQUFRLEdBQUcsQ0FBQyxFQUNsQyxJQUFJLENBQUNiLEdBQUcsR0FBR2EsUUFBUSxHQUFHQSxRQUFRLEdBQUcsQ0FBQyxFQUNsQ0EsUUFBUSxHQUFHLENBQUMsRUFDWixDQUFDLEVBQUUsQ0FBQyxHQUFHTSxJQUFJLENBQUNDLEVBQ2hCLENBQUM7VUFDRFIsR0FBRyxDQUFDUyxJQUFJLENBQUMsQ0FBQztRQUNkO1FBQ0FULEdBQUcsQ0FBQ1UsT0FBTyxDQUFDLENBQUM7TUFDakI7SUFDSjtFQUFDO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhY29ubWFuLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb2xsZWN0aWJsZS1lbnRpdHkuanM/MzhiZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2xsZWN0aWJsZUVudGl0eTogYmFzZSBjbGFzcyBmb3IgZG90cyBhbmQgZnJ1aXRcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbGxlY3RpYmxlRW50aXR5IHtcbiAgICBjb25zdHJ1Y3Rvcihjb2wsIHJvdywgdHlwZSA9ICdkb3QnLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5jb2wgPSBjb2w7XG4gICAgICAgIHRoaXMucm93ID0gcm93O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlOyAvLyAnZG90JywgJ3N1cGVyZG90JywgJ2ZydWl0JywgZXRjLlxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7IC8vIGUuZy4sIGZydWl0IHR5cGUsIHBvaW50cywgaW1hZ2VcbiAgICB9XG5cbiAgICByZW5kZXIoY3R4LCB0aWxlU2l6ZSwgYXJ0KSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RvdCcpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNmZmYnO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyhcbiAgICAgICAgICAgICAgICB0aGlzLmNvbCAqIHRpbGVTaXplICsgdGlsZVNpemUgLyAyLFxuICAgICAgICAgICAgICAgIHRoaXMucm93ICogdGlsZVNpemUgKyB0aWxlU2l6ZSAvIDIsXG4gICAgICAgICAgICAgICAgdGlsZVNpemUgLyA4LFxuICAgICAgICAgICAgICAgIDAsIDIgKiBNYXRoLlBJXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSAnc3VwZXJkb3QnKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjZmZkNzAwJztcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5hcmMoXG4gICAgICAgICAgICAgICAgdGhpcy5jb2wgKiB0aWxlU2l6ZSArIHRpbGVTaXplIC8gMixcbiAgICAgICAgICAgICAgICB0aGlzLnJvdyAqIHRpbGVTaXplICsgdGlsZVNpemUgLyAyLFxuICAgICAgICAgICAgICAgIHRpbGVTaXplIC8gNCxcbiAgICAgICAgICAgICAgICAwLCAyICogTWF0aC5QSVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ2ZydWl0Jykge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGlmIChhcnQgJiYgYXJ0LmZydWl0ICYmIGFydC5mcnVpdC5pbWFnZSkge1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgIGFydC5mcnVpdC5pbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2wgKiB0aWxlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3cgKiB0aWxlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgdGlsZVNpemUsIHRpbGVTaXplXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjZjAwJztcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2wgKiB0aWxlU2l6ZSArIHRpbGVTaXplIC8gMixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3cgKiB0aWxlU2l6ZSArIHRpbGVTaXplIC8gMixcbiAgICAgICAgICAgICAgICAgICAgdGlsZVNpemUgLyAzLFxuICAgICAgICAgICAgICAgICAgICAwLCAyICogTWF0aC5QSVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOlsiQ29sbGVjdGlibGVFbnRpdHkiLCJjb2wiLCJyb3ciLCJ0eXBlIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwib3B0aW9ucyIsIl9jbGFzc0NhbGxDaGVjayIsImFjdGl2ZSIsIl9jcmVhdGVDbGFzcyIsImtleSIsInZhbHVlIiwicmVuZGVyIiwiY3R4IiwidGlsZVNpemUiLCJhcnQiLCJzYXZlIiwiZmlsbFN0eWxlIiwiYmVnaW5QYXRoIiwiYXJjIiwiTWF0aCIsIlBJIiwiZmlsbCIsInJlc3RvcmUiLCJmcnVpdCIsImltYWdlIiwiZHJhd0ltYWdlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/assets/js/collectible-entity.js\n\n}");

/***/ }),

/***/ "./resources/assets/js/collectible-spawner.js":
/*!****************************************************!*\
  !*** ./resources/assets/js/collectible-spawner.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CollectibleSpawner)\n/* harmony export */ });\n/* harmony import */ var _collectible_entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./collectible-entity.js */ \"./resources/assets/js/collectible-entity.js\");\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settings.js */ \"./resources/assets/js/settings.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// CollectibleSpawner: generates dots and fruit on valid tiles\n\n\nvar CollectibleSpawner = /*#__PURE__*/function () {\n  function CollectibleSpawner(mapData, tileTypes) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, CollectibleSpawner);\n    this.mapData = mapData;\n    this.tileTypes = tileTypes; // { EMPTY, PORTAL, GHOST_SPAWN, GHOST_DOOR, ... }\n    this.options = options;\n  }\n\n  // Returns: { dots: [], fruit: [] }\n  return _createClass(CollectibleSpawner, [{\n    key: \"spawnCollectibles\",\n    value: function spawnCollectibles() {\n      var existingEntities = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var dots = [];\n      var fruit = [];\n      var superdots = [];\n      var occupied = new Set(existingEntities.map(function (e) {\n        return \"\".concat(e.col, \",\").concat(e.row);\n      }));\n      // SUPERDOTS: Place superdots at positions defined by the map (tileTypes.SUPER_DOT)\n      for (var row = 0; row < this.mapData.length; row++) {\n        for (var col = 0; col < this.mapData[0].length; col++) {\n          if (this.mapData[row][col] === this.tileTypes.SUPER_DOT && !occupied.has(\"\".concat(col, \",\").concat(row)) && !this._isInPen(col, row) && !this._isInPortalOrTunnel(col, row)) {\n            superdots.push(new _collectible_entity_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](col, row, 'superdot', {\n              points: _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].superDotPoints || 50\n            }));\n            occupied.add(\"\".concat(col, \",\").concat(row));\n          }\n        }\n      }\n      // Dots\n      for (var _row = 0; _row < this.mapData.length; _row++) {\n        for (var _col = 0; _col < this.mapData[0].length; _col++) {\n          if (this.mapData[_row][_col] === this.tileTypes.EMPTY && !occupied.has(\"\".concat(_col, \",\").concat(_row)) && !this._isInPen(_col, _row) && !this._isInPortalOrTunnel(_col, _row)) {\n            dots.push(new _collectible_entity_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](_col, _row, 'dot', {\n              points: _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].dotPoints\n            }));\n          }\n        }\n      }\n      // Fruits: Only spawn at least 5 tiles away from any superdot\n      var fruitMinDistance = 5;\n      var fruitCandidates = [];\n      for (var _row2 = 0; _row2 < this.mapData.length; _row2++) {\n        for (var _col2 = 0; _col2 < this.mapData[0].length; _col2++) {\n          if (this.mapData[_row2][_col2] === this.tileTypes.EMPTY && !occupied.has(\"\".concat(_col2, \",\").concat(_row2)) && !this._isInPen(_col2, _row2) && !this._isInPortalOrTunnel(_col2, _row2)) {\n            var tooClose = false;\n            var _iterator = _createForOfIteratorHelper(superdots),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var sd = _step.value;\n                var dx = Math.abs(_col2 - sd.col);\n                var dy = Math.abs(_row2 - sd.row);\n                if (dx + dy < fruitMinDistance) {\n                  tooClose = true;\n                  break;\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n            if (!tooClose) {\n              fruitCandidates.push({\n                col: _col2,\n                row: _row2\n              });\n            }\n          }\n        }\n      }\n      // Pick a random fruit type\n      var fruitType = _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fruitTypes[Math.floor(Math.random() * _settings_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fruitTypes.length)];\n      // Optionally, allow caller to pass fruit locations\n      var fruitLocations = this.options.fruitLocations || [];\n      if (fruitLocations.length === 0) {\n        if (fruitCandidates.length > 0) {\n          fruitLocations = [fruitCandidates[Math.floor(Math.random() * fruitCandidates.length)]];\n        }\n      }\n      var _iterator2 = _createForOfIteratorHelper(fruitLocations),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var loc = _step2.value;\n          if (loc) {\n            fruit.push(new _collectible_entity_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](loc.col, loc.row, 'fruit', _objectSpread({}, fruitType)));\n            occupied.add(\"\".concat(loc.col, \",\").concat(loc.row));\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return {\n        superdots: superdots,\n        dots: dots,\n        fruit: fruit\n      };\n    }\n  }, {\n    key: \"_pickRandomValidTile\",\n    value: function _pickRandomValidTile(occupied) {\n      var valid = [];\n      for (var row = 0; row < this.mapData.length; row++) {\n        for (var col = 0; col < this.mapData[0].length; col++) {\n          if (this.mapData[row][col] === this.tileTypes.EMPTY && !occupied.has(\"\".concat(col, \",\").concat(row)) && !this._isInPen(col, row) && !this._isInPortalOrTunnel(col, row)) {\n            valid.push({\n              col: col,\n              row: row\n            });\n          }\n        }\n      }\n      if (valid.length === 0) return null;\n      return valid[Math.floor(Math.random() * valid.length)];\n    }\n  }, {\n    key: \"_isInPen\",\n    value: function _isInPen(col, row) {\n      // Pen is GHOST_SPAWN or GHOST_DOOR\n      return this.mapData[row][col] === this.tileTypes.GHOST_SPAWN || this.mapData[row][col] === this.tileTypes.GHOST_DOOR;\n    }\n  }, {\n    key: \"_isInPortalOrTunnel\",\n    value: function _isInPortalOrTunnel(col, row) {\n      // Exclude portals and the empty tunnel path between them\n      if (this.mapData[row][col] === this.tileTypes.PORTAL) return true;\n      // Optionally: Exclude direct tunnel path (left/right edge)\n      if (col === 0 || col === this.mapData[0].length - 1) return true;\n      return false;\n    }\n  }]);\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2NvbGxlY3RpYmxlLXNwYXduZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0Q7QUFDbkI7QUFBQSxJQUVoQkUsa0JBQWtCO0VBQ25DLFNBQUFBLG1CQUFZQyxPQUFPLEVBQUVDLFNBQVMsRUFBZ0I7SUFBQSxJQUFkQyxPQUFPLEdBQUFDLFNBQUEsQ0FBQUMsTUFBQSxRQUFBRCxTQUFBLFFBQUFFLFNBQUEsR0FBQUYsU0FBQSxNQUFHLENBQUMsQ0FBQztJQUFBRyxlQUFBLE9BQUFQLGtCQUFBO0lBQ3hDLElBQUksQ0FBQ0MsT0FBTyxHQUFHQSxPQUFPO0lBQ3RCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQSxTQUFTLENBQUMsQ0FBQztJQUM1QixJQUFJLENBQUNDLE9BQU8sR0FBR0EsT0FBTztFQUMxQjs7RUFFQTtFQUFBLE9BQUFLLFlBQUEsQ0FBQVIsa0JBQUE7SUFBQVMsR0FBQTtJQUFBQyxLQUFBLEVBQ0EsU0FBQUMsaUJBQWlCQSxDQUFBLEVBQXdCO01BQUEsSUFBdkJDLGdCQUFnQixHQUFBUixTQUFBLENBQUFDLE1BQUEsUUFBQUQsU0FBQSxRQUFBRSxTQUFBLEdBQUFGLFNBQUEsTUFBRyxFQUFFO01BQ25DLElBQU1TLElBQUksR0FBRyxFQUFFO01BQ2YsSUFBTUMsS0FBSyxHQUFHLEVBQUU7TUFDaEIsSUFBTUMsU0FBUyxHQUFHLEVBQUU7TUFDcEIsSUFBTUMsUUFBUSxHQUFHLElBQUlDLEdBQUcsQ0FBQ0wsZ0JBQWdCLENBQUNNLEdBQUcsQ0FBQyxVQUFBQyxDQUFDO1FBQUEsVUFBQUMsTUFBQSxDQUFPRCxDQUFDLENBQUNFLEdBQUcsT0FBQUQsTUFBQSxDQUFJRCxDQUFDLENBQUNHLEdBQUc7TUFBQSxDQUFFLENBQUMsQ0FBQztNQUN4RTtNQUNBLEtBQUssSUFBSUEsR0FBRyxHQUFHLENBQUMsRUFBRUEsR0FBRyxHQUFHLElBQUksQ0FBQ3JCLE9BQU8sQ0FBQ0ksTUFBTSxFQUFFaUIs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UUFBUUEsQ0FBQ0osR0FBRyxFQUFFQyxHQUFHLEVBQUU7TUFDZjtNQUNBLE9BQ0ksSUFBSSxDQUFDckIsT0FBTyxDQUFDcUIsR0FBRyxDQUFDLENBQUNELEdBQUcsQ0FBQyxLQUFLLElBQUksQ0FBQ25CLFNBQVMsQ0FBQzBELFdBQVcsSUFDckQsSUFBSSxDQUFDM0QsT0FBTyxDQUFDcUIsR0FBRyxDQUFDLENBQUNELEdBQUcsQ0FBQyxLQUFLLElBQUksQ0FBQ25CLFNBQVMsQ0FBQzJELFVBQVU7SUFFNUQ7RUFBQztJQUFBcEQsR0FBQTtJQUFBQyxLQUFBLEVBRUQsU0FBQWdCLG1CQUFtQkEsQ0FBQ0wsR0FBRyxFQUFFQyxHQUFHLEVBQUU7TUFDMUI7TUFDQSxJQUFJLElBQUksQ0FBQ3JCLE9BQU8sQ0FBQ3FCLEdBQUcsQ0FBQyxDQUFDRCxHQUFHLENBQUMsS0FBSyxJQUFJLENBQUNuQixTQUFTLENBQUM0RCxNQUFNLEVBQUUsT0FBTyxJQUFJO01BQ2pFO01BQ0EsSUFBSXpDLEdBQUcsS0FBSyxDQUFDLElBQUlBLEdBQUcsS0FBSyxJQUFJLENBQUNwQixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUNJLE1BQU0sR0FBRyxDQUFDLEVBQUUsT0FBTyxJQUFJO01BQ2hFLE9BQU8sS0FBSztJQUNoQjtFQUFDO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhY29ubWFuLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9jb2xsZWN0aWJsZS1zcGF3bmVyLmpzP2ExMGUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29sbGVjdGlibGVTcGF3bmVyOiBnZW5lcmF0ZXMgZG90cyBhbmQgZnJ1aXQgb24gdmFsaWQgdGlsZXNcbmltcG9ydCBDb2xsZWN0aWJsZUVudGl0eSBmcm9tICcuL2NvbGxlY3RpYmxlLWVudGl0eS5qcyc7XG5pbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi9zZXR0aW5ncy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbGxlY3RpYmxlU3Bhd25lciB7XG4gICAgY29uc3RydWN0b3IobWFwRGF0YSwgdGlsZVR5cGVzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5tYXBEYXRhID0gbWFwRGF0YTtcbiAgICAgICAgdGhpcy50aWxlVHlwZXMgPSB0aWxlVHlwZXM7IC8vIHsgRU1QVFksIFBPUlRBTCwgR0hPU1RfU1BBV04sIEdIT1NUX0RPT1IsIC4uLiB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuczogeyBkb3RzOiBbXSwgZnJ1aXQ6IFtdIH1cbiAgICBzcGF3bkNvbGxlY3RpYmxlcyhleGlzdGluZ0VudGl0aWVzID0gW10pIHtcbiAgICAgICAgY29uc3QgZG90cyA9IFtdO1xuICAgICAgICBjb25zdCBmcnVpdCA9IFtdO1xuICAgICAgICBjb25zdCBzdXBlcmRvdHMgPSBbXTtcbiAgICAgICAgY29uc3Qgb2NjdXBpZWQgPSBuZXcgU2V0KGV4aXN0aW5nRW50aXRpZXMubWFwKGUgPT4gYCR7ZS5jb2x9LCR7ZS5yb3d9YCkpO1xuICAgICAgICAvLyBTVVBFUkRPVFM6IFBsYWNlIHN1cGVyZG90cyBhdCBwb3NpdGlvbnMgZGVmaW5lZCBieSB0aGUgbWFwICh0aWxlVHlwZXMuU1VQRVJfRE9UKVxuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLm1hcERhdGEubGVuZ3RoOyByb3crKykge1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5tYXBEYXRhWzBdLmxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwRGF0YVtyb3ddW2NvbF0gPT09IHRoaXMudGlsZVR5cGVzLlNVUEVSX0RPVCAmJlxuICAgICAgICAgICAgICAgICAgICAhb2NjdXBpZWQuaGFzKGAke2NvbH0sJHtyb3d9YCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2lzSW5QZW4oY29sLCByb3cpICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLl9pc0luUG9ydGFsT3JUdW5uZWwoY29sLCByb3cpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyZG90cy5wdXNoKG5ldyBDb2xsZWN0aWJsZUVudGl0eShjb2wsIHJvdywgJ3N1cGVyZG90JywgeyBwb2ludHM6IHNldHRpbmdzLnN1cGVyRG90UG9pbnRzIHx8IDUwIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgb2NjdXBpZWQuYWRkKGAke2NvbH0sJHtyb3d9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERvdHNcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5tYXBEYXRhLmxlbmd0aDsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMubWFwRGF0YVswXS5sZW5ndGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcERhdGFbcm93XVtjb2xdID09PSB0aGlzLnRpbGVUeXBlcy5FTVBUWSAmJlxuICAgICAgICAgICAgICAgICAgICAhb2NjdXBpZWQuaGFzKGAke2NvbH0sJHtyb3d9YCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2lzSW5QZW4oY29sLCByb3cpICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLl9pc0luUG9ydGFsT3JUdW5uZWwoY29sLCByb3cpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvdHMucHVzaChuZXcgQ29sbGVjdGlibGVFbnRpdHkoY29sLCByb3csICdkb3QnLCB7IHBvaW50czogc2V0dGluZ3MuZG90UG9pbnRzIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRnJ1aXRzOiBPbmx5IHNwYXduIGF0IGxlYXN0IDUgdGlsZXMgYXdheSBmcm9tIGFueSBzdXBlcmRvdFxuICAgICAgICBjb25zdCBmcnVpdE1pbkRpc3RhbmNlID0gNTtcbiAgICAgICAgY29uc3QgZnJ1aXRDYW5kaWRhdGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMubWFwRGF0YS5sZW5ndGg7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLm1hcERhdGFbMF0ubGVuZ3RoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBEYXRhW3Jvd11bY29sXSA9PT0gdGhpcy50aWxlVHlwZXMuRU1QVFkgJiZcbiAgICAgICAgICAgICAgICAgICAgIW9jY3VwaWVkLmhhcyhgJHtjb2x9LCR7cm93fWApICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLl9pc0luUGVuKGNvbCwgcm93KSAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5faXNJblBvcnRhbE9yVHVubmVsKGNvbCwgcm93KVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9vQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZCBvZiBzdXBlcmRvdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR4ID0gTWF0aC5hYnMoY29sIC0gc2QuY29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR5ID0gTWF0aC5hYnMocm93IC0gc2Qucm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeCArIGR5IDwgZnJ1aXRNaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb0Nsb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvb0Nsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcnVpdENhbmRpZGF0ZXMucHVzaCh7Y29sLCByb3d9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQaWNrIGEgcmFuZG9tIGZydWl0IHR5cGVcbiAgICAgICAgY29uc3QgZnJ1aXRUeXBlID0gc2V0dGluZ3MuZnJ1aXRUeXBlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBzZXR0aW5ncy5mcnVpdFR5cGVzLmxlbmd0aCldO1xuICAgICAgICAvLyBPcHRpb25hbGx5LCBhbGxvdyBjYWxsZXIgdG8gcGFzcyBmcnVpdCBsb2NhdGlvbnNcbiAgICAgICAgbGV0IGZydWl0TG9jYXRpb25zID0gdGhpcy5vcHRpb25zLmZydWl0TG9jYXRpb25zIHx8IFtdO1xuICAgICAgICBpZiAoZnJ1aXRMb2NhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoZnJ1aXRDYW5kaWRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmcnVpdExvY2F0aW9ucyA9IFtmcnVpdENhbmRpZGF0ZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZnJ1aXRDYW5kaWRhdGVzLmxlbmd0aCldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxvYyBvZiBmcnVpdExvY2F0aW9ucykge1xuICAgICAgICAgICAgaWYgKGxvYykge1xuICAgICAgICAgICAgICAgIGZydWl0LnB1c2gobmV3IENvbGxlY3RpYmxlRW50aXR5KGxvYy5jb2wsIGxvYy5yb3csICdmcnVpdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZnJ1aXRUeXBlXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIG9jY3VwaWVkLmFkZChgJHtsb2MuY29sfSwke2xvYy5yb3d9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3VwZXJkb3RzLCBkb3RzLCBmcnVpdCB9O1xuICAgIH1cblxuICAgIF9waWNrUmFuZG9tVmFsaWRUaWxlKG9jY3VwaWVkKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gW107XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMubWFwRGF0YS5sZW5ndGg7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLm1hcERhdGFbMF0ubGVuZ3RoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBEYXRhW3Jvd11bY29sXSA9PT0gdGhpcy50aWxlVHlwZXMuRU1QVFkgJiZcbiAgICAgICAgICAgICAgICAgICAgIW9jY3VwaWVkLmhhcyhgJHtjb2x9LCR7cm93fWApICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLl9pc0luUGVuKGNvbCwgcm93KSAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5faXNJblBvcnRhbE9yVHVubmVsKGNvbCwgcm93KVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZC5wdXNoKHsgY29sLCByb3cgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWxpZC5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdmFsaWRbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdmFsaWQubGVuZ3RoKV07XG4gICAgfVxuXG4gICAgX2lzSW5QZW4oY29sLCByb3cpIHtcbiAgICAgICAgLy8gUGVuIGlzIEdIT1NUX1NQQVdOIG9yIEdIT1NUX0RPT1JcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMubWFwRGF0YVtyb3ddW2NvbF0gPT09IHRoaXMudGlsZVR5cGVzLkdIT1NUX1NQQVdOIHx8XG4gICAgICAgICAgICB0aGlzLm1hcERhdGFbcm93XVtjb2xdID09PSB0aGlzLnRpbGVUeXBlcy5HSE9TVF9ET09SXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgX2lzSW5Qb3J0YWxPclR1bm5lbChjb2wsIHJvdykge1xuICAgICAgICAvLyBFeGNsdWRlIHBvcnRhbHMgYW5kIHRoZSBlbXB0eSB0dW5uZWwgcGF0aCBiZXR3ZWVuIHRoZW1cbiAgICAgICAgaWYgKHRoaXMubWFwRGF0YVtyb3ddW2NvbF0gPT09IHRoaXMudGlsZVR5cGVzLlBPUlRBTCkgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIE9wdGlvbmFsbHk6IEV4Y2x1ZGUgZGlyZWN0IHR1bm5lbCBwYXRoIChsZWZ0L3JpZ2h0IGVkZ2UpXG4gICAgICAgIGlmIChjb2wgPT09IDAgfHwgY29sID09PSB0aGlzLm1hcERhdGFbMF0ubGVuZ3RoIC0gMSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiQ29sbGVjdGlibGVFbnRpdHkiLCJzZXR0aW5ncyIsIkNvbGxlY3RpYmxlU3Bhd25lciIsIm1hcERhdGEiLCJ0aWxlVHlwZXMiLCJvcHRpb25zIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiX2NsYXNzQ2FsbENoZWNrIiwiX2NyZWF0ZUNsYXNzIiwia2V5IiwidmFsdWUiLCJzcGF3bkNvbGxlY3RpYmxlcyIsImV4aXN0aW5nRW50aXRpZXMiLCJkb3RzIiwiZnJ1aXQiLCJzdXBlcmRvdHMiLCJvY2N1cGllZCIsIlNldCIsIm1hcCIsImUiLCJjb25jYXQiLCJjb2wiLCJyb3ciLCJTVVBFUl9ET1QiLCJoYXMiLCJfaXNJblBlbiIsIl9pc0luUG9ydGFsT3JUdW5uZWwiLCJwdXNoIiwicG9pbnRzIiwic3VwZXJEb3RQb2ludHMiLCJhZGQiLCJFTVBUWSIsImRvdFBvaW50cyIsImZydWl0TWluRGlzdGFuY2UiLCJmcnVpdENhbmRpZGF0ZXMiLCJ0b29DbG9zZSIsIl9pdGVyYXRvciIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIiwiX3N0ZXAiLCJzIiwibiIsImRvbmUiLCJzZCIsImR4IiwiTWF0aCIsImFicyIsImR5IiwiZXJyIiwiZiIsImZydWl0VHlwZSIsImZydWl0VHlwZXMiLCJmbG9vciIsInJhbmRvbSIsImZydWl0TG9jYXRpb25zIiwiX2l0ZXJhdG9yMiIsIl9zdGVwMiIsImxvYyIsIl9vYmplY3RTcHJlYWQiLCJfcGlja1JhbmRvbVZhbGlkVGlsZSIsInZhbGlkIiwiR0hPU1RfU1BBV04iLCJHSE9TVF9ET09SIiwiUE9SVEFMIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/assets/js/collectible-spawner.js\n\n}");

/***/ }),

/***/ "./resources/assets/js/entity-art.js":
/*!*******************************************!*\
  !*** ./resources/assets/js/entity-art.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// Central config for entity art assets and metadata\n// Use PNG or SVG paths (relative to public/vendor/laraconman/images/)\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  player: {\n    name: 'Player',\n    image: '/vendor/laraconman/images/player.svg',\n    size: 32\n  },\n  ghosts: [{\n    name: 'NullPointer',\n    image: '/vendor/laraconman/images/ghost-blinky.svg',\n    size: 32\n  }, {\n    name: 'PushProduction',\n    image: '/vendor/laraconman/images/ghost-pinky.svg',\n    size: 32\n  }, {\n    name: 'Glitchy',\n    image: '/vendor/laraconman/images/ghost-inky.svg',\n    size: 32\n  }, {\n    name: 'Regexorcist',\n    image: '/vendor/laraconman/images/ghost-clyde.svg',\n    size: 32\n  }, {\n    name: 'RaceCondition',\n    image: '/vendor/laraconman/images/ghost-blinky.svg',\n    size: 32\n  }, {\n    name: 'HeapReaper',\n    image: '/vendor/laraconman/images/ghost-pinky.svg',\n    size: 32\n  }, {\n    name: 'GhostException',\n    image: '/vendor/laraconman/images/ghost-inky.svg',\n    size: 32\n  }, {\n    name: 'StackOverghost',\n    image: '/vendor/laraconman/images/ghost-clyde.svg',\n    size: 32\n  }, {\n    name: 'SyntaxTerror',\n    image: '/vendor/laraconman/images/ghost-blinky.svg',\n    size: 32\n  }],\n  dot: {\n    image: '/vendor/laraconman/images/dot.svg',\n    size: 8\n  },\n  powerPellets: [{\n    name: 'Classic',\n    image: '/vendor/laraconman/images/power-pellet-classic.svg',\n    size: 16\n  }, {\n    name: 'Star',\n    image: '/vendor/laraconman/images/power-pellet-star.svg',\n    size: 16\n  }],\n  fruit: [{\n    name: 'Cherry',\n    image: '/vendor/laraconman/images/fruit-cherry.svg',\n    size: 20\n  }, {\n    name: 'Strawberry',\n    image: '/vendor/laraconman/images/fruit-strawberry.svg',\n    size: 20\n  }]\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2VudGl0eS1hcnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUEsaUVBQWU7RUFDWEEsTUFBTSxFQUFFO0lBQ0pDLElBQUksRUFBRSxRQUFRO0lBQ2RDLEtBQUssRUFBRSxzQ0FBc0M7SUFDN0NDLElBQUksRUFBRTtFQUNWLENBQUM7RUFDREMsTUFBTSxFQUFFLENBQ0o7SUFBRUgsSUFBSSxFQUFFLGFBQWE7SUFBS0MsS0FBSyxFQUFFLDRDQUE0QztJQUFFQyxJQUFJLEVBQUU7RUFBRyxDQUFDLEVBQ3pGO0lBQUVGLElBQUksRUFBRSxnQkFBZ0I7SUFBUUMsS0FBSyxFQUFFLDJDQUEyQztJQUFHQyxJQUFJLEVBQUU7RUFBRyxDQUFDLEVBQy9GO0lBQUVGLElBQUksRUFBRSxTQUFTO0lBQVNDLEtBQUssRUFBRSwwQ0FBMEM7SUFBSUMsSUFBSSxFQUFFO0VBQUcsQ0FBQyxFQUN6RjtJQUFFRixJQUFJLEVBQUUsYUFBYTtJQUFLQyxLQUFLLEVBQUUsMkNBQTJDO0lBQUdDLElBQUksRUFBRTtFQUFHLENBQUMsRUFDekY7SUFBRUYsSUFBSSxFQUFFLGVBQWU7SUFBR0MsS0FBSyxFQUFFLDRDQUE0QztJQUFFQyxJQUFJLEVBQUU7RUFBRyxDQUFDLEVBQ3pGO0lBQUVGLElBQUksRUFBRSxZQUFZO0lBQU1DLEtBQUssRUFBRSwyQ0FBMkM7SUFBR0MsSUFBSSxFQUFFO0VBQUcsQ0FBQyxFQUN6RjtJQUFFRixJQUFJLEVBQUUsZ0JBQWdCO0lBQUVDLEtBQUssRUFBRSwwQ0FBMEM7SUFBSUMsSUFBSSxFQUFFO0VBQUcsQ0FBQyxFQUN6RjtJQUFFRixJQUFJLEVBQUUsZ0JBQWdCO0lBQUVDLEtBQUssRUFBRSwyQ0FBMkM7SUFBR0MsSUFBSSxFQUFFO0VBQUcsQ0FBQyxFQUN6RjtJQUFFRixJQUFJLEVBQUUsY0FBYztJQUFJQyxLQUFLLEVBQUUsNENBQTRDO0lBQUVDLElBQUksRUFBRTtFQUFHLENBQUMsQ0FDNUY7RUFDREUsR0FBRyxFQUFFO0lBQ0RILEtBQUssRUFBRSxtQ0FBbUM7SUFDMUNDLElBQUksRUFBRTtFQUNWLENBQUM7RUFDREcsWUFBWSxFQUFFLENBQ1Y7SUFBRUwsSUFBSSxFQUFFLFNBQVM7SUFBRUMsS0FBSyxFQUFFLG9EQUFvRDtJQUFFQyxJQUFJLEVBQUU7RUFBRyxDQUFDLEVBQzFGO0lBQUVGLElBQUksRUFBRSxNQUFNO0lBQUtDLEtBQUssRUFBRSxpREFBaUQ7SUFBS0MsSUFBSSxFQUFFO0VBQUcsQ0FBQyxDQUM3RjtFQUNESSxLQUFLLEVBQUUsQ0FDSDtJQUFFTixJQUFJLEVBQUUsUUFBUTtJQUFHQyxLQUFLLEVBQUUsNENBQTRDO0lBQUdDLElBQUksRUFBRTtFQUFHLENBQUMsRUFDbkY7SUFBRUYsSUFBSSxFQUFFLFlBQVk7SUFBRUMsS0FBSyxFQUFFLGdEQUFnRDtJQUFFQyxJQUFJLEVBQUU7RUFBRyxDQUFDO0FBRWpHLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhY29ubWFuLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9lbnRpdHktYXJ0LmpzPzAzMDUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2VudHJhbCBjb25maWcgZm9yIGVudGl0eSBhcnQgYXNzZXRzIGFuZCBtZXRhZGF0YVxuLy8gVXNlIFBORyBvciBTVkcgcGF0aHMgKHJlbGF0aXZlIHRvIHB1YmxpYy92ZW5kb3IvbGFyYWNvbm1hbi9pbWFnZXMvKVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcGxheWVyOiB7XG4gICAgICAgIG5hbWU6ICdQbGF5ZXInLFxuICAgICAgICBpbWFnZTogJy92ZW5kb3IvbGFyYWNvbm1hbi9pbWFnZXMvcGxheWVyLnN2ZycsXG4gICAgICAgIHNpemU6IDMyXG4gICAgfSxcbiAgICBnaG9zdHM6IFtcbiAgICAgICAgeyBuYW1lOiAnTnVsbFBvaW50ZXInLCAgICBpbWFnZTogJy92ZW5kb3IvbGFyYWNvbm1hbi9pbWFnZXMvZ2hvc3QtYmxpbmt5LnN2ZycsIHNpemU6IDMyIH0sXG4gICAgICAgIHsgbmFtZTogJ1B1c2hQcm9kdWN0aW9uJywgICAgICAgaW1hZ2U6ICcvdmVuZG9yL2xhcmFjb25tYW4vaW1hZ2VzL2dob3N0LXBpbmt5LnN2ZycsICBzaXplOiAzMiB9LFxuICAgICAgICB7IG5hbWU6ICdHbGl0Y2h5JywgICAgICAgIGltYWdlOiAnL3ZlbmRvci9sYXJhY29ubWFuL2ltYWdlcy9naG9zdC1pbmt5LnN2ZycsICAgc2l6ZTogMzIgfSxcbiAgICAgICAgeyBuYW1lOiAnUmVnZXhvcmNpc3QnLCAgICBpbWFnZTogJy92ZW5kb3IvbGFyYWNvbm1hbi9pbWFnZXMvZ2hvc3QtY2x5ZGUuc3ZnJywgIHNpemU6IDMyIH0sXG4gICAgICAgIHsgbmFtZTogJ1JhY2VDb25kaXRpb24nLCAgaW1hZ2U6ICcvdmVuZG9yL2xhcmFjb25tYW4vaW1hZ2VzL2dob3N0LWJsaW5reS5zdmcnLCBzaXplOiAzMiB9LFxuICAgICAgICB7IG5hbWU6ICdIZWFwUmVhcGVyJywgICAgIGltYWdlOiAnL3ZlbmRvci9sYXJhY29ubWFuL2ltYWdlcy9naG9zdC1waW5reS5zdmcnLCAgc2l6ZTogMzIgfSxcbiAgICAgICAgeyBuYW1lOiAnR2hvc3RFeGNlcHRpb24nLCBpbWFnZTogJy92ZW5kb3IvbGFyYWNvbm1hbi9pbWFnZXMvZ2hvc3QtaW5reS5zdmcnLCAgIHNpemU6IDMyIH0sXG4gICAgICAgIHsgbmFtZTogJ1N0YWNrT3Zlcmdob3N0JywgaW1hZ2U6ICcvdmVuZG9yL2xhcmFjb25tYW4vaW1hZ2VzL2dob3N0LWNseWRlLnN2ZycsICBzaXplOiAzMiB9LFxuICAgICAgICB7IG5hbWU6ICdTeW50YXhUZXJyb3InLCAgIGltYWdlOiAnL3ZlbmRvci9sYXJhY29ubWFuL2ltYWdlcy9naG9zdC1ibGlua3kuc3ZnJywgc2l6ZTogMzIgfVxuICAgIF0sXG4gICAgZG90OiB7XG4gICAgICAgIGltYWdlOiAnL3ZlbmRvci9sYXJhY29ubWFuL2ltYWdlcy9kb3Quc3ZnJyxcbiAgICAgICAgc2l6ZTogOFxuICAgIH0sXG4gICAgcG93ZXJQZWxsZXRzOiBbXG4gICAgICAgIHsgbmFtZTogJ0NsYXNzaWMnLCBpbWFnZTogJy92ZW5kb3IvbGFyYWNvbm1hbi9pbWFnZXMvcG93ZXItcGVsbGV0LWNsYXNzaWMuc3ZnJywgc2l6ZTogMTYgfSxcbiAgICAgICAgeyBuYW1lOiAnU3RhcicsICAgIGltYWdlOiAnL3ZlbmRvci9sYXJhY29ubWFuL2ltYWdlcy9wb3dlci1wZWxsZXQtc3Rhci5zdmcnLCAgICBzaXplOiAxNiB9XG4gICAgXSxcbiAgICBmcnVpdDogW1xuICAgICAgICB7IG5hbWU6ICdDaGVycnknLCAgaW1hZ2U6ICcvdmVuZG9yL2xhcmFjb25tYW4vaW1hZ2VzL2ZydWl0LWNoZXJyeS5zdmcnLCAgc2l6ZTogMjAgfSxcbiAgICAgICAgeyBuYW1lOiAnU3RyYXdiZXJyeScsIGltYWdlOiAnL3ZlbmRvci9sYXJhY29ubWFuL2ltYWdlcy9mcnVpdC1zdHJhd2JlcnJ5LnN2ZycsIHNpemU6IDIwIH1cbiAgICBdXG59O1xuIl0sIm5hbWVzIjpbInBsYXllciIsIm5hbWUiLCJpbWFnZSIsInNpemUiLCJnaG9zdHMiLCJkb3QiLCJwb3dlclBlbGxldHMiLCJmcnVpdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/assets/js/entity-art.js\n\n}");

/***/ }),

/***/ "./resources/assets/js/fx.js":
/*!***********************************!*\
  !*** ./resources/assets/js/fx.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   throttleLeading: () => (/* binding */ throttleLeading)\n/* harmony export */ });\n// further fx to come - send all ghosts to home, blow them all up, send pacman to co-ords or to a powerpill\n\n// Generic debounce utility\n// Usage: const debouncedFn = debounce(fn, wait)\nfunction debounce(fn) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;\n  var timeout;\n  return function () {\n    var _this = this;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      return fn.apply(_this, args);\n    }, wait);\n  };\n}\nfunction throttleLeading(fn) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n  var locked = false;\n  return function () {\n    if (locked) return;\n    locked = true;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    fn.apply(this, args);\n    setTimeout(function () {\n      locked = false;\n    }, wait);\n  };\n}\n/* Quick Spin */\nfunction effect_quick_spin() {\n  movespeed = speed - 20;\n  ghostspeed = speed - 20;\n  effect_mushrooms = 1;\n  effectTimer = 60;\n  invincibility = 1;\n  document.getElementById(\"pacman-top\").style.background = \"orange\";\n  document.getElementById(\"pacman-bottom\").style.background = \"orange\";\n  wallColour(\"#6600ff\");\n  //eval (\"document.getElementById('pacman').classList.add('spin')\");\n  eval(\"document.getElementById('maze').classList.add('spin')\");\n  for (i = 0; i < total_ghosts; i++) {\n    eval(\"document.getElementById('ghost\" + i + \"').classList.add('spin')\");\n  }\n}\nfunction effect_quick_spin_warn() {\n  eval(\"document.getElementById('maze').classList.remove('spin')\");\n  eval(\"document.getElementById('maze').classList.add('spin')\");\n}\nfunction effect_quick_spin_end() {\n  effect_mushrooms = 0;\n  wallColour(\"#3300ff\");\n  eval(\"document.getElementById('pacman').classList.remove('spin')\");\n  eval(\"document.getElementById('maze').classList.remove('spin')\");\n  for (i = 0; i < total_ghosts; i++) {\n    eval(\"document.getElementById('ghost\" + i + \"').classList.remove('spin')\");\n  }\n  movespeed = speed;\n  ghostspeed = speed;\n  invincibility = 0;\n  document.getElementById(\"pacman-top\").style.background = \"yellow\";\n  document.getElementById(\"pacman-bottom\").style.background = \"yellow\";\n}\n\n/* Long spin */\n\nfunction effect_long_spin() {\n  movespeed = speed - 20;\n  ghostspeed = speed - 20;\n  effect_mushrooms = 1;\n  effectTimer = 150;\n  invincibility = 1;\n  document.getElementById(\"pacman-top\").style.background = \"orange\";\n  document.getElementById(\"pacman-bottom\").style.background = \"orange\";\n  wallColour(\"#6600ff\");\n  eval(\"document.getElementById('pacman').classList.add('spin')\");\n  eval(\"document.getElementById('maze').classList.add('longspin')\");\n  for (i = 0; i < total_ghosts; i++) {\n    eval(\"document.getElementById('ghost\" + i + \"').classList.add('spin')\");\n  }\n}\nfunction effect_long_spin_warn() {\n  eval(\"document.getElementById('maze').classList.remove('longspin')\");\n  eval(\"document.getElementById('maze').classList.add('spin')\");\n}\nfunction effect_long_spin_end() {\n  effect_mushrooms = 0;\n  wallColour(\"#3300ff\");\n  eval(\"document.getElementById('pacman').classList.remove('spin')\");\n  eval(\"document.getElementById('maze').classList.remove('spin')\");\n  for (i = 0; i < total_ghosts; i++) {\n    eval(\"document.getElementById('ghost\" + i + \"').classList.remove('spin')\");\n  }\n  movespeed = speed;\n  ghostspeed = speed;\n  invincibility = 0;\n  document.getElementById(\"pacman-top\").style.background = \"yellow\";\n  document.getElementById(\"pacman-bottom\").style.background = \"yellow\";\n}\nfunction effect_mushrooms() {\n  movespeed = speed - 20;\n  ghostspeed = speed - 20;\n  effect_mushrooms = 1;\n  effectTimer = 250;\n  invincibility = 1;\n  document.getElementById(\"pacman-top\").style.background = \"orange\";\n  document.getElementById(\"pacman-bottom\").style.background = \"orange\";\n  wallColour(\"#6600ff\");\n  eval(\"document.getElementById('pacman').classList.add('spin')\");\n  eval(\"document.getElementById('maze').classList.add('spin')\");\n  for (i = 0; i < total_ghosts; i++) {\n    eval(\"document.getElementById('ghost\" + i + \"').classList.add('fastspin')\");\n  }\n}\nfunction effect_mushrooms_warn() {\n  eval(\"document.getElementById('maze').classList.remove('spin')\");\n  eval(\"document.getElementById('maze').classList.add('spin')\");\n  eval(\"document.getElementById('pacman').classList.remove('spin')\");\n  for (i = 0; i < total_ghosts; i++) {\n    eval(\"document.getElementById('ghost\" + i + \"').classList.remove('fastspin')\");\n  }\n  movespeed = speed;\n  ghostspeed = speed;\n}\nfunction effect_mushrooms_end() {\n  effect_mushrooms = 0;\n  wallColour(\"#3300ff\");\n  eval(\"document.getElementById('pacman').classList.remove('spin')\");\n  eval(\"document.getElementById('maze').classList.remove('spin')\");\n  invincibility = 0;\n  document.getElementById(\"pacman-top\").style.background = \"yellow\";\n  document.getElementById(\"pacman-bottom\").style.background = \"yellow\";\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2hFQSxJQUFJLENBQUUsdURBQXVELENBQUM7RUFDOUQsS0FBS0MsQ0FBQyxHQUFDLENBQUMsRUFBQ0EsQ0FBQyxHQUFDQyxZQUFZLEVBQUNELENBQUMsRUFBRSxFQUFDO0lBQ3hCRCxJQUFJLENBQUUsZ0NBQWdDLEdBQUdDLENBQUMsR0FBRyw4QkFBOEIsQ0FBQztFQUNoRjtBQUNKO0FBRUEsU0FBU08scUJBQXFCQSxDQUFBLEVBQUU7RUFDNUJSLElBQUksQ0FBRSwwREFBMEQsQ0FBQztFQUNqRUEsSUFBSSxDQUFFLHVEQUF1RCxDQUFDO0VBQzlEQSxJQUFJLENBQUUsNERBQTRELENBQUM7RUFDbkUsS0FBSUMsQ0FBQyxHQUFDLENBQUMsRUFBQ0EsQ0FBQyxHQUFDQyxZQUFZLEVBQUNELENBQUMsRUFBRSxFQUFDO0lBQ3ZCRCxJQUFJLENBQUUsZ0NBQWdDLEdBQUdDLENBQUMsR0FBRyxpQ0FBaUMsQ0FBQztFQUNuRjtFQUNBWixTQUFTLEdBQUNDLEtBQUs7RUFDZkMsVUFBVSxHQUFDRCxLQUFLO0FBQ3BCO0FBRUEsU0FBU21CLG9CQUFvQkEsQ0FBQSxFQUFFO0VBQzNCakIsZ0JBQWdCLEdBQUMsQ0FBQztFQUNsQk8sVUFBVSxDQUFDLFNBQVMsQ0FBQztFQUNyQkMsSUFBSSxDQUFFLDREQUE0RCxDQUFDO0VBQ25FQSxJQUFJLENBQUUsMERBQTBELENBQUM7RUFDakVOLGFBQWEsR0FBQyxDQUFDO0VBQ2ZDLFFBQVEsQ0FBQ0MsY0FBYyxDQUFDLFlBQVksQ0FBQyxDQUFDQyxLQUFLLENBQUNDLFVBQVUsR0FBQyxRQUFRO0VBQy9ESCxRQUFRLENBQUNDLGNBQWMsQ0FBQyxlQUFlLENBQUMsQ0FBQ0MsS0FBSyxDQUFDQyxVQUFVLEdBQUMsUUFBUTtBQUN0RSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmFjb25tYW4vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2Z4LmpzP2Y4MzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZnVydGhlciBmeCB0byBjb21lIC0gc2VuZCBhbGwgZ2hvc3RzIHRvIGhvbWUsIGJsb3cgdGhlbSBhbGwgdXAsIHNlbmQgcGFjbWFuIHRvIGNvLW9yZHMgb3IgdG8gYSBwb3dlcnBpbGxcblxuLy8gR2VuZXJpYyBkZWJvdW5jZSB1dGlsaXR5XG4vLyBVc2FnZTogY29uc3QgZGVib3VuY2VkRm4gPSBkZWJvdW5jZShmbiwgd2FpdClcbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZShmbiwgd2FpdCA9IDMwMCkge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGZuLmFwcGx5KHRoaXMsIGFyZ3MpLCB3YWl0KTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlTGVhZGluZyhmbiwgd2FpdCA9IDEwMDApIHtcbiAgICBsZXQgbG9ja2VkID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGxvY2tlZCkgcmV0dXJuO1xuICAgICAgICBsb2NrZWQgPSB0cnVlO1xuICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGxvY2tlZCA9IGZhbHNlOyB9LCB3YWl0KTtcbiAgICB9O1xufVxuLyogUXVpY2sgU3BpbiAqL1xuZnVuY3Rpb24gZWZmZWN0X3F1aWNrX3NwaW4oKXtcbiAgICBtb3Zlc3BlZWQgPSBzcGVlZC0yMDtcbiAgICBnaG9zdHNwZWVkID0gc3BlZWQtMjA7XG4gICAgZWZmZWN0X211c2hyb29tcz0xO1xuICAgIGVmZmVjdFRpbWVyPTYwO1xuICAgIGludmluY2liaWxpdHk9MTtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBhY21hbi10b3BcIikuc3R5bGUuYmFja2dyb3VuZD1cIm9yYW5nZVwiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGFjbWFuLWJvdHRvbVwiKS5zdHlsZS5iYWNrZ3JvdW5kPVwib3JhbmdlXCI7XG4gICAgd2FsbENvbG91cihcIiM2NjAwZmZcIik7XG4gICAgLy9ldmFsIChcImRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYWNtYW4nKS5jbGFzc0xpc3QuYWRkKCdzcGluJylcIik7XG4gICAgZXZhbCAoXCJkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWF6ZScpLmNsYXNzTGlzdC5hZGQoJ3NwaW4nKVwiKTtcbiAgICBmb3IgKGk9MDtpPHRvdGFsX2dob3N0cztpKyspe1xuICAgICAgICBldmFsIChcImRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnaG9zdFwiICsgaSArIFwiJykuY2xhc3NMaXN0LmFkZCgnc3BpbicpXCIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZWZmZWN0X3F1aWNrX3NwaW5fd2Fybigpe1xuICAgIGV2YWwgKFwiZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21hemUnKS5jbGFzc0xpc3QucmVtb3ZlKCdzcGluJylcIik7XG4gICAgZXZhbCAoXCJkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWF6ZScpLmNsYXNzTGlzdC5hZGQoJ3NwaW4nKVwiKTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0X3F1aWNrX3NwaW5fZW5kKCl7XG4gICAgZWZmZWN0X211c2hyb29tcz0wO1xuICAgIHdhbGxDb2xvdXIoXCIjMzMwMGZmXCIpO1xuICAgIGV2YWwgKFwiZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhY21hbicpLmNsYXNzTGlzdC5yZW1vdmUoJ3NwaW4nKVwiKTtcbiAgICBldmFsIChcImRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYXplJykuY2xhc3NMaXN0LnJlbW92ZSgnc3BpbicpXCIpO1xuICAgIGZvcihpPTA7aTx0b3RhbF9naG9zdHM7aSsrKXtcbiAgICAgICAgZXZhbCAoXCJkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2hvc3RcIiArIGkgKyBcIicpLmNsYXNzTGlzdC5yZW1vdmUoJ3NwaW4nKVwiKTtcbiAgICB9XG4gICAgbW92ZXNwZWVkPXNwZWVkO1xuICAgIGdob3N0c3BlZWQ9c3BlZWQ7XG4gICAgaW52aW5jaWJpbGl0eT0wO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGFjbWFuLXRvcFwiKS5zdHlsZS5iYWNrZ3JvdW5kPVwieWVsbG93XCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwYWNtYW4tYm90dG9tXCIpLnN0eWxlLmJhY2tncm91bmQ9XCJ5ZWxsb3dcIjtcbn1cblxuLyogTG9uZyBzcGluICovXG5cbmZ1bmN0aW9uIGVmZmVjdF9sb25nX3NwaW4oKXtcbiAgICBtb3Zlc3BlZWQgPSBzcGVlZC0yMDtcbiAgICBnaG9zdHNwZWVkID0gc3BlZWQtMjA7XG4gICAgZWZmZWN0X211c2hyb29tcz0xO1xuICAgIGVmZmVjdFRpbWVyPTE1MDtcbiAgICBpbnZpbmNpYmlsaXR5PTE7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwYWNtYW4tdG9wXCIpLnN0eWxlLmJhY2tncm91bmQ9XCJvcmFuZ2VcIjtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBhY21hbi1ib3R0b21cIikuc3R5bGUuYmFja2dyb3VuZD1cIm9yYW5nZVwiO1xuICAgIHdhbGxDb2xvdXIoXCIjNjYwMGZmXCIpO1xuICAgIGV2YWwgKFwiZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhY21hbicpLmNsYXNzTGlzdC5hZGQoJ3NwaW4nKVwiKTtcbiAgICBldmFsIChcImRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYXplJykuY2xhc3NMaXN0LmFkZCgnbG9uZ3NwaW4nKVwiKTtcbiAgICBmb3IgKGk9MDtpPHRvdGFsX2dob3N0cztpKyspe1xuICAgICAgICBldmFsIChcImRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnaG9zdFwiICsgaSArIFwiJykuY2xhc3NMaXN0LmFkZCgnc3BpbicpXCIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZWZmZWN0X2xvbmdfc3Bpbl93YXJuKCl7XG4gICAgZXZhbCAoXCJkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWF6ZScpLmNsYXNzTGlzdC5yZW1vdmUoJ2xvbmdzcGluJylcIik7XG4gICAgZXZhbCAoXCJkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWF6ZScpLmNsYXNzTGlzdC5hZGQoJ3NwaW4nKVwiKTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0X2xvbmdfc3Bpbl9lbmQoKXtcbiAgICBlZmZlY3RfbXVzaHJvb21zPTA7XG4gICAgd2FsbENvbG91cihcIiMzMzAwZmZcIik7XG4gICAgZXZhbCAoXCJkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFjbWFuJykuY2xhc3NMaXN0LnJlbW92ZSgnc3BpbicpXCIpO1xuICAgIGV2YWwgKFwiZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21hemUnKS5jbGFzc0xpc3QucmVtb3ZlKCdzcGluJylcIik7XG4gICAgZm9yKGk9MDtpPHRvdGFsX2dob3N0cztpKyspe1xuICAgICAgICBldmFsIChcImRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnaG9zdFwiICsgaSArIFwiJykuY2xhc3NMaXN0LnJlbW92ZSgnc3BpbicpXCIpO1xuICAgIH1cbiAgICBtb3Zlc3BlZWQ9c3BlZWQ7XG4gICAgZ2hvc3RzcGVlZD1zcGVlZDtcbiAgICBpbnZpbmNpYmlsaXR5PTA7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwYWNtYW4tdG9wXCIpLnN0eWxlLmJhY2tncm91bmQ9XCJ5ZWxsb3dcIjtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBhY21hbi1ib3R0b21cIikuc3R5bGUuYmFja2dyb3VuZD1cInllbGxvd1wiO1xufVxuXG5mdW5jdGlvbiBlZmZlY3RfbXVzaHJvb21zKCl7XG4gICAgbW92ZXNwZWVkID0gc3BlZWQtMjA7XG4gICAgZ2hvc3RzcGVlZCA9IHNwZWVkLTIwO1xuICAgIGVmZmVjdF9tdXNocm9vbXM9MTtcbiAgICBlZmZlY3RUaW1lcj0yNTA7XG4gICAgaW52aW5jaWJpbGl0eT0xO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGFjbWFuLXRvcFwiKS5zdHlsZS5iYWNrZ3JvdW5kPVwib3JhbmdlXCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwYWNtYW4tYm90dG9tXCIpLnN0eWxlLmJhY2tncm91bmQ9XCJvcmFuZ2VcIjtcbiAgICB3YWxsQ29sb3VyKFwiIzY2MDBmZlwiKTtcbiAgICBldmFsIChcImRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYWNtYW4nKS5jbGFzc0xpc3QuYWRkKCdzcGluJylcIik7XG4gICAgZXZhbCAoXCJkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWF6ZScpLmNsYXNzTGlzdC5hZGQoJ3NwaW4nKVwiKTtcbiAgICBmb3IgKGk9MDtpPHRvdGFsX2dob3N0cztpKyspe1xuICAgICAgICBldmFsIChcImRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnaG9zdFwiICsgaSArIFwiJykuY2xhc3NMaXN0LmFkZCgnZmFzdHNwaW4nKVwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGVmZmVjdF9tdXNocm9vbXNfd2Fybigpe1xuICAgIGV2YWwgKFwiZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21hemUnKS5jbGFzc0xpc3QucmVtb3ZlKCdzcGluJylcIik7XG4gICAgZXZhbCAoXCJkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWF6ZScpLmNsYXNzTGlzdC5hZGQoJ3NwaW4nKVwiKTtcbiAgICBldmFsIChcImRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYWNtYW4nKS5jbGFzc0xpc3QucmVtb3ZlKCdzcGluJylcIik7XG4gICAgZm9yKGk9MDtpPHRvdGFsX2dob3N0cztpKyspe1xuICAgICAgICBldmFsIChcImRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnaG9zdFwiICsgaSArIFwiJykuY2xhc3NMaXN0LnJlbW92ZSgnZmFzdHNwaW4nKVwiKTtcbiAgICB9XG4gICAgbW92ZXNwZWVkPXNwZWVkO1xuICAgIGdob3N0c3BlZWQ9c3BlZWQ7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdF9tdXNocm9vbXNfZW5kKCl7XG4gICAgZWZmZWN0X211c2hyb29tcz0wO1xuICAgIHdhbGxDb2xvdXIoXCIjMzMwMGZmXCIpO1xuICAgIGV2YWwgKFwiZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhY21hbicpLmNsYXNzTGlzdC5yZW1vdmUoJ3NwaW4nKVwiKTtcbiAgICBldmFsIChcImRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYXplJykuY2xhc3NMaXN0LnJlbW92ZSgnc3BpbicpXCIpO1xuICAgIGludmluY2liaWxpdHk9MDtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBhY21hbi10b3BcIikuc3R5bGUuYmFja2dyb3VuZD1cInllbGxvd1wiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGFjbWFuLWJvdHRvbVwiKS5zdHlsZS5iYWNrZ3JvdW5kPVwieWVsbG93XCI7XG59Il0sIm5hbWVzIjpbImRlYm91bmNlIiwiZm4iLCJ3YWl0IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwidGltZW91dCIsIl90aGlzIiwiX2xlbiIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYXBwbHkiLCJ0aHJvdHRsZUxlYWRpbmciLCJsb2NrZWQiLCJfbGVuMiIsIl9rZXkyIiwiZWZmZWN0X3F1aWNrX3NwaW4iLCJtb3Zlc3BlZWQiLCJzcGVlZCIsImdob3N0c3BlZWQiLCJlZmZlY3RfbXVzaHJvb21zIiwiZWZmZWN0VGltZXIiLCJpbnZpbmNpYmlsaXR5IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInN0eWxlIiwiYmFja2dyb3VuZCIsIndhbGxDb2xvdXIiLCJldmFsIiwiaSIsInRvdGFsX2dob3N0cyIsImVmZmVjdF9xdWlja19zcGluX3dhcm4iLCJlZmZlY3RfcXVpY2tfc3Bpbl9lbmQiLCJlZmZlY3RfbG9uZ19zcGluIiwiZWZmZWN0X2xvbmdfc3Bpbl93YXJuIiwiZWZmZWN0X2xvbmdfc3Bpbl9lbmQiLCJlZmZlY3RfbXVzaHJvb21zX3dhcm4iLCJlZmZlY3RfbXVzaHJvb21zX2VuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/assets/js/fx.js\n\n}");

/***/ }),

/***/ "./resources/assets/js/game.js":
/*!*************************************!*\
  !*** ./resources/assets/js/game.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings.js */ \"./resources/assets/js/settings.js\");\n/* harmony import */ var _fx_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fx.js */ \"./resources/assets/js/fx.js\");\n/* harmony import */ var _input_handler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./input-handler.js */ \"./resources/assets/js/input-handler.js\");\n/* harmony import */ var _map_renderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map-renderer.js */ \"./resources/assets/js/map-renderer.js\");\n/* harmony import */ var _player_entity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./player-entity.js */ \"./resources/assets/js/player-entity.js\");\n/* harmony import */ var _ghost_entity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ghost-entity.js */ \"./resources/assets/js/ghost-entity.js\");\n/* harmony import */ var pathfinding__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! pathfinding */ \"./node_modules/pathfinding/index.js\");\n/* harmony import */ var pathfinding__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(pathfinding__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _entity_art_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./entity-art.js */ \"./resources/assets/js/entity-art.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _collectible_entity_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./collectible-entity.js */ \"./resources/assets/js/collectible-entity.js\");\n/* harmony import */ var _collectible_spawner_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./collectible-spawner.js */ \"./resources/assets/js/collectible-spawner.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\n\n // Import PathFinding.js\n\n\n\n\n\n// Main game coordination using modular architecture\nvar Game = /*#__PURE__*/function () {\n  function Game() {\n    var _this = this;\n    _classCallCheck(this, Game);\n    _defineProperty(this, \"ghosts\", []);\n    this.canvas = null;\n    this.mapRenderer = null;\n    this.inputHandler = null;\n    this.gameState = 'welcome'; // welcome, stopped, playing, paused\n    this.currentMap = null;\n    this.player = null;\n\n    // Game elements initialized from settings\n    this.score = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].score;\n    this.lives = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lives;\n    this.level = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].level;\n    this.moveInc = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].moveInc;\n    this.speed = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].speed;\n    this.gameTime = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].gameTime;\n    this.mazeSource = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mazeSource;\n    this.basicVision = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].basicVision;\n    this.resetModeOnResetGame = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].resetModeOnResetGame;\n    this.excludeReverseDirectionInRandomMode = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].excludeReverseDirectionInRandomMode;\n    this.fx = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fx;\n    this.extras = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extras;\n    this.maxGhosts = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] && _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].maxGhosts || 3;\n\n    // Input handler: dump all input to console\n    this.inputHandler = new _input_handler_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n    this.inputHandler.setCallbacks({\n      onDirectionChange: function onDirectionChange(dir) {\n        return console.log('Direction:', dir);\n      },\n      onKeyPress: function (code, event) {\n        // Intercept Enter/Return for all platforms\n        code = code.toLowerCase();\n        if ((code === 'enter' || code === 'numpadenter' || code === 'return') && this.gameState === 'welcome') {\n          // Start the game\n          this.gameState = 'playing';\n          // Optionally: re-init player, collectibles, etc.\n          console.log('start that audio.');\n          return;\n        }\n        console.log(code);\n        console.log(this.gameState);\n      }.bind(this),\n      onPause: function onPause() {\n        return console.log('Pause requested');\n      },\n      onReset: function onReset() {\n        return console.log('Reset requested');\n      }\n    });\n\n    // Initialize when DOM is ready\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', function () {\n        return _this.init();\n      });\n    } else {\n      this.init();\n    }\n\n    // Add event emitter for tile events\n    this.tileEventEmitter = new TileEventEmitter();\n    this.ghostReleaseTimer = 0;\n    this.ghostReleaseInterval = 200; // frames between releases (adjustable)\n    this.ghostPool = _toConsumableArray(_entity_art_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].ghosts); // All possible ghosts\n    this.activeGhosts = []; // Ghosts currently in play\n    this.collisionEmitter = new (events__WEBPACK_IMPORTED_MODULE_8___default())();\n    this.ghostPenTimers = new Map(); // Track time each ghost spends in pen\n    this.ghostExitTimers = new Map(); // Track how long a ghost has been trying to exit\n    this.ghostExitTimeout = 2 * 60; // 2 seconds at 60fps\n    // Ghost pen timeout (in frames, from settings)\n    this.ghostPenTimeout = (_settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ghostPenTimeout || 2) * 60;\n    this.collisionCooldowns = new Map(); // Track entity collision cooldowns\n    this.collisionCooldownFrames = 30; // Half a second at 60fps\n\n    // Portal teleportation cooldowns to prevent loops\n    this.portalCooldowns = new Map(); // Track entity portal usage\n    this.portalCooldownFrames = 30; // Half second cooldown after teleport\n\n    // Listen for superdot pickup events\n    this.tileEventEmitter.on(function (event) {\n      if (event.type === 'superdot') {\n        console.log('Superdot event triggered:', event);\n        // Set player super state\n        if (_this.player && typeof _this.player.setSuperState === 'function') {\n          _this.player.setSuperState(true);\n          setTimeout(function () {\n            _this.player.setSuperState(false);\n          }, (_settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].megaPelletDuration || 5) * 1000);\n        }\n        // For each ghost not in pen, pick a random destination away from player\n        var player = _this.player;\n        var ghosts = _this.ghosts || [];\n        var mapData = _this.mapRenderer.mapData;\n        var minDistance = 6; // tiles away from player\n        var usedSpots = new Set();\n        ghosts.forEach(function (ghost, idx) {\n          if (ghost.state !== 'in_pen' && ghost.state !== 'exiting') {\n            var tries = 0;\n            var dest;\n            do {\n              var angle = Math.random() * 2 * Math.PI;\n              var dist = minDistance + Math.floor(Math.random() * 4) + idx;\n              var col = Math.max(1, Math.min(mapData[0].length - 2, player.col + Math.round(Math.cos(angle) * dist)));\n              var row = Math.max(1, Math.min(mapData.length - 2, player.row + Math.round(Math.sin(angle) * dist)));\n              dest = {\n                col: col,\n                row: row\n              };\n              tries++;\n            } while ((mapData[dest.row][dest.col] !== _this.mapRenderer.TILES.EMPTY || usedSpots.has(\"\".concat(dest.col, \",\").concat(dest.row))) && tries < 10);\n            usedSpots.add(\"\".concat(dest.col, \",\").concat(dest.row));\n            ghost.setDestination(dest, mapData);\n            // Immediately update ghost direction and path\n            if (typeof ghost.moveToDestination === 'function') {\n              ghost.pathStep = 1;\n              ghost.moveToDestination();\n            }\n          }\n        });\n      }\n    });\n  }\n\n  /**\n   * Initialize the game\n   */\n  return _createClass(Game, [{\n    key: \"init\",\n    value: function init() {\n      this.canvas = document.getElementById('gameCanvas');\n      if (!this.canvas) {\n        console.error('Game canvas not found');\n        return;\n      }\n      this.gameState = 'welcome';\n\n      // --- Maze rendering integration ---\n      var csv = window.laraconmanMazeCsv;\n      if (csv) {\n        var _mapArray$;\n        // Parse CSV and load into MapRenderer\n        var mapArray = Game.parseAndAdaptMazeCsv(csv);\n        var width = ((_mapArray$ = mapArray[0]) === null || _mapArray$ === void 0 ? void 0 : _mapArray$.length) || 0;\n        var height = mapArray.length;\n        this.mapRenderer = new _map_renderer_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.canvas);\n        // MapRenderer expects CSV string, so rejoin for compatibility\n        var normalizedCsv = mapArray.map(function (row) {\n          return row.join(',');\n        }).join('\\n');\n        this.mapRenderer.loadMap(normalizedCsv, width, height);\n        this.mapRenderer.render();\n        this.initPlayer(this.mapRenderer.mapData, this.mapRenderer.tileSize);\n        this.initCollectibles();\n        this.initEventListeners();\n        this.gameLoop();\n      }\n      console.log('Game initialized');\n    }\n  }, {\n    key: \"initCollectibles\",\n    value: function initCollectibles() {\n      // Use the map and tile types from mapRenderer\n      var mapData = this.mapRenderer.mapData;\n      var tileTypes = this.mapRenderer.TILES;\n      var spawner = new _collectible_spawner_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"](mapData, tileTypes);\n      var _spawner$spawnCollect = spawner.spawnCollectibles(),\n        superdots = _spawner$spawnCollect.superdots,\n        dots = _spawner$spawnCollect.dots,\n        fruit = _spawner$spawnCollect.fruit;\n      this.dots = dots;\n      this.fruit = fruit;\n      this.superdots = superdots;\n    }\n  }, {\n    key: \"initEventListeners\",\n    value: function initEventListeners() {\n      var _this2 = this;\n      this.collisionEmitter.on('collision-consumable', function (_ref) {\n        var player = _ref.player,\n          consumed = _ref.consumed;\n        if (!consumed || !consumed.type) {\n          return;\n        }\n        _this2.setScore(_this2.getScore() + consumed.options.points);\n        // Remove dot from this.dots if it is a dot\n        if (consumed.type === _this2.mapRenderer.TILES.DOT) {\n          _this2.dots = _this2.dots.filter(function (dot) {\n            return !(dot.col === consumed.col && dot.row === consumed.row);\n          });\n          return;\n        } else if (consumed.type === _this2.mapRenderer.TILES.SUPER_DOT) {\n          _this2.superdots = _this2.superdots.filter(function (dot) {\n            return !(dot.col === consumed.col && dot.row === consumed.row);\n          });\n          if (_this2.mapRenderer && _this2.mapRenderer.mapData) {\n            _this2.mapRenderer.mapData[consumed.row][consumed.col] = _this2.mapRenderer.TILES.EMPTY;\n          }\n          if (player && typeof player.setSuperState === 'function') {\n            player.setSuperState(true);\n            setTimeout(function () {\n              player.setSuperState(false);\n            }, (_settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].megaPelletDuration || 5) * 1000);\n            console.log('user is a super dot!');\n          } else {\n            console.log('fn or player no exist.');\n          }\n        } else if (consumed.type === _this2.mapRenderer.TILES.FRUIT) {\n          console.log('its a fruit!');\n          _this2.fruit = _this2.fruit.filter(function (fruit) {\n            return !(fruit.col === consumed.col && fruit.row === consumed.row);\n          });\n        }\n      });\n      // Add default event handlers for collisions\n      this.collisionEmitter.on('collision-ghost', function (_ref2) {\n        var player = _ref2.player,\n          ghost = _ref2.ghost;\n        console.log('Player collided with ghost:', ghost.displayName || ghost.color);\n      });\n\n      // Debounced player-eaten event handler\n      this.collisionEmitter.on('player-eaten', (0,_fx_js__WEBPACK_IMPORTED_MODULE_1__.throttleLeading)(function (_ref3) {\n        var player = _ref3.player,\n          ghost = _ref3.ghost;\n        // Animate player death, decrement lives, respawn player\n        _this2.lives -= 1;\n        if (player && typeof player.die === 'function') {\n          player.die();\n        }\n        _this2.gameState = 'stopped';\n        _this2.updateUI && _this2.updateUI();\n        if (_this2.lives > 0) {\n          if (typeof _this2.initPlayer === 'function') {\n            _this2.initPlayer(_this2.mapRenderer.mapData, _this2.mapRenderer.tileSize);\n            _this2.inputHandler.setCallbacks({\n              onDirectionChange: function onDirectionChange(dir) {\n                return _this2.player.setDirection(dir);\n              }\n            });\n          }\n          _this2.gameState = 'playing';\n        } else {\n          _this2.gameState = 'stopped';\n          _this2.updateUI && _this2.updateUI();\n        }\n        console.log(_this2.gameState);\n      }, 1500));\n      this.collisionEmitter.on('ghost-eaten', function (_ref4) {\n        var player = _ref4.player,\n          ghost = _ref4.ghost,\n          points = _ref4.points;\n        // Example: Animate ghost death, award points\n        if (ghost && typeof ghost.die === 'function') {\n          ghost.die(); // You may want to implement this\n        }\n        // Banish ghost to pen (set to first GHOST_SPAWN tile found)\n        var map = _this2.mapRenderer.mapData;\n        var found = false;\n        for (var r = 0; r < map.length && !found; r++) {\n          for (var c = 0; c < map[0].length && !found; c++) {\n            if (map[r][c] === _this2.mapRenderer.TILES.GHOST_SPAWN) {\n              ghost.col = c;\n              ghost.row = r;\n              ghost.x = c * _this2.mapRenderer.tileSize;\n              ghost.y = r * _this2.mapRenderer.tileSize;\n              ghost.state = 'in_pen';\n              found = true;\n              break;\n            }\n          }\n        }\n        _this2.score += points;\n        _this2.updateUI && _this2.updateUI();\n      });\n    }\n\n    /**\n     * Utility: Parse and adapt CSV maze data from Blade\n     * Converts pass-through tunnel (4) to renderer's tunnel (5) if needed\n     */\n  }, {\n    key: \"setupUI\",\n    value:\n    /**\n     * Set up UI event listeners\n     */\n    function setupUI() {\n      var _this3 = this;\n      var startBtn = document.getElementById('startBtn');\n      var pauseBtn = document.getElementById('pauseBtn');\n      var resetBtn = document.getElementById('resetBtn');\n      if (startBtn) {\n        startBtn.addEventListener('click', function () {\n          return _this3.startGame();\n        });\n      }\n      if (pauseBtn) {\n        pauseBtn.addEventListener('click', function () {\n          return _this3.togglePause();\n        });\n      }\n      if (resetBtn) {\n        resetBtn.addEventListener('click', function () {\n          return _this3.resetGame();\n        });\n      }\n    }\n\n    /**\n     * Load map data from DOM (passed from PHP)\n     */\n  }, {\n    key: \"loadMapFromDOM\",\n    value: function loadMapFromDOM() {\n      // Look for map data in a script tag or data attribute\n      var mapDataScript = document.getElementById('mapData');\n      if (mapDataScript) {\n        try {\n          this.currentMap = JSON.parse(mapDataScript.textContent);\n          this.loadMap(this.currentMap);\n        } catch (e) {\n          console.error('Failed to parse map data:', e);\n        }\n      } else {\n        // Fallback: look for global window variable\n        if (window.gameMapData) {\n          this.currentMap = window.gameMapData;\n          this.loadMap(this.currentMap);\n        } else {\n          console.warn('No map data found. Using test map.');\n          this.loadTestMap();\n        }\n      }\n    }\n\n    /**\n     * Load a map into the renderer\n     * @param {object} mapData - Map data from database\n     */\n  }, {\n    key: \"loadMap\",\n    value: function loadMap(mapData) {\n      if (!mapData || !mapData.design) {\n        console.error('Invalid map data');\n        return;\n      }\n      console.log('Loading map:', mapData.name);\n\n      // Load map into renderer\n      this.mapRenderer.loadMap(mapData.design, mapData.width, mapData.height);\n\n      // Render the map\n      this.mapRenderer.render();\n\n      // Update UI\n      this.updateUI();\n    }\n\n    /**\n     * Load a test map for development\n     */\n  }, {\n    key: \"loadTestMap\",\n    value: function loadTestMap() {\n      var testMap = {\n        name: 'Test Map',\n        width: 19,\n        height: 21,\n        design: \"1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\\n1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1\\n1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1\\n1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1\\n1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,2,1\\n1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1\\n1,1,1,1,2,1,1,1,0,1,0,1,1,1,2,1,1,1,1\\n0,0,0,1,2,1,0,0,0,0,0,0,0,1,2,1,0,0,0\\n1,1,1,1,2,1,0,1,3,3,3,1,0,1,2,1,1,1,1\\n4,0,0,0,2,0,0,1,0,0,0,1,0,0,2,0,0,0,4\\n1,1,1,1,2,1,0,1,1,1,1,1,0,1,2,1,1,1,1\\n0,0,0,1,2,1,0,0,0,0,0,0,0,1,2,1,0,0,0\\n1,1,1,1,2,1,1,1,0,1,0,1,1,1,2,1,1,1,1\\n1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1\\n1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1\\n1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1\\n1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1\\n1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1\\n1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1\\n1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1\\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\"\n      };\n      this.currentMap = testMap;\n      this.loadMap(testMap);\n    }\n\n    /**\n     * Start the game\n     */\n  }, {\n    key: \"startGame\",\n    value: function startGame() {\n      if (this.gameState === 'stopped') {\n        this.gameState = 'playing';\n        this.updateUI();\n        console.log('Game started');\n\n        // TODO: Initialize player and ghosts\n      } else if (this.gameState === 'paused') {\n        this.gameState = 'playing';\n        this.updateUI();\n        console.log('Game resumed');\n      }\n    }\n\n    /**\n     * Toggle pause state\n     */\n  }, {\n    key: \"togglePause\",\n    value: function togglePause() {\n      if (this.gameState === 'playing') {\n        this.gameState = 'paused';\n        console.log('Game paused');\n      } else if (this.gameState === 'paused') {\n        this.gameState = 'playing';\n        console.log('Game resumed');\n      }\n      this.updateUI();\n    }\n\n    /**\n     * Reset the game\n     */\n  }, {\n    key: \"resetGame\",\n    value: function resetGame() {\n      this.gameState = 'stopped';\n      this.score = 0;\n      this.lives = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lives;\n\n      // Reset input handler\n      this.inputHandler.reset();\n\n      // Reload current map\n      if (this.currentMap) {\n        this.loadMap(this.currentMap);\n      }\n      this.updateUI();\n      console.log('Game reset');\n    }\n\n    /**\n     * Handle direction changes from input\n     * @param {string} direction - New movement direction\n     */\n  }, {\n    key: \"handleDirectionChange\",\n    value: function handleDirectionChange(direction) {\n      if (this.gameState !== 'playing') return;\n      console.log('Direction changed:', direction);\n      // TODO: Update player movement direction\n    }\n\n    /**\n     * Update UI elements\n     */\n  }, {\n    key: \"updateUI\",\n    value: function updateUI() {\n      // Update score\n      var scoreElement = document.getElementById('score');\n      if (scoreElement) {\n        scoreElement.textContent = this.score;\n      }\n\n      // Update lives\n      var livesElement = document.getElementById('lives');\n      if (livesElement) {\n        livesElement.textContent = this.lives;\n      }\n\n      // Update button states\n      var startBtn = document.getElementById('startBtn');\n      var pauseBtn = document.getElementById('pauseBtn');\n      if (startBtn) {\n        startBtn.textContent = this.gameState === 'stopped' ? 'Start Game' : 'Resume';\n        startBtn.disabled = this.gameState === 'playing';\n      }\n      if (pauseBtn) {\n        pauseBtn.textContent = this.gameState === 'paused' ? 'Resume' : 'Pause';\n        pauseBtn.disabled = this.gameState === 'stopped';\n      }\n    }\n\n    /**\n     * Get current game state\n     * @returns {string} Current game state\n     */\n  }, {\n    key: \"getGameState\",\n    value: function getGameState() {\n      return this.gameState;\n    }\n\n    /**\n     * Get current map data\n     * @returns {object} Current map data\n     */\n  }, {\n    key: \"getCurrentMap\",\n    value: function getCurrentMap() {\n      return this.currentMap;\n    }\n\n    /**\n     * Initialize player entity\n     * @param {array} mapData - Map data\n     * @param {number} tileSize - Tile size\n     */\n  }, {\n    key: \"initPlayer\",\n    value: function initPlayer(mapData, tileSize) {\n      var _this4 = this;\n      // Find ghost pen tiles\n      var penTiles = [];\n      for (var r = 0; r < mapData.length; r++) {\n        for (var c = 0; c < mapData[0].length; c++) {\n          if (mapData[r][c] === this.mapRenderer.TILES.GHOST_SPAWN) {\n            penTiles.push({\n              col: c,\n              row: r\n            });\n          }\n        }\n      }\n      // Find center-most tile below the pen that is EMPTY\n      var playerStart = {\n        col: 1,\n        row: 1\n      };\n      if (penTiles.length > 0) {\n        // Compute center col of pen\n        var penCols = penTiles.map(function (t) {\n          return t.col;\n        });\n        var penRows = penTiles.map(function (t) {\n          return t.row;\n        });\n        var minCol = Math.min.apply(Math, _toConsumableArray(penCols)),\n          maxCol = Math.max.apply(Math, _toConsumableArray(penCols));\n        var maxRow = Math.max.apply(Math, _toConsumableArray(penRows)); // <--- added this line\n        var centerCol = Math.round((minCol + maxCol) / 2);\n        // Search downward from just below pen, only at centerCol\n        for (var _r = maxRow + 1; _r < mapData.length - 1; _r++) {\n          if (mapData[_r][centerCol] === this.mapRenderer.TILES.EMPTY) {\n            playerStart = {\n              col: centerCol,\n              row: _r\n            };\n            break;\n          }\n        }\n      } else {\n        // fallback to old logic\n        outer: for (var _r2 = 1; _r2 < mapData.length - 1; _r2++) {\n          for (var _c = 1; _c < mapData[0].length - 1; _c++) {\n            if (mapData[_r2][_c] === 0) {\n              playerStart = {\n                col: _c,\n                row: _r2\n              };\n              break outer;\n            }\n          }\n        }\n      }\n      var speed = 2;\n      this.player = new _player_entity_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](playerStart.col, playerStart.row, tileSize, mapData, _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n      if (this.inputHandler && typeof this.inputHandler.setCallbacks === 'function') {\n        this.inputHandler.setCallbacks({\n          onDirectionChange: function onDirectionChange(dir) {\n            if (_this4.player) _this4.player.setDirection(dir);\n          }\n        });\n      }\n    }\n\n    /**\n     * --- COLLISION DETECTION: ALL COLLISION LOGIC HERE ---\n     * Check for item collision and emit event\n     */\n  }, {\n    key: \"checkCollisions\",\n    value: function checkCollisions(entity) {\n      // Ghost collision\n      var _iterator = _createForOfIteratorHelper(this.ghosts),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var ghost = _step.value;\n          if (ghost.col === entity.col && ghost.row === entity.row) {\n            if (entity.state == 'normal') {\n              // Player is not super: lose a life, respawn, etc.\n              var points = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].playerDeathPoints || 0; // Usually 0 for player death\n              this.collisionEmitter.emit('player-eaten', {\n                player: entity,\n                ghost: ghost,\n                points: points\n              });\n            } else {\n              var _ghost$options;\n              // Player is super: eat the ghost, award points\n              var _points = ((_ghost$options = ghost.options) === null || _ghost$options === void 0 ? void 0 : _ghost$options.points) || _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ghostPoints || 200;\n              this.collisionEmitter.emit('ghost-eaten', {\n                player: entity,\n                ghost: ghost,\n                points: _points\n              });\n              this.score += _points;\n            }\n            this.updateUI && this.updateUI();\n            return;\n          }\n        }\n        // Fruit collision\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _iterator2 = _createForOfIteratorHelper(this.fruit || []),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var fruit = _step2.value;\n          if (fruit.col === entity.col && fruit.row === entity.row) {\n            fruit.type = this.mapRenderer.TILES.FRUIT;\n            this.collisionEmitter.emit('collision-consumable', {\n              player: entity,\n              consumed: fruit\n            });\n            return;\n          }\n        }\n        // Dot collision\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      for (var i = this.dots.length - 1; i >= 0; i--) {\n        var sprite = this.dots[i];\n        if (sprite.col === entity.col && sprite.row === entity.row) {\n          // Handle dot collision (fire event, remove dot, etc.)\n          sprite.type = this.mapRenderer.TILES.DOT;\n          this.collisionEmitter.emit('collision-consumable', {\n            player: entity,\n            consumed: sprite\n          });\n          return;\n        }\n      }\n      // Superdot collision\n      if (this.superdots && this.superdots.length) {\n        for (var _i = this.superdots.length - 1; _i >= 0; _i--) {\n          var _sprite = this.superdots[_i];\n          if (_sprite.col === entity.col && _sprite.row === entity.row) {\n            //                    console.log('superdot collision');\n            // Handle superdot collision\n            _sprite.type = this.mapRenderer.TILES.SUPER_DOT;\n            this.collisionEmitter.emit('collision-consumable', {\n              player: entity,\n              consumed: _sprite\n            });\n            return;\n          }\n        }\n      }\n\n      // Portal collision\n      var tile = this.mapRenderer.mapData[entity.row][entity.col];\n      if (tile === this.mapRenderer.TILES.PORTAL) {\n        var entityType = entity.type;\n        var portalKey = \"\".concat(entityType, \":portal:\").concat(entity.col, \",\").concat(entity.row);\n        var cooldown = this.portalCooldowns.get(portalKey) || 0;\n        if (cooldown === 0) {\n          var dest = this.findOppositePortal(entity.col, entity.row);\n          if (dest) {\n            // Set cooldown for both entry and exit portal\n            var destKey = \"\".concat(entityType, \":portal:\").concat(dest.col, \",\").concat(dest.row);\n            this.portalCooldowns.set(portalKey, this.portalCooldownFrames);\n            this.portalCooldowns.set(destKey, this.portalCooldownFrames);\n            // Move entity one block away from portal exit toward map center\n            var dCol = 0,\n              dRow = 0;\n            var centerCol = Math.floor(this.mapRenderer.mapData[0].length / 2);\n            if (dest.col < centerCol) dCol = 1;else if (dest.col > centerCol) dCol = -1;\n            // If vertical tunnel, bias row\n            var centerRow = Math.floor(this.mapRenderer.mapData.length / 2);\n            if (dest.row < centerRow) dRow = 1;else if (dest.row > centerRow) dRow = -1;\n            var newCol = dest.col + dCol;\n            var newRow = dest.row + dRow;\n            // Only move if new tile is walkable\n            var walkable = [this.mapRenderer.TILES.EMPTY, this.mapRenderer.TILES.DOT, this.mapRenderer.TILES.SUPER_DOT];\n            if (newCol >= 0 && newCol < this.mapRenderer.mapData[0].length && newRow >= 0 && newRow < this.mapRenderer.mapData.length && walkable.includes(this.mapRenderer.mapData[newRow][newCol])) {\n              this.teleportEntity(entity, {\n                col: newCol,\n                row: newRow\n              });\n              // Set cooldown for the ejection tile as well\n              var ejectionKey = \"\".concat(entityType, \":portal:\").concat(newCol, \",\").concat(newRow);\n              this.portalCooldowns.set(ejectionKey, this.portalCooldownFrames);\n            } else {\n              this.teleportEntity(entity, dest);\n            }\n            // Emit appropriate event\n            var col = entity.col,\n              row = entity.row;\n            if (entityType === 'player') {\n              if (dCol !== 0) col += dCol;\n              this.collisionEmitter.emit('player-portal', {\n                player: entity,\n                from: {\n                  col: col,\n                  row: row\n                },\n                to: dest\n              });\n            } else if (entityType === 'ghost') {\n              this.collisionEmitter.emit('ghost-portal', {\n                ghost: entity,\n                from: {\n                  col: col,\n                  row: row\n                },\n                to: dest\n              });\n              entity.destination = null;\n              entity.path = null;\n              entity.pathStep = 0;\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Spawn a ghost at a random ghost spawn tile INSIDE THE PEN\n     */\n  }, {\n    key: \"spawnGhost\",\n    value: function spawnGhost() {\n      if (this.ghosts.length >= this.maxGhosts) return;\n\n      // Find all ghost spawn tiles inside the pen (classic: 2 rows x 4 cols above door)\n      var spawns = [];\n      var data = this.mapRenderer.mapData;\n      for (var r = 0; r < data.length; r++) {\n        for (var c = 0; c < data[0].length; c++) {\n          if (data[r][c] === this.mapRenderer.TILES.GHOST_SPAWN) spawns.push({\n            col: c,\n            row: r\n          });\n        }\n      }\n      if (spawns.length === 0) return;\n      // Pick a random pen tile for each new ghost\n      var idx = Math.floor(Math.random() * spawns.length);\n      var spawn = spawns[idx];\n      var usedNames = this.activeGhosts.map(function (g) {\n        return g.name;\n      });\n      var available = this.ghostPool.filter(function (g) {\n        return !usedNames.includes(g.name);\n      });\n      if (available.length === 0 || this.ghosts.length >= this.maxGhosts) return;\n      var ghostConfig = available[Math.floor(Math.random() * available.length)];\n      var ghostSpeed = 2;\n      var ghostColor = ghostConfig.color || '#FF0000';\n      var ghost = new _ghost_entity_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](spawn.col, spawn.row, this.mapRenderer.tileSize, this.mapRenderer.mapData, ghostSpeed, ghostColor, this.mapRenderer.TILES);\n      ghost.image = ghostConfig.image;\n      ghost.displayName = ghostConfig.name;\n      this.ghosts.push(ghost);\n      this.activeGhosts.push(ghostConfig);\n    }\n\n    /**\n     * Move ghosts with pathfinding to a random destination outside the pen\n     */\n  }, {\n    key: \"moveGhosts\",\n    value: function moveGhosts() {\n      var _this5 = this;\n      if (this.gameState == 'stopped') {\n        return;\n      }\n      var data = this.mapRenderer.mapData;\n      var penTiles = [];\n      for (var r = 0; r < data.length; r++) {\n        for (var c = 0; c < data[0].length; c++) {\n          if (data[r][c] === this.mapRenderer.TILES.GHOST_SPAWN) penTiles.push(\"\".concat(c, \",\").concat(r));\n        }\n      }\n      var _iterator3 = _createForOfIteratorHelper(this.ghosts),\n        _step3;\n      try {\n        var _loop = function _loop() {\n          var ghost = _step3.value;\n          if (ghost.state === 'in_pen') {\n            // Move randomly within pen\n            var dirs = ['up', 'down', 'left', 'right'].filter(function (dir) {\n              return ghost.canMove(dir);\n            });\n            if (dirs.length > 0) {\n              var dir = dirs[Math.floor(Math.random() * dirs.length)];\n              ghost.setDirection(dir);\n            }\n            // Fallback: force-evict after timeout\n            var t = _this5.ghostPenTimers.get(ghost) || 0;\n            _this5.ghostPenTimers.set(ghost, t + 1);\n            if (t + 1 > _this5.ghostPenTimeout) {\n              ghost.setState('exiting');\n              _this5.ghostPenTimers[\"delete\"](ghost);\n              // Pick a destination OUTSIDE the pen ONLY if not already set\n              if (!ghost.destination) {\n                var candidates = [];\n                for (var _r3 = 0; _r3 < data.length; _r3++) {\n                  for (var _c2 = 0; _c2 < data[0].length; _c2++) {\n                    var tile = data[_r3][_c2];\n                    if ((tile === _this5.mapRenderer.TILES.EMPTY || tile === _this5.mapRenderer.TILES.DOT || tile === _this5.mapRenderer.TILES.SUPER_DOT) && !penTiles.includes(\"\".concat(_c2, \",\").concat(_r3)) && !(ghost.col === _c2 && ghost.row === _r3)) {\n                      candidates.push({\n                        col: _c2,\n                        row: _r3\n                      });\n                    }\n                  }\n                }\n                if (candidates.length > 0) {\n                  var dest = candidates[Math.floor(Math.random() * candidates.length)];\n                  ghost.setDestination(dest, data);\n                }\n              }\n              ghost.moveToDestination();\n            } else {\n              ghost.move();\n            }\n          } else if (ghost.state === 'exiting') {\n            // Always move to destination if exiting\n            ghost.moveToDestination();\n            if (ghost.atDestination() && !penTiles.includes(\"\".concat(ghost.col, \",\").concat(ghost.row))) {\n              ghost.setState('active');\n            }\n          } else if (ghost.state === 'active') {\n            // If ghost is active and has no destination or has reached its destination, pick a new one\n            if (!ghost.destination || ghost.atDestination()) {\n              var _candidates = [];\n              for (var _r4 = 0; _r4 < data.length; _r4++) {\n                for (var _c3 = 0; _c3 < data[0].length; _c3++) {\n                  var _tile = data[_r4][_c3];\n                  if ((_tile === _this5.mapRenderer.TILES.EMPTY || _tile === _this5.mapRenderer.TILES.DOT || _tile === _this5.mapRenderer.TILES.SUPER_DOT) && !penTiles.includes(\"\".concat(_c3, \",\").concat(_r4))) {\n                    _candidates.push({\n                      col: _c3,\n                      row: _r4\n                    });\n                  }\n                }\n              }\n              if (_candidates.length > 0) {\n                var _dest = _candidates[Math.floor(Math.random() * _candidates.length)];\n                ghost.setDestination(_dest, data);\n              }\n            }\n            ghost.moveToDestination();\n          } else {\n            _this5.ghostPenTimers[\"delete\"](ghost);\n            ghost.move();\n          }\n        };\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n\n    /**\n     * Game loop\n     */\n  }, {\n    key: \"gameLoop\",\n    value:\n    /**\n     * Game loop\n     */\n    function gameLoop() {\n      var _this6 = this;\n      this.mapRenderer.render();\n      this.renderCollectibles(this.mapRenderer.ctx);\n      if (this.player) {\n        this.player.render(this.mapRenderer.ctx);\n        if (this.gameState == 'playing') {\n          this.player.move();\n          this.checkCollisions(this.player);\n        }\n      }\n      if (this.gameState === 'welcome') {\n        this.drawWelcomeScreen();\n      } else if (this.gameState === 'gameover') {\n        alert('f');\n      } else if (this.gameState == 'highscore') {\n        alert('butts');\n      } else {\n        this.moveGhosts();\n        var _iterator4 = _createForOfIteratorHelper(this.ghosts),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var ghost = _step4.value;\n            ghost.render(this.mapRenderer.ctx);\n          }\n\n          // Ghost release logic\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n        this.ghostReleaseTimer++;\n        if (this.ghostReleaseTimer >= this.ghostReleaseInterval) {\n          this.spawnGhost();\n          this.ghostReleaseTimer = 0;\n        }\n\n        // Update collision cooldowns\n        this.updateCollisionCooldowns();\n      }\n      requestAnimationFrame(function () {\n        return _this6.gameLoop();\n      });\n    }\n  }, {\n    key: \"drawWelcomeScreen\",\n    value: function drawWelcomeScreen() {\n      this.drawOverlay('WakaWaka', 'Press Enter to Start');\n    }\n  }, {\n    key: \"drawOverlay\",\n    value: function drawOverlay(title, subtitle) {\n      var ctx = this.mapRenderer.ctx;\n      ctx.save();\n      ctx.globalAlpha = 0.8;\n      ctx.fillStyle = 'black';\n      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n      ctx.globalAlpha = 1.0;\n      ctx.fillStyle = 'white';\n      ctx.font = 'bold 32px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText(title, ctx.canvas.width / 2, ctx.canvas.height / 2 - 20);\n      ctx.font = '24px Arial';\n      ctx.fillText(subtitle, ctx.canvas.width / 2, ctx.canvas.height / 2 + 30);\n      ctx.restore();\n    }\n  }, {\n    key: \"renderCollectibles\",\n    value: function renderCollectibles(ctx) {\n      var _this7 = this;\n      if (this.dots) this.dots.forEach(function (dot) {\n        return dot.render(ctx, _this7.mapRenderer.tileSize);\n      });\n      if (this.fruit) this.fruit.forEach(function (fruit) {\n        return fruit.render(ctx, _this7.mapRenderer.tileSize, _this7.mapRenderer.entityArt);\n      });\n    }\n\n    /**\n     * Get everything at a specific coordinate\n     */\n  }, {\n    key: \"getWhatIsAt\",\n    value: function getWhatIsAt(col, row) {\n      var result = {\n        tile: this.mapRenderer.mapData[row] ? this.mapRenderer.mapData[row][col] : null,\n        entities: []\n      };\n\n      // Check for other entities at this position\n      if (this.player && this.player.col === col && this.player.row === row) {\n        result.entities.push({\n          type: 'player',\n          entity: this.player\n        });\n      }\n      var _iterator5 = _createForOfIteratorHelper(this.ghosts),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var ghost = _step5.value;\n          if (ghost.col === col && ghost.row === row) {\n            result.entities.push({\n              type: 'ghost',\n              entity: ghost\n            });\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      if (this.pellets) {\n        var _iterator6 = _createForOfIteratorHelper(this.pellets),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var pellet = _step6.value;\n            if (pellet.col === col && pellet.row === row) {\n              result.entities.push({\n                type: 'pellet',\n                entity: pellet\n              });\n            }\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      }\n      if (this.fruits) {\n        var _iterator7 = _createForOfIteratorHelper(this.fruits),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var fruit = _step7.value;\n            if (fruit.col === col && fruit.row === row) {\n              result.entities.push({\n                type: 'fruit',\n                entity: fruit\n              });\n            }\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Fire collision events for entity hitting something\n     */\n  }, {\n    key: \"fireCollisionEvents\",\n    value: function fireCollisionEvents(entity, collisions) {\n      var entityType = this.getEntityType(entity);\n\n      // Handle entity vs entity collisions\n      var _iterator8 = _createForOfIteratorHelper(collisions.entities),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var collision = _step8.value;\n          if (collision.entity === entity) continue; // Don't collide with self\n\n          var key = \"\".concat(entityType, \":\").concat(collision.type, \":\").concat(collision.entity.id || collision.entity.displayName || collision.entity.color);\n          if (entityType == 'ghost' && collision.type === 'ghost') {\n            return;\n          }\n          if (entityType === 'ghost' && collision.type === 'player') {\n            /**\n             * We ignore this one.\n             */\n            return;\n          } else if (entityType === 'player' && collision.type === 'ghost') {\n            // Player collided with ghost\n            var isSuper = typeof entity.isSuperState === 'function' ? entity.isSuperState() : false;\n            if (isSuper) {\n              var _collision$entity$opt;\n              console.log('super user');\n              // Player wins: ghost should go to pen, award points\n              var points = ((_collision$entity$opt = collision.entity.options) === null || _collision$entity$opt === void 0 ? void 0 : _collision$entity$opt.points) || _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ghostPoints || 200;\n              this.collisionEmitter.emit('ghost-eaten', {\n                player: entity,\n                ghost: collision.entity,\n                points: points\n              });\n            } else {\n              console.log('ghosty!');\n              // Ghost wins: player should respawn, lose life\n              var _points2 = _settings_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].playerDeathPoints || 0; // Usually 0 for player death\n              this.collisionEmitter.emit('player-eaten', {\n                player: entity,\n                ghost: collision.entity,\n                points: _points2\n              });\n            }\n            this.setEventCooldown(key);\n            continue;\n          }\n          if (this.shouldFireEvent(key)) {\n            this.collisionEmitter.emit(\"\".concat(entityType, \"-\").concat(collision.type), _defineProperty(_defineProperty({}, entityType, entity), collision.type, collision.entity));\n            this.setEventCooldown(key);\n          } else {\n            console.log(key);\n          }\n        }\n        // Handle tile collisions (portals, collectibles on map)\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      if (collisions.tile) {\n        this.handleTileCollision(entity, collisions.tile, entity.col, entity.row);\n      }\n    }\n\n    /**\n     * Teleport entity to destination\n     */\n  }, {\n    key: \"teleportEntity\",\n    value: function teleportEntity(entity, dest) {\n      entity.col = dest.col;\n      entity.row = dest.row;\n      entity.x = dest.col * entity.tileSize;\n      entity.y = dest.row * entity.tileSize;\n      entity.targetX = entity.x;\n      entity.targetY = entity.y;\n      entity.moving = false;\n    }\n\n    /**\n     * Get entity type string\n     */\n  }, {\n    key: \"getEntityType\",\n    value: function getEntityType(entity) {\n      if (entity === this.player) return 'player';\n      if (this.ghosts.includes(entity)) return 'ghost';\n      return 'unknown';\n    }\n\n    /**\n     * Check if event should fire (not in cooldown)\n     */\n  }, {\n    key: \"shouldFireEvent\",\n    value: function shouldFireEvent(key) {\n      var cooldown = this.collisionCooldowns.get(key) || 0;\n      return cooldown === 0;\n    }\n\n    /**\n     * Set event cooldown\n     */\n  }, {\n    key: \"setEventCooldown\",\n    value: function setEventCooldown(key) {\n      this.collisionCooldowns.set(key, this.collisionCooldownFrames);\n    }\n\n    /**\n     * Update collision cooldowns each frame\n     */\n  }, {\n    key: \"updateCollisionCooldowns\",\n    value: function updateCollisionCooldowns() {\n      // Decrement collision cooldowns\n      var _iterator9 = _createForOfIteratorHelper(this.collisionCooldowns.entries()),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _step9$value = _slicedToArray(_step9.value, 2),\n            key = _step9$value[0],\n            value = _step9$value[1];\n          if (value > 0) {\n            this.collisionCooldowns.set(key, value - 1);\n          }\n        }\n        // Decrement portal cooldowns\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      var _iterator0 = _createForOfIteratorHelper(this.portalCooldowns.entries()),\n        _step0;\n      try {\n        for (_iterator0.s(); !(_step0 = _iterator0.n()).done;) {\n          var _step0$value = _slicedToArray(_step0.value, 2),\n            _key = _step0$value[0],\n            _value = _step0$value[1];\n          if (_value > 0) {\n            this.portalCooldowns.set(_key, _value - 1);\n          }\n        }\n      } catch (err) {\n        _iterator0.e(err);\n      } finally {\n        _iterator0.f();\n      }\n    }\n\n    // Find the portal/tunnel tile on the opposite side\n  }, {\n    key: \"findOppositePortal\",\n    value: function findOppositePortal(col, row) {\n      var portals = [];\n      var map = this.mapRenderer.mapData;\n      for (var r = 0; r < map.length; r++) {\n        for (var c = 0; c < map[0].length; c++) {\n          if (map[r][c] === this.mapRenderer.TILES.PORTAL && (c !== col || r !== row)) {\n            portals.push({\n              col: c,\n              row: r\n            });\n          }\n        }\n      }\n      if (portals.length === 0) return null;\n      if (portals.length === 1) return portals[0];\n      // Try to match by row (left/right tunnels)\n      for (var _i2 = 0, _portals = portals; _i2 < _portals.length; _i2++) {\n        var p = _portals[_i2];\n        if (p.row === row) return p;\n      }\n      // If not found, try to match by column (top/bottom tunnels)\n      for (var _i3 = 0, _portals2 = portals; _i3 < _portals2.length; _i3++) {\n        var _p = _portals2[_i3];\n        if (_p.col === col) return _p;\n      }\n      // Fallback: pick the farthest (classic Pac-Man: left/right edge)\n      var maxDist = -1,\n        best = null;\n      for (var _i4 = 0, _portals3 = portals; _i4 < _portals3.length; _i4++) {\n        var _p2 = _portals3[_i4];\n        var dist = Math.abs(_p2.col - col) + Math.abs(_p2.row - row);\n        if (dist > maxDist) {\n          maxDist = dist;\n          best = _p2;\n        }\n      }\n      return best;\n    }\n\n    // Helper: bounding-box collision for entities\n  }, {\n    key: \"isEntityColliding\",\n    value: function isEntityColliding(a, b) {\n      var size = Math.min(a.tileSize, b.tileSize) * 0.6; // 60% of tile size for hitbox\n      return Math.abs(a.x - b.x) < size && Math.abs(a.y - b.y) < size;\n    }\n  }, {\n    key: \"setScore\",\n    value: function setScore(val) {\n      this.score = val;\n      console.log('Score updated:', val);\n      this.updateUI && this.updateUI();\n    }\n  }, {\n    key: \"getScore\",\n    value: function getScore() {\n      return this.score;\n    }\n  }], [{\n    key: \"parseAndAdaptMazeCsv\",\n    value: function parseAndAdaptMazeCsv(csvString) {\n      var rows = csvString.trim().split('\\n');\n      return rows.map(function (row) {\n        return row.trim().split(',').map(function (val) {\n          var n = Number(val.trim());\n          // Example: adapt 4 to 5 if renderer expects 5 for tunnel\n          // If MapRenderer expects 4 for tunnel, no change needed\n          return n;\n        });\n      });\n    }\n  }]);\n}(); // Utility to convert mapData to PathFinding.js grid format\nfunction makePFGrid(mapData, walkableTiles) {\n  var grid = [];\n  for (var r = 0; r < mapData.length; r++) {\n    var row = [];\n    for (var c = 0; c < mapData[0].length; c++) {\n      // 0 = walkable, 1 = blocked\n      row.push(walkableTiles.includes(mapData[r][c]) ? 0 : 1);\n    }\n    grid.push(row);\n  }\n  return new (pathfinding__WEBPACK_IMPORTED_MODULE_6___default().Grid)(grid);\n}\n\n// Add event emitter for tile events\nvar TileEventEmitter = /*#__PURE__*/function () {\n  function TileEventEmitter() {\n    _classCallCheck(this, TileEventEmitter);\n    this.listeners = [];\n  }\n  return _createClass(TileEventEmitter, [{\n    key: \"on\",\n    value: function on(cb) {\n      this.listeners.push(cb);\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      this.listeners.forEach(function (cb) {\n        return cb(event);\n      });\n    }\n  }]);\n}(); // Initialize game when script loads\nvar game = new Game();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZXMvYXNzZXRzL2pzL2dhbWUuanM/NWYzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi9zZXR0aW5ncy5qcyc7XG5pbXBvcnQgeyBkZWJvdW5jZSwgdGhyb3R0bGVMZWFkaW5nIH0gZnJvbSAnLi9meC5qcyc7XG5pbXBvcnQgSW5wdXRIYW5kbGVyIGZyb20gJy4vaW5wdXQtaGFuZGxlci5qcyc7XG5pbXBvcnQgTWFwUmVuZGVyZXIgZnJvbSAnLi9tYXAtcmVuZGVyZXIuanMnO1xuaW1wb3J0IFBsYXllckVudGl0eSBmcm9tICcuL3BsYXllci1lbnRpdHkuanMnO1xuaW1wb3J0IEdob3N0RW50aXR5IGZyb20gJy4vZ2hvc3QtZW50aXR5LmpzJztcbmltcG9ydCBQRiBmcm9tICdwYXRoZmluZGluZyc7IC8vIEltcG9ydCBQYXRoRmluZGluZy5qc1xuaW1wb3J0IGVudGl0eUFydCBmcm9tICcuL2VudGl0eS1hcnQuanMnO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IENvbGxlY3RpYmxlRW50aXR5IGZyb20gJy4vY29sbGVjdGlibGUtZW50aXR5LmpzJztcbmltcG9ydCBDb2xsZWN0aWJsZVNwYXduZXIgZnJvbSAnLi9jb2xsZWN0aWJsZS1zcGF3bmVyLmpzJztcblxuLy8gTWFpbiBnYW1lIGNvb3JkaW5hdGlvbiB1c2luZyBtb2R1bGFyIGFyY2hpdGVjdHVyZVxuY2xhc3MgR2FtZSB7XG4gICAgZ2hvc3RzID0gW107XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXBSZW5kZXJlciA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5wdXRIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5nYW1lU3RhdGUgPSAnd2VsY29tZSc7IC8vIHdlbGNvbWUsIHN0b3BwZWQsIHBsYXlpbmcsIHBhdXNlZFxuICAgICAgICB0aGlzLmN1cnJlbnRNYXAgPSBudWxsO1xuICAgICAgICB0aGlzLnBsYXllciA9IG51bGw7XG5cbiAgICAgICAgLy8gR2FtZSBlbGVtZW50cyBpbml0aWFsaXplZCBmcm9tIHNldHRpbmdzXG4gICAgICAgIHRoaXMuc2NvcmUgPSBzZXR0aW5ncy5zY29yZTtcbiAgICAgICAgdGhpcy5saXZlcyA9IHNldHRpbmdzLmxpdmVzO1xuICAgICAgICB0aGlzLmxldmVsID0gc2V0dGluZ3MubGV2ZWw7XG4gICAgICAgIHRoaXMubW92ZUluYyA9IHNldHRpbmdzLm1vdmVJbmM7XG4gICAgICAgIHRoaXMuc3BlZWQgPSBzZXR0aW5ncy5zcGVlZDtcbiAgICAgICAgdGhpcy5nYW1lVGltZSA9IHNldHRpbmdzLmdhbWVUaW1lO1xuICAgICAgICB0aGlzLm1hemVTb3VyY2UgPSBzZXR0aW5ncy5tYXplU291cmNlO1xuICAgICAgICB0aGlzLmJhc2ljVmlzaW9uID0gc2V0dGluZ3MuYmFzaWNWaXNpb247XG4gICAgICAgIHRoaXMucmVzZXRNb2RlT25SZXNldEdhbWUgPSBzZXR0aW5ncy5yZXNldE1vZGVPblJlc2V0R2FtZTtcbiAgICAgICAgdGhpcy5leGNsdWRlUmV2ZXJzZURpcmVjdGlvbkluUmFuZG9tTW9kZSA9IHNldHRpbmdzLmV4Y2x1ZGVSZXZlcnNlRGlyZWN0aW9uSW5SYW5kb21Nb2RlO1xuICAgICAgICB0aGlzLmZ4ID0gc2V0dGluZ3MuZng7XG4gICAgICAgIHRoaXMuZXh0cmFzID0gc2V0dGluZ3MuZXh0cmFzO1xuICAgICAgICB0aGlzLm1heEdob3N0cyA9IChzZXR0aW5ncyAmJiBzZXR0aW5ncy5tYXhHaG9zdHMpIHx8IDM7XG5cbiAgICAgICAgLy8gSW5wdXQgaGFuZGxlcjogZHVtcCBhbGwgaW5wdXQgdG8gY29uc29sZVxuICAgICAgICB0aGlzLmlucHV0SGFuZGxlciA9IG5ldyBJbnB1dEhhbmRsZXIoKTtcblxuICAgICAgICB0aGlzLmlucHV0SGFuZGxlci5zZXRDYWxsYmFja3Moe1xuICAgICAgICAgICAgb25EaXJlY3Rpb25DaGFuZ2U6IGRpciA9PiBjb25zb2xlLmxvZygnRGlyZWN0aW9uOicsIGRpciksXG4gICAgICAgICAgICBvbktleVByZXNzOiBmdW5jdGlvbihjb2RlLCBldmVudCkge1xuICAgICAgICAgICAgICAgIC8vIEludGVyY2VwdCBFbnRlci9SZXR1cm4gZm9yIGFsbCBwbGF0Zm9ybXNcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPT09ICdlbnRlcicgfHwgY29kZSA9PT0gJ251bXBhZGVudGVyJyB8fCBjb2RlID09PSAncmV0dXJuJykgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lU3RhdGUgPT09ICd3ZWxjb21lJ1xuICAgICAgICAgICAgICAgICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBnYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZVN0YXRlID0gJ3BsYXlpbmcnO1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb25hbGx5OiByZS1pbml0IHBsYXllciwgY29sbGVjdGlibGVzLCBldGMuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzdGFydCB0aGF0IGF1ZGlvLicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvZGUpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZ2FtZVN0YXRlKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG9uUGF1c2U6ICgpID0+IGNvbnNvbGUubG9nKCdQYXVzZSByZXF1ZXN0ZWQnKSxcbiAgICAgICAgICAgIG9uUmVzZXQ6ICgpID0+IGNvbnNvbGUubG9nKCdSZXNldCByZXF1ZXN0ZWQnKVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIHdoZW4gRE9NIGlzIHJlYWR5XG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB0aGlzLmluaXQoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBldmVudCBlbWl0dGVyIGZvciB0aWxlIGV2ZW50c1xuICAgICAgICB0aGlzLnRpbGVFdmVudEVtaXR0ZXIgPSBuZXcgVGlsZUV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmdob3N0UmVsZWFzZVRpbWVyID0gMDtcbiAgICAgICAgdGhpcy5naG9zdFJlbGVhc2VJbnRlcnZhbCA9IDIwMDsgLy8gZnJhbWVzIGJldHdlZW4gcmVsZWFzZXMgKGFkanVzdGFibGUpXG4gICAgICAgIHRoaXMuZ2hvc3RQb29sID0gWy4uLmVudGl0eUFydC5naG9zdHNdOyAvLyBBbGwgcG9zc2libGUgZ2hvc3RzXG4gICAgICAgIHRoaXMuYWN0aXZlR2hvc3RzID0gW107IC8vIEdob3N0cyBjdXJyZW50bHkgaW4gcGxheVxuICAgICAgICB0aGlzLmNvbGxpc2lvbkVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAgICAgdGhpcy5naG9zdFBlblRpbWVycyA9IG5ldyBNYXAoKTsgLy8gVHJhY2sgdGltZSBlYWNoIGdob3N0IHNwZW5kcyBpbiBwZW5cbiAgICAgICAgdGhpcy5naG9zdEV4aXRUaW1lcnMgPSBuZXcgTWFwKCk7IC8vIFRyYWNrIGhvdyBsb25nIGEgZ2hvc3QgaGFzIGJlZW4gdHJ5aW5nIHRvIGV4aXRcbiAgICAgICAgdGhpcy5naG9zdEV4aXRUaW1lb3V0ID0gMiAqIDYwOyAvLyAyIHNlY29uZHMgYXQgNjBmcHNcbiAgICAgICAgLy8gR2hvc3QgcGVuIHRpbWVvdXQgKGluIGZyYW1lcywgZnJvbSBzZXR0aW5ncylcbiAgICAgICAgdGhpcy5naG9zdFBlblRpbWVvdXQgPSAoc2V0dGluZ3MuZ2hvc3RQZW5UaW1lb3V0IHx8IDIpICogNjA7XG4gICAgICAgIHRoaXMuY29sbGlzaW9uQ29vbGRvd25zID0gbmV3IE1hcCgpOyAvLyBUcmFjayBlbnRpdHkgY29sbGlzaW9uIGNvb2xkb3duc1xuICAgICAgICB0aGlzLmNvbGxpc2lvbkNvb2xkb3duRnJhbWVzID0gMzA7IC8vIEhhbGYgYSBzZWNvbmQgYXQgNjBmcHNcbiAgICAgICAgXG4gICAgICAgIC8vIFBvcnRhbCB0ZWxlcG9ydGF0aW9uIGNvb2xkb3ducyB0byBwcmV2ZW50IGxvb3BzXG4gICAgICAgIHRoaXMucG9ydGFsQ29vbGRvd25zID0gbmV3IE1hcCgpOyAvLyBUcmFjayBlbnRpdHkgcG9ydGFsIHVzYWdlXG4gICAgICAgIHRoaXMucG9ydGFsQ29vbGRvd25GcmFtZXMgPSAzMDsgLy8gSGFsZiBzZWNvbmQgY29vbGRvd24gYWZ0ZXIgdGVsZXBvcnRcblxuICAgICAgICAvLyBMaXN0ZW4gZm9yIHN1cGVyZG90IHBpY2t1cCBldmVudHNcbiAgICAgICAgdGhpcy50aWxlRXZlbnRFbWl0dGVyLm9uKGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAnc3VwZXJkb3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1N1cGVyZG90IGV2ZW50IHRyaWdnZXJlZDonLCBldmVudCk7XG4gICAgICAgICAgICAgICAgLy8gU2V0IHBsYXllciBzdXBlciBzdGF0ZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBsYXllciAmJiB0eXBlb2YgdGhpcy5wbGF5ZXIuc2V0U3VwZXJTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXllci5zZXRTdXBlclN0YXRlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGxheWVyLnNldFN1cGVyU3RhdGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9LCAoc2V0dGluZ3MubWVnYVBlbGxldER1cmF0aW9uIHx8IDUpICogMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIGdob3N0IG5vdCBpbiBwZW4sIHBpY2sgYSByYW5kb20gZGVzdGluYXRpb24gYXdheSBmcm9tIHBsYXllclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYXllciA9IHRoaXMucGxheWVyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdob3N0cyA9IHRoaXMuZ2hvc3RzIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcERhdGEgPSB0aGlzLm1hcFJlbmRlcmVyLm1hcERhdGE7XG4gICAgICAgICAgICAgICAgY29uc3QgbWluRGlzdGFuY2UgPSA2OyAvLyB0aWxlcyBhd2F5IGZyb20gcGxheWVyXG4gICAgICAgICAgICAgICAgY29uc3QgdXNlZFNwb3RzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIGdob3N0cy5mb3JFYWNoKChnaG9zdCwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnaG9zdC5zdGF0ZSAhPT0gJ2luX3BlbicgJiYgZ2hvc3Quc3RhdGUgIT09ICdleGl0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyaWVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBtaW5EaXN0YW5jZSArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpICsgaWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IE1hdGgubWF4KDEsIE1hdGgubWluKG1hcERhdGFbMF0ubGVuZ3RoIC0gMiwgcGxheWVyLmNvbCArIE1hdGgucm91bmQoTWF0aC5jb3MoYW5nbGUpICogZGlzdCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3cgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihtYXBEYXRhLmxlbmd0aCAtIDIsIHBsYXllci5yb3cgKyBNYXRoLnJvdW5kKE1hdGguc2luKGFuZ2xlKSAqIGRpc3QpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdCA9IHtjb2wsIHJvd307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXBEYXRhW2Rlc3Qucm93XVtkZXN0LmNvbF0gIT09IHRoaXMubWFwUmVuZGVyZXIuVElMRVMuRU1QVFkgfHwgdXNlZFNwb3RzLmhhcyhgJHtkZXN0LmNvbH0sJHtkZXN0LnJvd31gKSkgJiYgdHJpZXMgPCAxMFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZWRTcG90cy5hZGQoYCR7ZGVzdC5jb2x9LCR7ZGVzdC5yb3d9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnaG9zdC5zZXREZXN0aW5hdGlvbihkZXN0LCBtYXBEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEltbWVkaWF0ZWx5IHVwZGF0ZSBnaG9zdCBkaXJlY3Rpb24gYW5kIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2hvc3QubW92ZVRvRGVzdGluYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnaG9zdC5wYXRoU3RlcCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2hvc3QubW92ZVRvRGVzdGluYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBnYW1lXG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2FtZUNhbnZhcycpO1xuXG4gICAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dhbWUgY2FudmFzIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nYW1lU3RhdGUgPSAnd2VsY29tZSc7XG5cbiAgICAgICAgLy8gLS0tIE1hemUgcmVuZGVyaW5nIGludGVncmF0aW9uIC0tLVxuICAgICAgICBjb25zdCBjc3YgPSB3aW5kb3cubGFyYWNvbm1hbk1hemVDc3Y7XG5cbiAgICAgICAgaWYgKGNzdikge1xuICAgICAgICAgICAgLy8gUGFyc2UgQ1NWIGFuZCBsb2FkIGludG8gTWFwUmVuZGVyZXJcbiAgICAgICAgICAgIGNvbnN0IG1hcEFycmF5ID0gR2FtZS5wYXJzZUFuZEFkYXB0TWF6ZUNzdihjc3YpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBtYXBBcnJheVswXT8ubGVuZ3RoIHx8IDA7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBtYXBBcnJheS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLm1hcFJlbmRlcmVyID0gbmV3IE1hcFJlbmRlcmVyKHRoaXMuY2FudmFzKTtcbiAgICAgICAgICAgIC8vIE1hcFJlbmRlcmVyIGV4cGVjdHMgQ1NWIHN0cmluZywgc28gcmVqb2luIGZvciBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkQ3N2ID0gbWFwQXJyYXkubWFwKHJvdyA9PiByb3cuam9pbignLCcpKS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIHRoaXMubWFwUmVuZGVyZXIubG9hZE1hcChub3JtYWxpemVkQ3N2LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMubWFwUmVuZGVyZXIucmVuZGVyKCk7XG4gICAgICAgICAgICB0aGlzLmluaXRQbGF5ZXIodGhpcy5tYXBSZW5kZXJlci5tYXBEYXRhLCB0aGlzLm1hcFJlbmRlcmVyLnRpbGVTaXplKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdENvbGxlY3RpYmxlcygpO1xuICAgICAgICAgICAgdGhpcy5pbml0RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHRoaXMuZ2FtZUxvb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdHYW1lIGluaXRpYWxpemVkJyk7XG4gICAgfVxuXG4gICAgaW5pdENvbGxlY3RpYmxlcygpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBtYXAgYW5kIHRpbGUgdHlwZXMgZnJvbSBtYXBSZW5kZXJlclxuICAgICAgICBjb25zdCBtYXBEYXRhID0gdGhpcy5tYXBSZW5kZXJlci5tYXBEYXRhO1xuICAgICAgICBjb25zdCB0aWxlVHlwZXMgPSB0aGlzLm1hcFJlbmRlcmVyLlRJTEVTO1xuICAgICAgICBjb25zdCBzcGF3bmVyID0gbmV3IENvbGxlY3RpYmxlU3Bhd25lcihtYXBEYXRhLCB0aWxlVHlwZXMpO1xuICAgICAgICBjb25zdCB7IHN1cGVyZG90cywgZG90cywgZnJ1aXQgfSA9IHNwYXduZXIuc3Bhd25Db2xsZWN0aWJsZXMoKTtcbiAgICAgICAgdGhpcy5kb3RzID0gZG90cztcbiAgICAgICAgdGhpcy5mcnVpdCA9IGZydWl0O1xuICAgICAgICB0aGlzLnN1cGVyZG90cyA9IHN1cGVyZG90cztcbiAgICB9XG4gICAgaW5pdEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdGhpcy5jb2xsaXNpb25FbWl0dGVyLm9uKCdjb2xsaXNpb24tY29uc3VtYWJsZScsICh7IHBsYXllciwgY29uc3VtZWQgfSkgPT4ge1xuICAgICAgICAgIGlmICghY29uc3VtZWQgfHwgIWNvbnN1bWVkLnR5cGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNldFNjb3JlKHRoaXMuZ2V0U2NvcmUoKSArIGNvbnN1bWVkLm9wdGlvbnMucG9pbnRzKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBkb3QgZnJvbSB0aGlzLmRvdHMgaWYgaXQgaXMgYSBkb3RcbiAgICAgICAgICAgIGlmIChjb25zdW1lZC50eXBlID09PSB0aGlzLm1hcFJlbmRlcmVyLlRJTEVTLkRPVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG90cyA9IHRoaXMuZG90cy5maWx0ZXIoZG90ID0+ICEoZG90LmNvbCA9PT0gY29uc3VtZWQuY29sICYmIGRvdC5yb3cgPT09IGNvbnN1bWVkLnJvdykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uc3VtZWQudHlwZSA9PT0gdGhpcy5tYXBSZW5kZXJlci5USUxFUy5TVVBFUl9ET1QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1cGVyZG90cyA9IHRoaXMuc3VwZXJkb3RzLmZpbHRlcihkb3QgPT4gIShkb3QuY29sID09PSBjb25zdW1lZC5jb2wgJiYgZG90LnJvdyA9PT0gY29uc3VtZWQucm93KSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXBSZW5kZXJlciAmJiB0aGlzLm1hcFJlbmRlcmVyLm1hcERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBSZW5kZXJlci5tYXBEYXRhW2NvbnN1bWVkLnJvd11bY29uc3VtZWQuY29sXSA9IHRoaXMubWFwUmVuZGVyZXIuVElMRVMuRU1QVFk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBsYXllciAmJiB0eXBlb2YgcGxheWVyLnNldFN1cGVyU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLnNldFN1cGVyU3RhdGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVyLnNldFN1cGVyU3RhdGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9LCAoc2V0dGluZ3MubWVnYVBlbGxldER1cmF0aW9uIHx8IDUpICogMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd1c2VyIGlzIGEgc3VwZXIgZG90IScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmbiBvciBwbGF5ZXIgbm8gZXhpc3QuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnN1bWVkLnR5cGUgPT09IHRoaXMubWFwUmVuZGVyZXIuVElMRVMuRlJVSVQpIHtcbmNvbnNvbGUubG9nKCdpdHMgYSBmcnVpdCEnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZydWl0ID0gdGhpcy5mcnVpdC5maWx0ZXIoZnJ1aXQgPT4gIShmcnVpdC5jb2wgPT09IGNvbnN1bWVkLmNvbCAmJiBmcnVpdC5yb3cgPT09IGNvbnN1bWVkLnJvdykpO1xuICAgICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAgIC8vIEFkZCBkZWZhdWx0IGV2ZW50IGhhbmRsZXJzIGZvciBjb2xsaXNpb25zXG4gICAgICAgIHRoaXMuY29sbGlzaW9uRW1pdHRlci5vbignY29sbGlzaW9uLWdob3N0JywgKHtwbGF5ZXIsIGdob3N0fSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1BsYXllciBjb2xsaWRlZCB3aXRoIGdob3N0OicsIGdob3N0LmRpc3BsYXlOYW1lIHx8IGdob3N0LmNvbG9yKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRGVib3VuY2VkIHBsYXllci1lYXRlbiBldmVudCBoYW5kbGVyXG4gICAgICAgIHRoaXMuY29sbGlzaW9uRW1pdHRlci5vbigncGxheWVyLWVhdGVuJywgdGhyb3R0bGVMZWFkaW5nKCh7IHBsYXllciwgZ2hvc3QgfSkgPT4ge1xuICAgICAgICAgICAgLy8gQW5pbWF0ZSBwbGF5ZXIgZGVhdGgsIGRlY3JlbWVudCBsaXZlcywgcmVzcGF3biBwbGF5ZXJcbiAgICAgICAgICAgIHRoaXMubGl2ZXMgLT0xO1xuICAgICAgICAgICAgaWYgKHBsYXllciAmJiB0eXBlb2YgcGxheWVyLmRpZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHBsYXllci5kaWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2FtZVN0YXRlID0gJ3N0b3BwZWQnO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVVSSAmJiB0aGlzLnVwZGF0ZVVJKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5saXZlcyA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuaW5pdFBsYXllciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRQbGF5ZXIodGhpcy5tYXBSZW5kZXJlci5tYXBEYXRhLCB0aGlzLm1hcFJlbmRlcmVyLnRpbGVTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dEhhbmRsZXIuc2V0Q2FsbGJhY2tzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRGlyZWN0aW9uQ2hhbmdlOiBkaXIgPT4gdGhpcy5wbGF5ZXIuc2V0RGlyZWN0aW9uKGRpcilcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZVN0YXRlID0gJ3BsYXlpbmcnO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZVN0YXRlID0gJ3N0b3BwZWQnO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVUkgJiYgdGhpcy51cGRhdGVVSSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5nYW1lU3RhdGUpO1xuICAgICAgICB9LCAxNTAwKSk7XG5cbiAgICAgICAgdGhpcy5jb2xsaXNpb25FbWl0dGVyLm9uKCdnaG9zdC1lYXRlbicsICh7IHBsYXllciwgZ2hvc3QsIHBvaW50cyB9KSA9PiB7XG4gICAgICAgICAgICAvLyBFeGFtcGxlOiBBbmltYXRlIGdob3N0IGRlYXRoLCBhd2FyZCBwb2ludHNcbiAgICAgICAgICAgIGlmIChnaG9zdCAmJiB0eXBlb2YgZ2hvc3QuZGllID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZ2hvc3QuZGllKCk7IC8vIFlvdSBtYXkgd2FudCB0byBpbXBsZW1lbnQgdGhpc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQmFuaXNoIGdob3N0IHRvIHBlbiAoc2V0IHRvIGZpcnN0IEdIT1NUX1NQQVdOIHRpbGUgZm91bmQpXG4gICAgICAgICAgICBjb25zdCBtYXAgPSB0aGlzLm1hcFJlbmRlcmVyLm1hcERhdGE7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgbWFwLmxlbmd0aCAmJiAhZm91bmQ7IHIrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgbWFwWzBdLmxlbmd0aCAmJiAhZm91bmQ7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFwW3JdW2NdID09PSB0aGlzLm1hcFJlbmRlcmVyLlRJTEVTLkdIT1NUX1NQQVdOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnaG9zdC5jb2wgPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2hvc3Qucm93ID0gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdob3N0LnggPSBjICogdGhpcy5tYXBSZW5kZXJlci50aWxlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdob3N0LnkgPSByICogdGhpcy5tYXBSZW5kZXJlci50aWxlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdob3N0LnN0YXRlID0gJ2luX3Blbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2NvcmUgKz0gcG9pbnRzO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVVSSAmJiB0aGlzLnVwZGF0ZVVJKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHk6IFBhcnNlIGFuZCBhZGFwdCBDU1YgbWF6ZSBkYXRhIGZyb20gQmxhZGVcbiAgICAgKiBDb252ZXJ0cyBwYXNzLXRocm91Z2ggdHVubmVsICg0KSB0byByZW5kZXJlcidzIHR1bm5lbCAoNSkgaWYgbmVlZGVkXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlQW5kQWRhcHRNYXplQ3N2KGNzdlN0cmluZykge1xuICAgICAgICBjb25zdCByb3dzID0gY3N2U3RyaW5nLnRyaW0oKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIHJldHVybiByb3dzLm1hcChyb3cgPT5cbiAgICAgICAgICAgIHJvdy50cmltKCkuc3BsaXQoJywnKS5tYXAodmFsID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbiA9IE51bWJlcih2YWwudHJpbSgpKTtcbiAgICAgICAgICAgICAgICAvLyBFeGFtcGxlOiBhZGFwdCA0IHRvIDUgaWYgcmVuZGVyZXIgZXhwZWN0cyA1IGZvciB0dW5uZWxcbiAgICAgICAgICAgICAgICAvLyBJZiBNYXBSZW5kZXJlciBleHBlY3RzIDQgZm9yIHR1bm5lbCwgbm8gY2hhbmdlIG5lZWRlZFxuICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgVUkgZXZlbnQgbGlzdGVuZXJzXG4gICAgICovXG4gICAgc2V0dXBVSSgpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhcnRCdG4nKTtcbiAgICAgICAgY29uc3QgcGF1c2VCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGF1c2VCdG4nKTtcbiAgICAgICAgY29uc3QgcmVzZXRCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzZXRCdG4nKTtcblxuICAgICAgICBpZiAoc3RhcnRCdG4pIHtcbiAgICAgICAgICAgIHN0YXJ0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5zdGFydEdhbWUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF1c2VCdG4pIHtcbiAgICAgICAgICAgIHBhdXNlQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy50b2dnbGVQYXVzZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNldEJ0bikge1xuICAgICAgICAgICAgcmVzZXRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLnJlc2V0R2FtZSgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgbWFwIGRhdGEgZnJvbSBET00gKHBhc3NlZCBmcm9tIFBIUClcbiAgICAgKi9cbiAgICBsb2FkTWFwRnJvbURPTSgpIHtcbiAgICAgICAgLy8gTG9vayBmb3IgbWFwIGRhdGEgaW4gYSBzY3JpcHQgdGFnIG9yIGRhdGEgYXR0cmlidXRlXG4gICAgICAgIGNvbnN0IG1hcERhdGFTY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFwRGF0YScpO1xuICAgICAgICBpZiAobWFwRGF0YVNjcmlwdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNYXAgPSBKU09OLnBhcnNlKG1hcERhdGFTY3JpcHQudGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZE1hcCh0aGlzLmN1cnJlbnRNYXApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBtYXAgZGF0YTonLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrOiBsb29rIGZvciBnbG9iYWwgd2luZG93IHZhcmlhYmxlXG4gICAgICAgICAgICBpZiAod2luZG93LmdhbWVNYXBEYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TWFwID0gd2luZG93LmdhbWVNYXBEYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZE1hcCh0aGlzLmN1cnJlbnRNYXApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIG1hcCBkYXRhIGZvdW5kLiBVc2luZyB0ZXN0IG1hcC4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRUZXN0TWFwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGEgbWFwIGludG8gdGhlIHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG1hcERhdGEgLSBNYXAgZGF0YSBmcm9tIGRhdGFiYXNlXG4gICAgICovXG4gICAgbG9hZE1hcChtYXBEYXRhKSB7XG4gICAgICAgIGlmICghbWFwRGF0YSB8fCAhbWFwRGF0YS5kZXNpZ24pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgbWFwIGRhdGEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIG1hcDonLCBtYXBEYXRhLm5hbWUpO1xuXG4gICAgICAgIC8vIExvYWQgbWFwIGludG8gcmVuZGVyZXJcbiAgICAgICAgdGhpcy5tYXBSZW5kZXJlci5sb2FkTWFwKG1hcERhdGEuZGVzaWduLCBtYXBEYXRhLndpZHRoLCBtYXBEYXRhLmhlaWdodCk7XG5cbiAgICAgICAgLy8gUmVuZGVyIHRoZSBtYXBcbiAgICAgICAgdGhpcy5tYXBSZW5kZXJlci5yZW5kZXIoKTtcblxuICAgICAgICAvLyBVcGRhdGUgVUlcbiAgICAgICAgdGhpcy51cGRhdGVVSSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgYSB0ZXN0IG1hcCBmb3IgZGV2ZWxvcG1lbnRcbiAgICAgKi9cbiAgICBsb2FkVGVzdE1hcCgpIHtcbiAgICAgICAgY29uc3QgdGVzdE1hcCA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdUZXN0IE1hcCcsXG4gICAgICAgICAgICB3aWR0aDogMTksXG4gICAgICAgICAgICBoZWlnaHQ6IDIxLFxuICAgICAgICAgICAgZGVzaWduOiBgMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMVxuMSwyLDIsMiwyLDIsMiwyLDIsMSwyLDIsMiwyLDIsMiwyLDIsMVxuMSwyLDEsMSwyLDEsMSwxLDIsMSwyLDEsMSwxLDIsMSwxLDIsMVxuMSwyLDIsMiwyLDIsMiwyLDIsMiwyLDIsMiwyLDIsMiwyLDIsMVxuMSwyLDEsMSwyLDEsMiwxLDEsMSwxLDEsMiwxLDIsMSwxLDIsMVxuMSwyLDIsMiwyLDEsMiwyLDIsMSwyLDIsMiwxLDIsMiwyLDIsMVxuMSwxLDEsMSwyLDEsMSwxLDAsMSwwLDEsMSwxLDIsMSwxLDEsMVxuMCwwLDAsMSwyLDEsMCwwLDAsMCwwLDAsMCwxLDIsMSwwLDAsMFxuMSwxLDEsMSwyLDEsMCwxLDMsMywzLDEsMCwxLDIsMSwxLDEsMVxuNCwwLDAsMCwyLDAsMCwxLDAsMCwwLDEsMCwwLDIsMCwwLDAsNFxuMSwxLDEsMSwyLDEsMCwxLDEsMSwxLDEsMCwxLDIsMSwxLDEsMVxuMCwwLDAsMSwyLDEsMCwwLDAsMCwwLDAsMCwxLDIsMSwwLDAsMFxuMSwxLDEsMSwyLDEsMSwxLDAsMSwwLDEsMSwxLDIsMSwxLDEsMVxuMSwyLDIsMiwyLDIsMiwyLDIsMSwyLDIsMiwyLDIsMiwyLDIsMVxuMSwyLDEsMSwyLDEsMSwxLDIsMSwyLDEsMSwxLDIsMSwxLDIsMVxuMSwyLDIsMSwyLDIsMiwyLDIsMiwyLDIsMiwyLDIsMSwyLDIsMVxuMSwxLDIsMSwyLDEsMiwxLDEsMSwxLDEsMiwxLDIsMSwyLDEsMVxuMSwyLDIsMiwyLDEsMiwyLDIsMSwyLDIsMiwxLDIsMiwyLDIsMVxuMSwyLDEsMSwxLDEsMSwxLDIsMSwyLDEsMSwxLDEsMSwxLDIsMVxuMSwyLDIsMiwyLDIsMiwyLDIsMiwyLDIsMiwyLDIsMiwyLDIsMVxuMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMWBcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmN1cnJlbnRNYXAgPSB0ZXN0TWFwO1xuICAgICAgICB0aGlzLmxvYWRNYXAodGVzdE1hcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIGdhbWVcbiAgICAgKi9cbiAgICBzdGFydEdhbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmdhbWVTdGF0ZSA9PT0gJ3N0b3BwZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmdhbWVTdGF0ZSA9ICdwbGF5aW5nJztcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVUkoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHYW1lIHN0YXJ0ZWQnKTtcblxuICAgICAgICAgICAgLy8gVE9ETzogSW5pdGlhbGl6ZSBwbGF5ZXIgYW5kIGdob3N0c1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZ2FtZVN0YXRlID09PSAncGF1c2VkJykge1xuICAgICAgICAgICAgdGhpcy5nYW1lU3RhdGUgPSAncGxheWluZyc7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVVJKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnR2FtZSByZXN1bWVkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgcGF1c2Ugc3RhdGVcbiAgICAgKi9cbiAgICB0b2dnbGVQYXVzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2FtZVN0YXRlID09PSAncGxheWluZycpIHtcbiAgICAgICAgICAgIHRoaXMuZ2FtZVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnR2FtZSBwYXVzZWQnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmdhbWVTdGF0ZSA9PT0gJ3BhdXNlZCcpIHsgIFxuICAgICAgICAgICAgdGhpcy5nYW1lU3RhdGUgPSAncGxheWluZyc7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnR2FtZSByZXN1bWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVVSSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBnYW1lXG4gICAgICovXG4gICAgcmVzZXRHYW1lKCkge1xuICAgICAgICB0aGlzLmdhbWVTdGF0ZSA9ICdzdG9wcGVkJztcbiAgICAgICAgdGhpcy5zY29yZSA9IDA7XG4gICAgICAgIHRoaXMubGl2ZXMgPSBzZXR0aW5ncy5saXZlcztcblxuICAgICAgICAvLyBSZXNldCBpbnB1dCBoYW5kbGVyXG4gICAgICAgIHRoaXMuaW5wdXRIYW5kbGVyLnJlc2V0KCk7XG5cbiAgICAgICAgLy8gUmVsb2FkIGN1cnJlbnQgbWFwXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRNYXApIHtcbiAgICAgICAgICAgIHRoaXMubG9hZE1hcCh0aGlzLmN1cnJlbnRNYXApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVVSSgpO1xuICAgICAgICBjb25zb2xlLmxvZygnR2FtZSByZXNldCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBkaXJlY3Rpb24gY2hhbmdlcyBmcm9tIGlucHV0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiAtIE5ldyBtb3ZlbWVudCBkaXJlY3Rpb25cbiAgICAgKi9cbiAgICBoYW5kbGVEaXJlY3Rpb25DaGFuZ2UoZGlyZWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmdhbWVTdGF0ZSAhPT0gJ3BsYXlpbmcnKSByZXR1cm47XG5cbiAgICAgICAgY29uc29sZS5sb2coJ0RpcmVjdGlvbiBjaGFuZ2VkOicsIGRpcmVjdGlvbik7XG4gICAgICAgIC8vIFRPRE86IFVwZGF0ZSBwbGF5ZXIgbW92ZW1lbnQgZGlyZWN0aW9uXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIFVJIGVsZW1lbnRzXG4gICAgICovXG4gICAgdXBkYXRlVUkoKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBzY29yZVxuICAgICAgICBjb25zdCBzY29yZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2NvcmUnKTtcbiAgICAgICAgaWYgKHNjb3JlRWxlbWVudCkge1xuICAgICAgICAgICAgc2NvcmVFbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5zY29yZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBsaXZlc1xuICAgICAgICBjb25zdCBsaXZlc0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGl2ZXMnKTtcbiAgICAgICAgaWYgKGxpdmVzRWxlbWVudCkge1xuICAgICAgICAgICAgbGl2ZXNFbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5saXZlcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBidXR0b24gc3RhdGVzXG4gICAgICAgIGNvbnN0IHN0YXJ0QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJ0QnRuJyk7XG4gICAgICAgIGNvbnN0IHBhdXNlQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhdXNlQnRuJyk7XG5cbiAgICAgICAgaWYgKHN0YXJ0QnRuKSB7XG4gICAgICAgICAgICBzdGFydEJ0bi50ZXh0Q29udGVudCA9IHRoaXMuZ2FtZVN0YXRlID09PSAnc3RvcHBlZCcgPyAnU3RhcnQgR2FtZScgOiAnUmVzdW1lJztcbiAgICAgICAgICAgIHN0YXJ0QnRuLmRpc2FibGVkID0gdGhpcy5nYW1lU3RhdGUgPT09ICdwbGF5aW5nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXVzZUJ0bikge1xuICAgICAgICAgICAgcGF1c2VCdG4udGV4dENvbnRlbnQgPSB0aGlzLmdhbWVTdGF0ZSA9PT0gJ3BhdXNlZCcgPyAnUmVzdW1lJyA6ICdQYXVzZSc7XG4gICAgICAgICAgICBwYXVzZUJ0bi5kaXNhYmxlZCA9IHRoaXMuZ2FtZVN0YXRlID09PSAnc3RvcHBlZCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBnYW1lIHN0YXRlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQ3VycmVudCBnYW1lIHN0YXRlXG4gICAgICovXG4gICAgZ2V0R2FtZVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nYW1lU3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgbWFwIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDdXJyZW50IG1hcCBkYXRhXG4gICAgICovXG4gICAgZ2V0Q3VycmVudE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudE1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHBsYXllciBlbnRpdHlcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBtYXBEYXRhIC0gTWFwIGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGlsZVNpemUgLSBUaWxlIHNpemVcbiAgICAgKi9cbiAgICBpbml0UGxheWVyKG1hcERhdGEsIHRpbGVTaXplKSB7XG4gICAgICAgIC8vIEZpbmQgZ2hvc3QgcGVuIHRpbGVzXG4gICAgICAgIGxldCBwZW5UaWxlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByID0gMDsgciA8IG1hcERhdGEubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgbWFwRGF0YVswXS5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgIGlmIChtYXBEYXRhW3JdW2NdID09PSB0aGlzLm1hcFJlbmRlcmVyLlRJTEVTLkdIT1NUX1NQQVdOKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlblRpbGVzLnB1c2goe2NvbDogYywgcm93OiByfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgY2VudGVyLW1vc3QgdGlsZSBiZWxvdyB0aGUgcGVuIHRoYXQgaXMgRU1QVFlcbiAgICAgICAgbGV0IHBsYXllclN0YXJ0ID0geyBjb2w6IDEsIHJvdzogMSB9O1xuICAgICAgICBpZiAocGVuVGlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSBjZW50ZXIgY29sIG9mIHBlblxuICAgICAgICAgICAgbGV0IHBlbkNvbHMgPSBwZW5UaWxlcy5tYXAodCA9PiB0LmNvbCk7XG4gICAgICAgICAgICBsZXQgcGVuUm93cyA9IHBlblRpbGVzLm1hcCh0ID0+IHQucm93KTtcbiAgICAgICAgICAgIGxldCBtaW5Db2wgPSBNYXRoLm1pbiguLi5wZW5Db2xzKSwgbWF4Q29sID0gTWF0aC5tYXgoLi4ucGVuQ29scyk7XG4gICAgICAgICAgICBsZXQgbWF4Um93ID0gTWF0aC5tYXgoLi4ucGVuUm93cyk7IC8vIDwtLS0gYWRkZWQgdGhpcyBsaW5lXG4gICAgICAgICAgICBsZXQgY2VudGVyQ29sID0gTWF0aC5yb3VuZCgobWluQ29sICsgbWF4Q29sKSAvIDIpO1xuICAgICAgICAgICAgLy8gU2VhcmNoIGRvd253YXJkIGZyb20ganVzdCBiZWxvdyBwZW4sIG9ubHkgYXQgY2VudGVyQ29sXG4gICAgICAgICAgICBmb3IgKGxldCByID0gbWF4Um93ICsgMTsgciA8IG1hcERhdGEubGVuZ3RoLTE7IHIrKykge1xuICAgICAgICAgICAgICAgIGlmIChtYXBEYXRhW3JdW2NlbnRlckNvbF0gPT09IHRoaXMubWFwUmVuZGVyZXIuVElMRVMuRU1QVFkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyU3RhcnQgPSB7Y29sOiBjZW50ZXJDb2wsIHJvdzogcn07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIG9sZCBsb2dpY1xuICAgICAgICAgICAgb3V0ZXI6IGZvciAobGV0IHIgPSAxOyByIDwgbWFwRGF0YS5sZW5ndGgtMTsgcisrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyA9IDE7IGMgPCBtYXBEYXRhWzBdLmxlbmd0aC0xOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcERhdGFbcl1bY10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllclN0YXJ0ID0geyBjb2w6IGMsIHJvdzogciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BlZWQgPSAyO1xuICAgICAgICB0aGlzLnBsYXllciA9IG5ldyBQbGF5ZXJFbnRpdHkocGxheWVyU3RhcnQuY29sLCBwbGF5ZXJTdGFydC5yb3csIHRpbGVTaXplLCBtYXBEYXRhLCBzZXR0aW5ncyk7XG4gICAgICAgIGlmICh0aGlzLmlucHV0SGFuZGxlciAmJiB0eXBlb2YgdGhpcy5pbnB1dEhhbmRsZXIuc2V0Q2FsbGJhY2tzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0SGFuZGxlci5zZXRDYWxsYmFja3Moe1xuICAgICAgICAgICAgICAgIG9uRGlyZWN0aW9uQ2hhbmdlOiBkaXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wbGF5ZXIpIHRoaXMucGxheWVyLnNldERpcmVjdGlvbihkaXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogLS0tIENPTExJU0lPTiBERVRFQ1RJT046IEFMTCBDT0xMSVNJT04gTE9HSUMgSEVSRSAtLS1cbiAgICAgKiBDaGVjayBmb3IgaXRlbSBjb2xsaXNpb24gYW5kIGVtaXQgZXZlbnRcbiAgICAgKi9cbiAgICBjaGVja0NvbGxpc2lvbnMoZW50aXR5KSB7XG4gICAgICAgIC8vIEdob3N0IGNvbGxpc2lvblxuICAgICAgICBmb3IgKGNvbnN0IGdob3N0IG9mIHRoaXMuZ2hvc3RzKSB7XG4gICAgICAgICAgICBpZiAoZ2hvc3QuY29sID09PSBlbnRpdHkuY29sICYmIGdob3N0LnJvdyA9PT0gZW50aXR5LnJvdykge1xuICAgICAgICAgICAgICAgIGlmIChlbnRpdHkuc3RhdGUgPT0gJ25vcm1hbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGxheWVyIGlzIG5vdCBzdXBlcjogbG9zZSBhIGxpZmUsIHJlc3Bhd24sIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gc2V0dGluZ3MucGxheWVyRGVhdGhQb2ludHMgfHwgMDsgLy8gVXN1YWxseSAwIGZvciBwbGF5ZXIgZGVhdGhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25FbWl0dGVyLmVtaXQoJ3BsYXllci1lYXRlbicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllcjogZW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2hvc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGxheWVyIGlzIHN1cGVyOiBlYXQgdGhlIGdob3N0LCBhd2FyZCBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gZ2hvc3Qub3B0aW9ucz8ucG9pbnRzIHx8IHNldHRpbmdzLmdob3N0UG9pbnRzIHx8IDIwMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25FbWl0dGVyLmVtaXQoJ2dob3N0LWVhdGVuJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVyOiBlbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBnaG9zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY29yZSArPSBwb2ludHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVUkgJiYgdGhpcy51cGRhdGVVSSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGcnVpdCBjb2xsaXNpb25cbiAgICAgICAgZm9yIChjb25zdCBmcnVpdCBvZiB0aGlzLmZydWl0IHx8IFtdKSB7XG4gICAgICAgICAgICBpZiAoZnJ1aXQuY29sID09PSBlbnRpdHkuY29sICYmIGZydWl0LnJvdyA9PT0gZW50aXR5LnJvdykge1xuICAgICAgICAgICAgICAgIGZydWl0LnR5cGUgPSB0aGlzLm1hcFJlbmRlcmVyLlRJTEVTLkZSVUlUO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uRW1pdHRlci5lbWl0KCdjb2xsaXNpb24tY29uc3VtYWJsZScsIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyOiBlbnRpdHksXG4gICAgICAgICAgICAgICAgICAgIGNvbnN1bWVkOiBmcnVpdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEb3QgY29sbGlzaW9uXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmRvdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblxuICAgICAgICAgICAgY29uc3Qgc3ByaXRlID0gdGhpcy5kb3RzW2ldO1xuICAgICAgICAgICAgaWYgKHNwcml0ZS5jb2wgPT09IGVudGl0eS5jb2wgJiYgc3ByaXRlLnJvdyA9PT0gZW50aXR5LnJvdykge1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBkb3QgY29sbGlzaW9uIChmaXJlIGV2ZW50LCByZW1vdmUgZG90LCBldGMuKVxuICAgICAgICAgICAgICAgIHNwcml0ZS50eXBlID0gdGhpcy5tYXBSZW5kZXJlci5USUxFUy5ET1Q7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25FbWl0dGVyLmVtaXQoJ2NvbGxpc2lvbi1jb25zdW1hYmxlJywge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXI6IGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgY29uc3VtZWQ6IHNwcml0ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTdXBlcmRvdCBjb2xsaXNpb25cbiAgICAgICAgaWYgKHRoaXMuc3VwZXJkb3RzICYmIHRoaXMuc3VwZXJkb3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3VwZXJkb3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ByaXRlID0gdGhpcy5zdXBlcmRvdHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHNwcml0ZS5jb2wgPT09IGVudGl0eS5jb2wgJiYgc3ByaXRlLnJvdyA9PT0gZW50aXR5LnJvdykge1xuLy8gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzdXBlcmRvdCBjb2xsaXNpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHN1cGVyZG90IGNvbGxpc2lvblxuICAgICAgICAgICAgICAgICAgICBzcHJpdGUudHlwZSA9IHRoaXMubWFwUmVuZGVyZXIuVElMRVMuU1VQRVJfRE9UO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkVtaXR0ZXIuZW1pdCgnY29sbGlzaW9uLWNvbnN1bWFibGUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXI6IGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN1bWVkOiBzcHJpdGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBvcnRhbCBjb2xsaXNpb25cbiAgICAgICAgY29uc3QgdGlsZSA9IHRoaXMubWFwUmVuZGVyZXIubWFwRGF0YVtlbnRpdHkucm93XVtlbnRpdHkuY29sXTtcbiAgICAgICAgaWYgKHRpbGUgPT09IHRoaXMubWFwUmVuZGVyZXIuVElMRVMuUE9SVEFMKSB7XG4gICAgICAgICAgICBsZXQgZW50aXR5VHlwZSA9IGVudGl0eS50eXBlO1xuICAgICAgICAgICAgY29uc3QgcG9ydGFsS2V5ID0gYCR7ZW50aXR5VHlwZX06cG9ydGFsOiR7ZW50aXR5LmNvbH0sJHtlbnRpdHkucm93fWA7XG4gICAgICAgICAgICBjb25zdCBjb29sZG93biA9IHRoaXMucG9ydGFsQ29vbGRvd25zLmdldChwb3J0YWxLZXkpIHx8IDA7XG5cbiAgICAgICAgICAgIGlmIChjb29sZG93biA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc3QgPSB0aGlzLmZpbmRPcHBvc2l0ZVBvcnRhbChlbnRpdHkuY29sLCBlbnRpdHkucm93KTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgY29vbGRvd24gZm9yIGJvdGggZW50cnkgYW5kIGV4aXQgcG9ydGFsXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RLZXkgPSBgJHtlbnRpdHlUeXBlfTpwb3J0YWw6JHtkZXN0LmNvbH0sJHtkZXN0LnJvd31gO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcnRhbENvb2xkb3ducy5zZXQocG9ydGFsS2V5LCB0aGlzLnBvcnRhbENvb2xkb3duRnJhbWVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3J0YWxDb29sZG93bnMuc2V0KGRlc3RLZXksIHRoaXMucG9ydGFsQ29vbGRvd25GcmFtZXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIGVudGl0eSBvbmUgYmxvY2sgYXdheSBmcm9tIHBvcnRhbCBleGl0IHRvd2FyZCBtYXAgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkQ29sID0gMCwgZFJvdyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlckNvbCA9IE1hdGguZmxvb3IodGhpcy5tYXBSZW5kZXJlci5tYXBEYXRhWzBdLmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzdC5jb2wgPCBjZW50ZXJDb2wpIGRDb2wgPSAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkZXN0LmNvbCA+IGNlbnRlckNvbCkgZENvbCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB2ZXJ0aWNhbCB0dW5uZWwsIGJpYXMgcm93XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlclJvdyA9IE1hdGguZmxvb3IodGhpcy5tYXBSZW5kZXJlci5tYXBEYXRhLmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzdC5yb3cgPCBjZW50ZXJSb3cpIGRSb3cgPSAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkZXN0LnJvdyA+IGNlbnRlclJvdykgZFJvdyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3Q29sID0gZGVzdC5jb2wgKyBkQ29sO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3Um93ID0gZGVzdC5yb3cgKyBkUm93O1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IG1vdmUgaWYgbmV3IHRpbGUgaXMgd2Fsa2FibGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2Fsa2FibGUgPSBbdGhpcy5tYXBSZW5kZXJlci5USUxFUy5FTVBUWSwgdGhpcy5tYXBSZW5kZXJlci5USUxFUy5ET1QsIHRoaXMubWFwUmVuZGVyZXIuVElMRVMuU1VQRVJfRE9UXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29sID49IDAgJiYgbmV3Q29sIDwgdGhpcy5tYXBSZW5kZXJlci5tYXBEYXRhWzBdLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um93ID49IDAgJiYgbmV3Um93IDwgdGhpcy5tYXBSZW5kZXJlci5tYXBEYXRhLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgd2Fsa2FibGUuaW5jbHVkZXModGhpcy5tYXBSZW5kZXJlci5tYXBEYXRhW25ld1Jvd11bbmV3Q29sXSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRlbGVwb3J0RW50aXR5KGVudGl0eSwge2NvbDogbmV3Q29sLCByb3c6IG5ld1Jvd30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGNvb2xkb3duIGZvciB0aGUgZWplY3Rpb24gdGlsZSBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlamVjdGlvbktleSA9IGAke2VudGl0eVR5cGV9OnBvcnRhbDoke25ld0NvbH0sJHtuZXdSb3d9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9ydGFsQ29vbGRvd25zLnNldChlamVjdGlvbktleSwgdGhpcy5wb3J0YWxDb29sZG93bkZyYW1lcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRlbGVwb3J0RW50aXR5KGVudGl0eSwgZGVzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRW1pdCBhcHByb3ByaWF0ZSBldmVudFxuICAgICAgICAgICAgICAgICAgICBsZXQgY29sID0gZW50aXR5LmNvbCwgcm93ID0gZW50aXR5LnJvdztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudGl0eVR5cGUgPT09ICdwbGF5ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZENvbCAhPT0gMCkgY29sICs9IGRDb2w7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkVtaXR0ZXIuZW1pdCgncGxheWVyLXBvcnRhbCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXI6IGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiB7IGNvbCwgcm93IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IGRlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVudGl0eVR5cGUgPT09ICdnaG9zdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uRW1pdHRlci5lbWl0KCdnaG9zdC1wb3J0YWwnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2hvc3Q6IGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiB7IGNvbCwgcm93IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IGRlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50aXR5LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0eS5wYXRoID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0eS5wYXRoU3RlcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGF3biBhIGdob3N0IGF0IGEgcmFuZG9tIGdob3N0IHNwYXduIHRpbGUgSU5TSURFIFRIRSBQRU5cbiAgICAgKi9cbiAgICBzcGF3bkdob3N0KCkge1xuICAgICAgICBpZiAodGhpcy5naG9zdHMubGVuZ3RoID49IHRoaXMubWF4R2hvc3RzKSByZXR1cm47XG5cbiAgICAgICAgLy8gRmluZCBhbGwgZ2hvc3Qgc3Bhd24gdGlsZXMgaW5zaWRlIHRoZSBwZW4gKGNsYXNzaWM6IDIgcm93cyB4IDQgY29scyBhYm92ZSBkb29yKVxuICAgICAgICBjb25zdCBzcGF3bnMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMubWFwUmVuZGVyZXIubWFwRGF0YTtcbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBkYXRhLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGRhdGFbMF0ubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtyXVtjXSA9PT0gdGhpcy5tYXBSZW5kZXJlci5USUxFUy5HSE9TVF9TUEFXTikgc3Bhd25zLnB1c2goe2NvbDogYywgcm93OiByfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwYXducy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgLy8gUGljayBhIHJhbmRvbSBwZW4gdGlsZSBmb3IgZWFjaCBuZXcgZ2hvc3RcbiAgICAgICAgY29uc3QgaWR4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc3Bhd25zLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHNwYXduID0gc3Bhd25zW2lkeF07XG4gICAgICAgIGNvbnN0IHVzZWROYW1lcyA9IHRoaXMuYWN0aXZlR2hvc3RzLm1hcChnID0+IGcubmFtZSk7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IHRoaXMuZ2hvc3RQb29sLmZpbHRlcihnID0+ICF1c2VkTmFtZXMuaW5jbHVkZXMoZy5uYW1lKSk7XG4gICAgICAgIGlmIChhdmFpbGFibGUubGVuZ3RoID09PSAwIHx8IHRoaXMuZ2hvc3RzLmxlbmd0aCA+PSB0aGlzLm1heEdob3N0cykgcmV0dXJuO1xuICAgICAgICBjb25zdCBnaG9zdENvbmZpZyA9IGF2YWlsYWJsZVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhdmFpbGFibGUubGVuZ3RoKV07XG4gICAgICAgIGNvbnN0IGdob3N0U3BlZWQgPSAyO1xuICAgICAgICBjb25zdCBnaG9zdENvbG9yID0gZ2hvc3RDb25maWcuY29sb3IgfHwgJyNGRjAwMDAnO1xuICAgICAgICBjb25zdCBnaG9zdCA9IG5ldyBHaG9zdEVudGl0eShcbiAgICAgICAgICAgIHNwYXduLmNvbCxcbiAgICAgICAgICAgIHNwYXduLnJvdyxcbiAgICAgICAgICAgIHRoaXMubWFwUmVuZGVyZXIudGlsZVNpemUsXG4gICAgICAgICAgICB0aGlzLm1hcFJlbmRlcmVyLm1hcERhdGEsXG4gICAgICAgICAgICBnaG9zdFNwZWVkLFxuICAgICAgICAgICAgZ2hvc3RDb2xvcixcbiAgICAgICAgICAgIHRoaXMubWFwUmVuZGVyZXIuVElMRVNcbiAgICAgICAgKTtcbiAgICAgICAgZ2hvc3QuaW1hZ2UgPSBnaG9zdENvbmZpZy5pbWFnZTtcbiAgICAgICAgZ2hvc3QuZGlzcGxheU5hbWUgPSBnaG9zdENvbmZpZy5uYW1lO1xuICAgICAgICB0aGlzLmdob3N0cy5wdXNoKGdob3N0KTtcbiAgICAgICAgdGhpcy5hY3RpdmVHaG9zdHMucHVzaChnaG9zdENvbmZpZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZSBnaG9zdHMgd2l0aCBwYXRoZmluZGluZyB0byBhIHJhbmRvbSBkZXN0aW5hdGlvbiBvdXRzaWRlIHRoZSBwZW5cbiAgICAgKi9cbiAgICBtb3ZlR2hvc3RzKCkge1xuICAgICAgICBpZiAodGhpcy5nYW1lU3RhdGUgPT0gJ3N0b3BwZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMubWFwUmVuZGVyZXIubWFwRGF0YTtcbiAgICAgICAgY29uc3QgcGVuVGlsZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBkYXRhLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGRhdGFbMF0ubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtyXVtjXSA9PT0gdGhpcy5tYXBSZW5kZXJlci5USUxFUy5HSE9TVF9TUEFXTikgcGVuVGlsZXMucHVzaChgJHtjfSwke3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBnaG9zdCBvZiB0aGlzLmdob3N0cykge1xuICAgICAgICAgICAgaWYgKGdob3N0LnN0YXRlID09PSAnaW5fcGVuJykge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgcmFuZG9tbHkgd2l0aGluIHBlblxuICAgICAgICAgICAgICAgIGNvbnN0IGRpcnMgPSBbJ3VwJywnZG93bicsJ2xlZnQnLCdyaWdodCddLmZpbHRlcihkaXIgPT4gZ2hvc3QuY2FuTW92ZShkaXIpKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpciA9IGRpcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKmRpcnMubGVuZ3RoKV07XG4gICAgICAgICAgICAgICAgICAgIGdob3N0LnNldERpcmVjdGlvbihkaXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGYWxsYmFjazogZm9yY2UtZXZpY3QgYWZ0ZXIgdGltZW91dFxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLmdob3N0UGVuVGltZXJzLmdldChnaG9zdCkgfHwgMDtcbiAgICAgICAgICAgICAgICB0aGlzLmdob3N0UGVuVGltZXJzLnNldChnaG9zdCwgdCArIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0ICsgMSA+IHRoaXMuZ2hvc3RQZW5UaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdob3N0LnNldFN0YXRlKCdleGl0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RQZW5UaW1lcnMuZGVsZXRlKGdob3N0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGljayBhIGRlc3RpbmF0aW9uIE9VVFNJREUgdGhlIHBlbiBPTkxZIGlmIG5vdCBhbHJlYWR5IHNldFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWdob3N0LmRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FuZGlkYXRlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBkYXRhLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBkYXRhWzBdLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbGUgPSBkYXRhW3JdW2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRpbGUgPT09IHRoaXMubWFwUmVuZGVyZXIuVElMRVMuRU1QVFkgfHwgdGlsZSA9PT0gdGhpcy5tYXBSZW5kZXJlci5USUxFUy5ET1QgfHwgdGlsZSA9PT0gdGhpcy5tYXBSZW5kZXJlci5USUxFUy5TVVBFUl9ET1QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAhcGVuVGlsZXMuaW5jbHVkZXMoYCR7Y30sJHtyfWApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAhKGdob3N0LmNvbCA9PT0gYyAmJiBnaG9zdC5yb3cgPT09IHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goe2NvbDogYywgcm93OiByfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdCA9IGNhbmRpZGF0ZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKmNhbmRpZGF0ZXMubGVuZ3RoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2hvc3Quc2V0RGVzdGluYXRpb24oZGVzdCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ2hvc3QubW92ZVRvRGVzdGluYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnaG9zdC5tb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChnaG9zdC5zdGF0ZSA9PT0gJ2V4aXRpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIG1vdmUgdG8gZGVzdGluYXRpb24gaWYgZXhpdGluZ1xuICAgICAgICAgICAgICAgIGdob3N0Lm1vdmVUb0Rlc3RpbmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGdob3N0LmF0RGVzdGluYXRpb24oKSAmJiAhcGVuVGlsZXMuaW5jbHVkZXMoYCR7Z2hvc3QuY29sfSwke2dob3N0LnJvd31gKSkge1xuICAgICAgICAgICAgICAgICAgICBnaG9zdC5zZXRTdGF0ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChnaG9zdC5zdGF0ZSA9PT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBnaG9zdCBpcyBhY3RpdmUgYW5kIGhhcyBubyBkZXN0aW5hdGlvbiBvciBoYXMgcmVhY2hlZCBpdHMgZGVzdGluYXRpb24sIHBpY2sgYSBuZXcgb25lXG4gICAgICAgICAgICAgICAgaWYgKCFnaG9zdC5kZXN0aW5hdGlvbiB8fCBnaG9zdC5hdERlc3RpbmF0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBkYXRhLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGRhdGFbMF0ubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWxlID0gZGF0YVtyXVtjXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRpbGUgPT09IHRoaXMubWFwUmVuZGVyZXIuVElMRVMuRU1QVFkgfHwgdGlsZSA9PT0gdGhpcy5tYXBSZW5kZXJlci5USUxFUy5ET1QgfHwgdGlsZSA9PT0gdGhpcy5tYXBSZW5kZXJlci5USUxFUy5TVVBFUl9ET1QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICFwZW5UaWxlcy5pbmNsdWRlcyhgJHtjfSwke3J9YCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtjb2w6IGMsIHJvdzogcn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXN0ID0gY2FuZGlkYXRlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqY2FuZGlkYXRlcy5sZW5ndGgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdob3N0LnNldERlc3RpbmF0aW9uKGRlc3QsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdob3N0Lm1vdmVUb0Rlc3RpbmF0aW9uKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RQZW5UaW1lcnMuZGVsZXRlKGdob3N0KTtcbiAgICAgICAgICAgICAgICBnaG9zdC5tb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHYW1lIGxvb3BcbiAgICAgKi9cbiAgICBnYW1lTG9vcCgpIHtcbiAgICAgICAgdGhpcy5tYXBSZW5kZXJlci5yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJDb2xsZWN0aWJsZXModGhpcy5tYXBSZW5kZXJlci5jdHgpO1xuICAgICAgICBpZiAodGhpcy5wbGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucGxheWVyLnJlbmRlcih0aGlzLm1hcFJlbmRlcmVyLmN0eCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmdhbWVTdGF0ZSA9PSAncGxheWluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXllci5tb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0NvbGxpc2lvbnModGhpcy5wbGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdhbWVTdGF0ZSA9PT0gJ3dlbGNvbWUnKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdXZWxjb21lU2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5nYW1lU3RhdGUgPT09ICdnYW1lb3ZlcicpIHtcbiAgICAgICAgICAgIGFsZXJ0KCdmJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5nYW1lU3RhdGUgPT0gJ2hpZ2hzY29yZScpIHtcbiAgICAgICAgICAgIGFsZXJ0KCdidXR0cycpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLm1vdmVHaG9zdHMoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZ2hvc3Qgb2YgdGhpcy5naG9zdHMpIGdob3N0LnJlbmRlcih0aGlzLm1hcFJlbmRlcmVyLmN0eCk7XG5cbiAgICAgICAgICAgIC8vIEdob3N0IHJlbGVhc2UgbG9naWNcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RSZWxlYXNlVGltZXIrKztcbiAgICAgICAgICAgIGlmICh0aGlzLmdob3N0UmVsZWFzZVRpbWVyID49IHRoaXMuZ2hvc3RSZWxlYXNlSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwYXduR2hvc3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdob3N0UmVsZWFzZVRpbWVyID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIGNvbGxpc2lvbiBjb29sZG93bnNcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29sbGlzaW9uQ29vbGRvd25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmdhbWVMb29wKCkpO1xuICAgIH1cblxuICAgIGRyYXdXZWxjb21lU2NyZWVuKCkge1xuICAgICAgICB0aGlzLmRyYXdPdmVybGF5KCdXYWthV2FrYScsICdQcmVzcyBFbnRlciB0byBTdGFydCcpO1xuICAgIH1cblxuICAgIGRyYXdPdmVybGF5KHRpdGxlLCBzdWJ0aXRsZSkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLm1hcFJlbmRlcmVyLmN0eDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC44O1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGN0eC5jYW52YXMud2lkdGgsIGN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMS4wO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgY3R4LmZvbnQgPSAnYm9sZCAzMnB4IEFyaWFsJztcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBjdHguZmlsbFRleHQodGl0bGUsIGN0eC5jYW52YXMud2lkdGggLyAyLCBjdHguY2FudmFzLmhlaWdodCAvIDIgLSAyMCk7XG4gICAgICAgIGN0eC5mb250ID0gJzI0cHggQXJpYWwnO1xuICAgICAgICBjdHguZmlsbFRleHQoc3VidGl0bGUsIGN0eC5jYW52YXMud2lkdGggLyAyLCBjdHguY2FudmFzLmhlaWdodCAvIDIgKyAzMCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgcmVuZGVyQ29sbGVjdGlibGVzKGN0eCkge1xuICAgICAgICBpZiAodGhpcy5kb3RzKSB0aGlzLmRvdHMuZm9yRWFjaChkb3QgPT4gZG90LnJlbmRlcihjdHgsIHRoaXMubWFwUmVuZGVyZXIudGlsZVNpemUpKTtcbiAgICAgICAgaWYgKHRoaXMuZnJ1aXQpIHRoaXMuZnJ1aXQuZm9yRWFjaChmcnVpdCA9PiBmcnVpdC5yZW5kZXIoY3R4LCB0aGlzLm1hcFJlbmRlcmVyLnRpbGVTaXplLCB0aGlzLm1hcFJlbmRlcmVyLmVudGl0eUFydCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBldmVyeXRoaW5nIGF0IGEgc3BlY2lmaWMgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGdldFdoYXRJc0F0KGNvbCwgcm93KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHRpbGU6IHRoaXMubWFwUmVuZGVyZXIubWFwRGF0YVtyb3ddID8gdGhpcy5tYXBSZW5kZXJlci5tYXBEYXRhW3Jvd11bY29sXSA6IG51bGwsXG4gICAgICAgICAgICBlbnRpdGllczogW11cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDaGVjayBmb3Igb3RoZXIgZW50aXRpZXMgYXQgdGhpcyBwb3NpdGlvblxuICAgICAgICBpZiAodGhpcy5wbGF5ZXIgJiYgdGhpcy5wbGF5ZXIuY29sID09PSBjb2wgJiYgdGhpcy5wbGF5ZXIucm93ID09PSByb3cpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbnRpdGllcy5wdXNoKHsgdHlwZTogJ3BsYXllcicsIGVudGl0eTogdGhpcy5wbGF5ZXIgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGdob3N0IG9mIHRoaXMuZ2hvc3RzKSB7XG4gICAgICAgICAgICBpZiAoZ2hvc3QuY29sID09PSBjb2wgJiYgZ2hvc3Qucm93ID09PSByb3cpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZW50aXRpZXMucHVzaCh7IHR5cGU6ICdnaG9zdCcsIGVudGl0eTogZ2hvc3QgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wZWxsZXRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBlbGxldCBvZiB0aGlzLnBlbGxldHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGVsbGV0LmNvbCA9PT0gY29sICYmIHBlbGxldC5yb3cgPT09IHJvdykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZW50aXRpZXMucHVzaCh7IHR5cGU6ICdwZWxsZXQnLCBlbnRpdHk6IHBlbGxldCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5mcnVpdHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJ1aXQgb2YgdGhpcy5mcnVpdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJ1aXQuY29sID09PSBjb2wgJiYgZnJ1aXQucm93ID09PSByb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVudGl0aWVzLnB1c2goeyB0eXBlOiAnZnJ1aXQnLCBlbnRpdHk6IGZydWl0IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZSBjb2xsaXNpb24gZXZlbnRzIGZvciBlbnRpdHkgaGl0dGluZyBzb21ldGhpbmdcbiAgICAgKi9cbiAgICBmaXJlQ29sbGlzaW9uRXZlbnRzKGVudGl0eSwgY29sbGlzaW9ucykge1xuICAgICAgICBjb25zdCBlbnRpdHlUeXBlID0gdGhpcy5nZXRFbnRpdHlUeXBlKGVudGl0eSk7XG4gICAgICAgIFxuICAgICAgICAvLyBIYW5kbGUgZW50aXR5IHZzIGVudGl0eSBjb2xsaXNpb25zXG4gICAgICAgIGZvciAoY29uc3QgY29sbGlzaW9uIG9mIGNvbGxpc2lvbnMuZW50aXRpZXMpIHtcbiAgICAgICAgICAgIGlmIChjb2xsaXNpb24uZW50aXR5ID09PSBlbnRpdHkpIGNvbnRpbnVlOyAvLyBEb24ndCBjb2xsaWRlIHdpdGggc2VsZlxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtlbnRpdHlUeXBlfToke2NvbGxpc2lvbi50eXBlfToke2NvbGxpc2lvbi5lbnRpdHkuaWQgfHwgY29sbGlzaW9uLmVudGl0eS5kaXNwbGF5TmFtZSB8fCBjb2xsaXNpb24uZW50aXR5LmNvbG9yfWA7XG5cbiAgICAgICAgICAgIGlmIChlbnRpdHlUeXBlID09ICdnaG9zdCcgJiYgY29sbGlzaW9uLnR5cGUgPT09ICdnaG9zdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbnRpdHlUeXBlID09PSAnZ2hvc3QnICYmIGNvbGxpc2lvbi50eXBlID09PSAncGxheWVyJykge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdlIGlnbm9yZSB0aGlzIG9uZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVudGl0eVR5cGUgPT09ICdwbGF5ZXInICYmIGNvbGxpc2lvbi50eXBlID09PSAnZ2hvc3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gUGxheWVyIGNvbGxpZGVkIHdpdGggZ2hvc3RcbiAgICAgICAgICAgICAgICBjb25zdCBpc1N1cGVyID0gdHlwZW9mIGVudGl0eS5pc1N1cGVyU3RhdGUgPT09ICdmdW5jdGlvbicgPyBlbnRpdHkuaXNTdXBlclN0YXRlKCkgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdXBlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc3VwZXIgdXNlcicpO1xuICAgICAgICAgICAgICAgICAgICAvLyBQbGF5ZXIgd2luczogZ2hvc3Qgc2hvdWxkIGdvIHRvIHBlbiwgYXdhcmQgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IGNvbGxpc2lvbi5lbnRpdHkub3B0aW9ucz8ucG9pbnRzIHx8IHNldHRpbmdzLmdob3N0UG9pbnRzIHx8IDIwMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25FbWl0dGVyLmVtaXQoJ2dob3N0LWVhdGVuJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVyOiBlbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBnaG9zdDogY29sbGlzaW9uLmVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICdnaG9zdHkhJ1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC8vIEdob3N0IHdpbnM6IHBsYXllciBzaG91bGQgcmVzcGF3biwgbG9zZSBsaWZlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IHNldHRpbmdzLnBsYXllckRlYXRoUG9pbnRzIHx8IDA7IC8vIFVzdWFsbHkgMCBmb3IgcGxheWVyIGRlYXRoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uRW1pdHRlci5lbWl0KCdwbGF5ZXItZWF0ZW4nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5ZXI6IGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdob3N0OiBjb2xsaXNpb24uZW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldEV2ZW50Q29vbGRvd24oa2V5KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZEZpcmVFdmVudChrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25FbWl0dGVyLmVtaXQoYCR7ZW50aXR5VHlwZX0tJHtjb2xsaXNpb24udHlwZX1gLCB7XG4gICAgICAgICAgICAgICAgICAgIFtlbnRpdHlUeXBlXTogZW50aXR5LFxuICAgICAgICAgICAgICAgICAgICBbY29sbGlzaW9uLnR5cGVdOiBjb2xsaXNpb24uZW50aXR5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFdmVudENvb2xkb3duKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHRpbGUgY29sbGlzaW9ucyAocG9ydGFscywgY29sbGVjdGlibGVzIG9uIG1hcClcbiAgICAgICAgaWYgKGNvbGxpc2lvbnMudGlsZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVUaWxlQ29sbGlzaW9uKGVudGl0eSwgY29sbGlzaW9ucy50aWxlLCBlbnRpdHkuY29sLCBlbnRpdHkucm93KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlbGVwb3J0IGVudGl0eSB0byBkZXN0aW5hdGlvblxuICAgICAqL1xuICAgIHRlbGVwb3J0RW50aXR5KGVudGl0eSwgZGVzdCkge1xuICAgICAgICBlbnRpdHkuY29sID0gZGVzdC5jb2w7XG4gICAgICAgIGVudGl0eS5yb3cgPSBkZXN0LnJvdztcbiAgICAgICAgZW50aXR5LnggPSBkZXN0LmNvbCAqIGVudGl0eS50aWxlU2l6ZTtcbiAgICAgICAgZW50aXR5LnkgPSBkZXN0LnJvdyAqIGVudGl0eS50aWxlU2l6ZTtcbiAgICAgICAgZW50aXR5LnRhcmdldFggPSBlbnRpdHkueDtcbiAgICAgICAgZW50aXR5LnRhcmdldFkgPSBlbnRpdHkueTtcbiAgICAgICAgZW50aXR5Lm1vdmluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBlbnRpdHkgdHlwZSBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXRFbnRpdHlUeXBlKGVudGl0eSkge1xuICAgICAgICBpZiAoZW50aXR5ID09PSB0aGlzLnBsYXllcikgcmV0dXJuICdwbGF5ZXInO1xuICAgICAgICBpZiAodGhpcy5naG9zdHMuaW5jbHVkZXMoZW50aXR5KSkgcmV0dXJuICdnaG9zdCc7XG4gICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgZXZlbnQgc2hvdWxkIGZpcmUgKG5vdCBpbiBjb29sZG93bilcbiAgICAgKi9cbiAgICBzaG91bGRGaXJlRXZlbnQoa2V5KSB7XG4gICAgICAgIGNvbnN0IGNvb2xkb3duID0gdGhpcy5jb2xsaXNpb25Db29sZG93bnMuZ2V0KGtleSkgfHwgMDtcbiAgICAgICAgcmV0dXJuIGNvb2xkb3duID09PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBldmVudCBjb29sZG93blxuICAgICAqL1xuICAgIHNldEV2ZW50Q29vbGRvd24oa2V5KSB7XG4gICAgICAgIHRoaXMuY29sbGlzaW9uQ29vbGRvd25zLnNldChrZXksIHRoaXMuY29sbGlzaW9uQ29vbGRvd25GcmFtZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBjb2xsaXNpb24gY29vbGRvd25zIGVhY2ggZnJhbWVcbiAgICAgKi9cbiAgICB1cGRhdGVDb2xsaXNpb25Db29sZG93bnMoKSB7XG4gICAgICAgIC8vIERlY3JlbWVudCBjb2xsaXNpb24gY29vbGRvd25zXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuY29sbGlzaW9uQ29vbGRvd25zLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uQ29vbGRvd25zLnNldChrZXksIHZhbHVlIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVjcmVtZW50IHBvcnRhbCBjb29sZG93bnNcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5wb3J0YWxDb29sZG93bnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0YWxDb29sZG93bnMuc2V0KGtleSwgdmFsdWUgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIHBvcnRhbC90dW5uZWwgdGlsZSBvbiB0aGUgb3Bwb3NpdGUgc2lkZVxuICAgIGZpbmRPcHBvc2l0ZVBvcnRhbChjb2wsIHJvdykge1xuICAgICAgICBjb25zdCBwb3J0YWxzID0gW107XG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwUmVuZGVyZXIubWFwRGF0YTtcbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBtYXAubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgbWFwWzBdLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcFtyXVtjXSA9PT0gdGhpcy5tYXBSZW5kZXJlci5USUxFUy5QT1JUQUwgJiYgKGMgIT09IGNvbCB8fCByICE9PSByb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcnRhbHMucHVzaCh7IGNvbDogYywgcm93OiByIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9ydGFscy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICAgICAgICBpZiAocG9ydGFscy5sZW5ndGggPT09IDEpIHJldHVybiBwb3J0YWxzWzBdO1xuICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggYnkgcm93IChsZWZ0L3JpZ2h0IHR1bm5lbHMpXG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBwb3J0YWxzKSB7XG4gICAgICAgICAgICBpZiAocC5yb3cgPT09IHJvdykgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm90IGZvdW5kLCB0cnkgdG8gbWF0Y2ggYnkgY29sdW1uICh0b3AvYm90dG9tIHR1bm5lbHMpXG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBwb3J0YWxzKSB7XG4gICAgICAgICAgICBpZiAocC5jb2wgPT09IGNvbCkgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2s6IHBpY2sgdGhlIGZhcnRoZXN0IChjbGFzc2ljIFBhYy1NYW46IGxlZnQvcmlnaHQgZWRnZSlcbiAgICAgICAgbGV0IG1heERpc3QgPSAtMSwgYmVzdCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBwb3J0YWxzKSB7XG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5hYnMocC5jb2wgLSBjb2wpICsgTWF0aC5hYnMocC5yb3cgLSByb3cpO1xuICAgICAgICAgICAgaWYgKGRpc3QgPiBtYXhEaXN0KSB7XG4gICAgICAgICAgICAgICAgbWF4RGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgYmVzdCA9IHA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3Q7XG4gICAgfVxuXG4gICAgLy8gSGVscGVyOiBib3VuZGluZy1ib3ggY29sbGlzaW9uIGZvciBlbnRpdGllc1xuICAgIGlzRW50aXR5Q29sbGlkaW5nKGEsIGIpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgubWluKGEudGlsZVNpemUsIGIudGlsZVNpemUpICogMC42OyAvLyA2MCUgb2YgdGlsZSBzaXplIGZvciBoaXRib3hcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIE1hdGguYWJzKGEueCAtIGIueCkgPCBzaXplICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhLnkgLSBiLnkpIDwgc2l6ZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHNldFNjb3JlKHZhbCkge1xuICAgICAgICB0aGlzLnNjb3JlID0gdmFsO1xuICAgICAgICBjb25zb2xlLmxvZygnU2NvcmUgdXBkYXRlZDonLCB2YWwpO1xuICAgICAgICB0aGlzLnVwZGF0ZVVJICYmIHRoaXMudXBkYXRlVUkoKTtcbiAgICB9XG4gICAgZ2V0U2NvcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3JlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdhbWUgbG9vcFxuICAgICAqL1xuICAgIGdhbWVMb29wKCkge1xuICAgICAgICB0aGlzLm1hcFJlbmRlcmVyLnJlbmRlcigpO1xuICAgICAgICB0aGlzLnJlbmRlckNvbGxlY3RpYmxlcyh0aGlzLm1hcFJlbmRlcmVyLmN0eCk7XG4gICAgICAgIGlmICh0aGlzLnBsYXllcikge1xuICAgICAgICAgICAgdGhpcy5wbGF5ZXIucmVuZGVyKHRoaXMubWFwUmVuZGVyZXIuY3R4KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZ2FtZVN0YXRlID09ICdwbGF5aW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMucGxheWVyLm1vdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ29sbGlzaW9ucyh0aGlzLnBsYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2FtZVN0YXRlID09PSAnd2VsY29tZScpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1dlbGNvbWVTY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmdhbWVTdGF0ZSA9PT0gJ2dhbWVvdmVyJykge1xuICAgICAgICAgICAgYWxlcnQoJ2YnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmdhbWVTdGF0ZSA9PSAnaGlnaHNjb3JlJykge1xuICAgICAgICAgICAgYWxlcnQoJ2J1dHRzJyk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMubW92ZUdob3N0cygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBnaG9zdCBvZiB0aGlzLmdob3N0cykgZ2hvc3QucmVuZGVyKHRoaXMubWFwUmVuZGVyZXIuY3R4KTtcblxuICAgICAgICAgICAgLy8gR2hvc3QgcmVsZWFzZSBsb2dpY1xuICAgICAgICAgICAgdGhpcy5naG9zdFJlbGVhc2VUaW1lcisrO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2hvc3RSZWxlYXNlVGltZXIgPj0gdGhpcy5naG9zdFJlbGVhc2VJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Bhd25HaG9zdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RSZWxlYXNlVGltZXIgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgY29sbGlzaW9uIGNvb2xkb3duc1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDb2xsaXNpb25Db29sZG93bnMoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuZ2FtZUxvb3AoKSk7XG4gICAgfVxufVxuXG4vLyBVdGlsaXR5IHRvIGNvbnZlcnQgbWFwRGF0YSB0byBQYXRoRmluZGluZy5qcyBncmlkIGZvcm1hdFxuZnVuY3Rpb24gbWFrZVBGR3JpZChtYXBEYXRhLCB3YWxrYWJsZVRpbGVzKSB7XG4gICAgY29uc3QgZ3JpZCA9IFtdO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgbWFwRGF0YS5sZW5ndGg7IHIrKykge1xuICAgICAgICBjb25zdCByb3cgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBtYXBEYXRhWzBdLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAvLyAwID0gd2Fsa2FibGUsIDEgPSBibG9ja2VkXG4gICAgICAgICAgICByb3cucHVzaCh3YWxrYWJsZVRpbGVzLmluY2x1ZGVzKG1hcERhdGFbcl1bY10pID8gMCA6IDEpO1xuICAgICAgICB9XG4gICAgICAgIGdyaWQucHVzaChyb3cpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFBGLkdyaWQoZ3JpZCk7XG59XG5cbi8vIEFkZCBldmVudCBlbWl0dGVyIGZvciB0aWxlIGV2ZW50c1xuY2xhc3MgVGlsZUV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIG9uKGNiKSB7IHRoaXMubGlzdGVuZXJzLnB1c2goY2IpOyB9XG4gICAgZW1pdChldmVudCkgeyB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGNiID0+IGNiKGV2ZW50KSk7IH1cbn1cblxuLy8gSW5pdGlhbGl6ZSBnYW1lIHdoZW4gc2NyaXB0IGxvYWRzXG5jb25zdCBnYW1lID0gbmV3IEdhbWUoKTsiXSwibmFtZXMiOlsic2V0dGluZ3MiLCJkZWJvdW5jZSIsInRocm90dGxlTGVhZGluZyIsIklucHV0SGFuZGxlciIsIk1hcFJlbmRlcmVyIiwiUGxheWVyRW50aXR5IiwiR2hvc3RFbnRpdHkiLCJQRiIsImVudGl0eUFydCIsIkV2ZW50RW1pdHRlciIsIkNvbGxlY3RpYmxlRW50aXR5IiwiQ29sbGVjdGlibGVTcGF3bmVyIiwiR2FtZSIsIl90aGlzIiwiX2NsYXNzQ2FsbENoZWNrIiwiX2RlZmluZVByb3BlcnR5IiwiY2FudmFzIiwibWFwUmVuZGVyZXIiLCJpbnB1dEhhbmRsZXIiLCJnYW1lU3RhdGUiLCJjdXJyZW50TWFwIiwicGxheWVyIiwic2NvcmUiLCJsaXZlcyIsImxldmVsIiwibW92ZUluYyIsInNwZWVkIiwiZ2FtZVRpbWUiLCJtYXplU291cmNlIiwiYmFzaWNWaXNpb24iLCJyZXNldE1vZGVPblJlc2V0R2FtZSIsImV4Y2x1ZGVSZXZlcnNlRGlyZWN0aW9uSW5SYW5kb21Nb2RlIiwiZngiLCJleHRyYXMiLCJtYXhHaG9zdHMiLCJzZXRDYWxsYmFja3MiLCJvbkRpcmVjdGlvbkNoYW5nZSIsImRpciIsImNvbnNvbGUiLCJsb2ciLCJvbktleVByZXNzIiwiY29kZSIsImV2ZW50IiwidG9Mb3dlckNhc2UiLCJiaW5kIiwib25QYXVzZSIsIm9uUmVzZXQiLCJkb2N1bWVudCIsInJlYWR5U3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwiaW5pdCIsInRpbGVFdmVudEVtaXR0ZXIiLCJUaWxlRXZlbnRFbWl0dGVyIiwiZ2hvc3RSZWxlYXNlVGltZXIiLCJnaG9zdFJlbGVhc2VJbnRlcnZhbCIsImdob3N0UG9vbCIsIl90b0NvbnN1bWFibGVBcnJheSIsImdob3N0cyIsImFjdGl2ZUdob3N0cyIsImNvbGxpc2lvbkVtaXR0ZXIiLCJnaG9zdFBlblRpbWVycyIsIk1hcCIsImdob3N0RXhpdFRpbWVycyIsImdob3N0RXhpdFRpbWVvdXQiLCJnaG9zdFBlblRpbWVvdXQiLCJjb2xsaXNpb25Db29sZG93bnMiLCJjb2xsaXNpb25Db29sZG93bkZyYW1lcyIsInBvcnRhbENvb2xkb3ducyIsInBvcnRhbENvb2xkb3duRnJhbWVzIiwib24iLCJ0eXBlIiwic2V0U3VwZXJTdGF0ZSIsInNldFRpbWVvdXQiLCJtZWdhUGVsbGV0RHVyYXRpb24iLCJtYXBEYXRhIiwibWluRGlzdGFuY2UiLCJ1c2VkU3BvdHMiLCJTZXQiLCJmb3JFYWNoIiwiZ2hvc3QiLCJpZHgiLCJzdGF0ZSIsInRyaWVzIiwiZGVzdCIsImFuZ2xlIiwiTWF0aCIsInJhbmRvbSIsIlBJIiwiZGlzdCIsImZsb29yIiwiY29sIiwibWF4IiwibWluIiwibGVuZ3RoIiwicm91bmQiLCJjb3MiLCJyb3ciLCJzaW4iLCJUSUxFUyIsIkVNUFRZIiwiaGFzIiwiY29uY2F0IiwiYWRkIiwic2V0RGVzdGluYXRpb24iLCJtb3ZlVG9EZXN0aW5hdGlvbiIsInBhdGhTdGVwIiwiX2NyZWF0ZUNsYXNzIiwia2V5IiwidmFsdWUiLCJnZXRFbGVtZW50QnlJZCIsImVycm9yIiwiY3N2Iiwid2luZG93IiwibGFyYWNvbm1hbk1hemVDc3YiLCJfbWFwQXJyYXkkIiwibWFwQXJyYXkiLCJwYXJzZUFuZEFkYXB0TWF6ZUNzdiIsIndpZHRoIiwiaGVpZ2h0Iiwibm9ybWFsaXplZENzdiIsIm1hcCIsImpvaW4iLCJsb2FkTWFwIiwicmVuZGVyIiwiaW5pdFBsYXllciIsInRpbGVTaXplIiwiaW5pdENvbGxlY3RpYmxlcyIsImluaXRFdmVudExpc3RlbmVycyIsImdhbWVMb29wIiwidGlsZVR5cGVzIiwic3Bhd25lciIsIl9zcGF3bmVyJHNwYXduQ29sbGVjdCIsInNwYXduQ29sbGVjdGlibGVzIiwic3VwZXJkb3RzIiwiZG90cyIsImZydWl0IiwiX3RoaXMyIiwiX3JlZiIsImNvbnN1bWVkIiwic2V0U2NvcmUiLCJnZXRTY29yZSIsIm9wdGlvbnMiLCJwb2ludHMiLCJET1QiLCJmaWx0ZXIiLCJkb3QiLCJTVVBFUl9ET1QiLCJGUlVJVCIsIl9yZWYyIiwiZGlzcGxheU5hbWUiLCJjb2xvciIsIl9yZWYzIiwiZGllIiwidXBkYXRlVUkiLCJzZXREaXJlY3Rpb24iLCJfcmVmNCIsImZvdW5kIiwiciIsImMiLCJHSE9TVF9TUEFXTiIsIngiLCJ5Iiwic2V0dXBVSSIsIl90aGlzMyIsInN0YXJ0QnRuIiwicGF1c2VCdG4iLCJyZXNldEJ0biIsInN0YXJ0R2FtZSIsInRvZ2dsZVBhdXNlIiwicmVzZXRHYW1lIiwibG9hZE1hcEZyb21ET00iLCJtYXBEYXRhU2NyaXB0IiwiSlNPTiIsInBhcnNlIiwidGV4dENvbnRlbnQiLCJlIiwiZ2FtZU1hcERhdGEiLCJ3YXJuIiwibG9hZFRlc3RNYXAiLCJkZXNpZ24iLCJuYW1lIiwidGVzdE1hcCIsInJlc2V0IiwiaGFuZGxlRGlyZWN0aW9uQ2hhbmdlIiwiZGlyZWN0aW9uIiwic2NvcmVFbGVtZW50IiwibGl2ZXNFbGVtZW50IiwiZGlzYWJsZWQiLCJnZXRHYW1lU3RhdGUiLCJnZXRDdXJyZW50TWFwIiwiX3RoaXM0IiwicGVuVGlsZXMiLCJwdXNoIiwicGxheWVyU3RhcnQiLCJwZW5Db2xzIiwidCIsInBlblJvd3MiLCJtaW5Db2wiLCJhcHBseSIsIm1heENvbCIsIm1heFJvdyIsImNlbnRlckNvbCIsIm91dGVyIiwiY2hlY2tDb2xsaXNpb25zIiwiZW50aXR5IiwiX2l0ZXJhdG9yIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiLCJfc3RlcCIsInMiLCJuIiwiZG9uZSIsInBsYXllckRlYXRoUG9pbnRzIiwiZW1pdCIsIl9naG9zdCRvcHRpb25zIiwiZ2hvc3RQb2ludHMiLCJlcnIiLCJmIiwiX2l0ZXJhdG9yMiIsIl9zdGVwMiIsImkiLCJzcHJpdGUiLCJ0aWxlIiwiUE9SVEFMIiwiZW50aXR5VHlwZSIsInBvcnRhbEtleSIsImNvb2xkb3duIiwiZ2V0IiwiZmluZE9wcG9zaXRlUG9ydGFsIiwiZGVzdEtleSIsInNldCIsImRDb2wiLCJkUm93IiwiY2VudGVyUm93IiwibmV3Q29sIiwibmV3Um93Iiwid2Fsa2FibGUiLCJpbmNsdWRlcyIsInRlbGVwb3J0RW50aXR5IiwiZWplY3Rpb25LZXkiLCJmcm9tIiwidG8iLCJkZXN0aW5hdGlvbiIsInBhdGgiLCJzcGF3bkdob3N0Iiwic3Bhd25zIiwiZGF0YSIsInNwYXduIiwidXNlZE5hbWVzIiwiZyIsImF2YWlsYWJsZSIsImdob3N0Q29uZmlnIiwiZ2hvc3RTcGVlZCIsImdob3N0Q29sb3IiLCJpbWFnZSIsIm1vdmVHaG9zdHMiLCJfdGhpczUiLCJfaXRlcmF0b3IzIiwiX3N0ZXAzIiwiX2xvb3AiLCJkaXJzIiwiY2FuTW92ZSIsInNldFN0YXRlIiwiY2FuZGlkYXRlcyIsIm1vdmUiLCJhdERlc3RpbmF0aW9uIiwiX3RoaXM2IiwicmVuZGVyQ29sbGVjdGlibGVzIiwiY3R4IiwiZHJhd1dlbGNvbWVTY3JlZW4iLCJhbGVydCIsIl9pdGVyYXRvcjQiLCJfc3RlcDQiLCJ1cGRhdGVDb2xsaXNpb25Db29sZG93bnMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkcmF3T3ZlcmxheSIsInRpdGxlIiwic3VidGl0bGUiLCJzYXZlIiwiZ2xvYmFsQWxwaGEiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImZvbnQiLCJ0ZXh0QWxpZ24iLCJmaWxsVGV4dCIsInJlc3RvcmUiLCJfdGhpczciLCJnZXRXaGF0SXNBdCIsInJlc3VsdCIsImVudGl0aWVzIiwiX2l0ZXJhdG9yNSIsIl9zdGVwNSIsInBlbGxldHMiLCJfaXRlcmF0b3I2IiwiX3N0ZXA2IiwicGVsbGV0IiwiZnJ1aXRzIiwiX2l0ZXJhdG9yNyIsIl9zdGVwNyIsImZpcmVDb2xsaXNpb25FdmVudHMiLCJjb2xsaXNpb25zIiwiZ2V0RW50aXR5VHlwZSIsIl9pdGVyYXRvcjgiLCJfc3RlcDgiLCJjb2xsaXNpb24iLCJpZCIsImlzU3VwZXIiLCJpc1N1cGVyU3RhdGUiLCJfY29sbGlzaW9uJGVudGl0eSRvcHQiLCJzZXRFdmVudENvb2xkb3duIiwic2hvdWxkRmlyZUV2ZW50IiwiaGFuZGxlVGlsZUNvbGxpc2lvbiIsInRhcmdldFgiLCJ0YXJnZXRZIiwibW92aW5nIiwiX2l0ZXJhdG9yOSIsImVudHJpZXMiLCJfc3RlcDkiLCJfc3RlcDkkdmFsdWUiLCJfc2xpY2VkVG9BcnJheSIsIl9pdGVyYXRvcjAiLCJfc3RlcDAiLCJfc3RlcDAkdmFsdWUiLCJwb3J0YWxzIiwiX2kyIiwiX3BvcnRhbHMiLCJwIiwiX2kzIiwiX3BvcnRhbHMyIiwibWF4RGlzdCIsImJlc3QiLCJfaTQiLCJfcG9ydGFsczMiLCJhYnMiLCJpc0VudGl0eUNvbGxpZGluZyIsImEiLCJiIiwic2l6ZSIsInZhbCIsImNzdlN0cmluZyIsInJvd3MiLCJ0cmltIiwic3BsaXQiLCJOdW1iZXIiLCJtYWtlUEZHcmlkIiwid2Fsa2FibGVUaWxlcyIsImdyaWQiLCJHcmlkIiwibGlzdGVuZXJzIiwiY2IiLCJnYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/assets/js/game.js\n\n}");

/***/ }),

/***/ "./resources/assets/js/ghost-entity.js":
/*!*********************************************!*\
  !*** ./resources/assets/js/ghost-entity.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GhostEntity)\n/* harmony export */ });\n/* harmony import */ var pathfinding__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pathfinding */ \"./node_modules/pathfinding/index.js\");\n/* harmony import */ var pathfinding__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pathfinding__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// ghost-entity.js\n// Minimal, extensible GhostEntity class for movement, collision, and future pathfinding\n\n\nvar GhostEntity = /*#__PURE__*/function () {\n  function GhostEntity(startCol, startRow, tileSize, mapData) {\n    var speed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;\n    var color = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '#FF0000';\n    var tiles = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n    var image = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n    _classCallCheck(this, GhostEntity);\n    this.col = startCol;\n    this.row = startRow;\n    this.tileSize = tileSize;\n    this.mapData = mapData; // reference to current map\n    this.direction = 'left'; // default\n    this.nextDirection = null;\n    this.speed = speed;\n    this.x = this.col * tileSize;\n    this.y = this.row * tileSize;\n    this.targetX = this.x;\n    this.targetY = this.y;\n    this.moving = false;\n    this.color = color;\n    this.image = image;\n    this.state = 'in_pen'; // 'in_pen', 'exiting', 'active'\n    this.exitTarget = null;\n    this.destination = null;\n    this.path = null;\n    this.pathStep = 0;\n    this.TILES = tiles;\n    this.lastPosition = null; // Track previous tile\n  }\n  return _createClass(GhostEntity, [{\n    key: \"setState\",\n    value: function setState(state) {\n      var exitTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      this.state = state;\n      this.exitTarget = exitTarget;\n      // When entering 'exiting', clear previous destination if just left pen\n      if (state === 'exiting' && this.destination && this.state !== 'exiting') {\n        this.destination = null;\n        this.path = null;\n        this.pathStep = 0;\n      }\n    }\n  }, {\n    key: \"setDirection\",\n    value: function setDirection(dir) {\n      this.nextDirection = dir;\n    }\n  }, {\n    key: \"canMove\",\n    value: function canMove(dir) {\n      var _GhostEntity$directio = GhostEntity.directionDelta(dir),\n        _GhostEntity$directio2 = _slicedToArray(_GhostEntity$directio, 2),\n        dCol = _GhostEntity$directio2[0],\n        dRow = _GhostEntity$directio2[1];\n      var nCol = this.col + dCol;\n      var nRow = this.row + dRow;\n      if (nCol < 0 || nRow < 0 || nRow >= this.mapData.length || nCol >= this.mapData[0].length) return false;\n      // Allow movement on walkable tiles always if not in_pen\n\n      if (this.state === 'exiting') {\n\n        //            return walkable.some(Boolean);\n      }\n      if (this.state === 'exiting' || this.state === 'active') {\n        var walkable = [this.mapData[nRow][nCol] === this.TILES.EMPTY, this.mapData[nRow][nCol] === this.TILES.DOT, this.mapData[nRow][nCol] === this.TILES.SUPER_DOT, this.mapData[nRow][nCol] === this.TILES.GHOST_DOOR, this.mapData[nRow][nCol] === this.TILES.GHOST_SPAWN];\n        return walkable.some(Boolean);\n      }\n      // If in_pen, only allow movement inside pen (GHOST_SPAWN)\n      return this.mapData[nRow][nCol] === this.TILES.GHOST_SPAWN;\n    }\n  }, {\n    key: \"move\",\n    value: function move() {\n      if (!this.moving) {\n        if (this.nextDirection && this.canMove(this.nextDirection)) {\n          this.direction = this.nextDirection;\n          this.nextDirection = null;\n        }\n        if (this.canMove(this.direction)) {\n          var _GhostEntity$directio3 = GhostEntity.directionDelta(this.direction),\n            _GhostEntity$directio4 = _slicedToArray(_GhostEntity$directio3, 2),\n            dCol = _GhostEntity$directio4[0],\n            dRow = _GhostEntity$directio4[1];\n          this.targetX = (this.col + dCol) * this.tileSize;\n          this.targetY = (this.row + dRow) * this.tileSize;\n          this.moving = true;\n        }\n      }\n      if (this.moving) {\n        var dx = this.targetX - this.x;\n        var dy = this.targetY - this.y;\n        var dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist <= this.speed) {\n          this.x = this.targetX;\n          this.y = this.targetY;\n          var _GhostEntity$directio5 = GhostEntity.directionDelta(this.direction),\n            _GhostEntity$directio6 = _slicedToArray(_GhostEntity$directio5, 2),\n            _dCol = _GhostEntity$directio6[0],\n            _dRow = _GhostEntity$directio6[1];\n          this.col += _dCol;\n          this.row += _dRow;\n          this.moving = false;\n        } else {\n          var angle = Math.atan2(dy, dx);\n          this.x += this.speed * Math.cos(angle);\n          this.y += this.speed * Math.sin(angle);\n        }\n      }\n    }\n  }, {\n    key: \"isAt\",\n    value: function isAt(col, row) {\n      return this.col === col && this.row === row;\n    }\n  }, {\n    key: \"render\",\n    value: function render(ctx) {\n      var _this = this;\n      ctx.save();\n      if (this.image) {\n        // Draw PNG/SVG art\n        var img = this._artImg || (this._artImg = new Image());\n        if (!img.src) img.src = this.image;\n        if (img.complete) {\n          ctx.drawImage(img, this.x, this.y, this.tileSize, this.tileSize);\n        } else {\n          img.onload = function () {\n            ctx.drawImage(img, _this.x, _this.y, _this.tileSize, _this.tileSize);\n          };\n        }\n      } else {\n        ctx.fillStyle = this.color;\n        ctx.beginPath();\n        ctx.arc(this.x + this.tileSize / 2, this.y + this.tileSize / 2, this.tileSize / 2 - 2, 0, 2 * Math.PI);\n        ctx.fill();\n      }\n      ctx.restore();\n    }\n  }, {\n    key: \"setDestination\",\n    value: function setDestination(dest, mapData) {\n      if (this.lastPosition && dest.col === this.lastPosition.col && dest.row === this.lastPosition.row) {\n        // Don't allow immediate reversal to previous position\n        return;\n      }\n      this.destination = dest;\n      // Convert mapData to PF grid for full maze\n      var walkable = [this.TILES.EMPTY, this.TILES.DOT, this.TILES.SUPER_DOT, this.TILES.GHOST_DOOR, this.TILES.GHOST_SPAWN];\n      var pfGrid = makePFGrid(mapData, walkable);\n      var finder = new (pathfinding__WEBPACK_IMPORTED_MODULE_0___default().AStarFinder)();\n      var pathArr = finder.findPath(this.col, this.row, dest.col, dest.row, pfGrid);\n      // Convert [col,row] array to [{col,row}] for compatibility\n      this.path = pathArr.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          c = _ref2[0],\n          r = _ref2[1];\n        return {\n          col: c,\n          row: r\n        };\n      });\n      this.pathStep = 1;\n    }\n  }, {\n    key: \"moveToDestination\",\n    value: function moveToDestination() {\n      // If path is missing or blocked, try to recompute a new path\n      if (!this.path || this.pathStep >= this.path.length) {\n        if (this.destination) {\n          this.path = GhostEntity.bfsPath(this.mapData, {\n            col: this.col,\n            row: this.row\n          }, this.destination);\n          this.pathStep = 1;\n        }\n        // If still no path, abandon destination\n        if (!this.path || this.path.length < 2) {\n          this.destination = null;\n          this.path = null;\n          this.pathStep = 0;\n          return;\n        }\n      }\n\n      // --- FORCE EXIT LOGIC ---\n      if (this.state === 'exiting') {\n        // If the next step is a GHOST_DOOR or EMPTY, always take it immediately\n        var _next = this.path[this.pathStep];\n        if (!_next) return;\n        var nextType = this.mapData[_next.row][_next.col];\n        if (nextType === this.TILES.GHOST_DOOR || nextType === this.TILES.EMPTY) {\n          if (_next.col > this.col) this.setDirection('right');else if (_next.col < this.col) this.setDirection('left');else if (_next.row > this.row) this.setDirection('down');else if (_next.row < this.row) this.setDirection('up');\n          this.move();\n          if (this.col === _next.col && this.row === _next.row) this.pathStep++;\n          return;\n        }\n      }\n      // Default: follow path\n      var next = this.path[this.pathStep];\n      if (!next) return;\n      if (this.col === next.col && this.row === next.row) {\n        this.lastPosition = {\n          col: this.col,\n          row: this.row\n        };\n      }\n      if (next.col > this.col) this.setDirection('right');else if (next.col < this.col) this.setDirection('left');else if (next.row > this.row) this.setDirection('down');else if (next.row < this.row) this.setDirection('up');\n      this.move();\n      if (this.col === next.col && this.row === next.row) this.pathStep++;\n    }\n  }, {\n    key: \"atDestination\",\n    value: function atDestination() {\n      return this.destination && this.col === this.destination.col && this.row === this.destination.row;\n    }\n  }], [{\n    key: \"directionDelta\",\n    value: function directionDelta(dir) {\n      switch (dir) {\n        case 'left':\n          return [-1, 0];\n        case 'right':\n          return [1, 0];\n        case 'up':\n          return [0, -1];\n        case 'down':\n          return [0, 1];\n        default:\n          return [0, 0];\n      }\n    }\n  }, {\n    key: \"bfsPath\",\n    value: function bfsPath(mapData, start, goal) {\n      var walkableTiles = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, 1, 3, 5];\n      var queue = [[start]];\n      var visited = new Set();\n      var key = function key(c, r) {\n        return \"\".concat(c, \",\").concat(r);\n      };\n      visited.add(key(start.col, start.row));\n      var height = mapData.length;\n      var width = mapData[0].length;\n      while (queue.length) {\n        var path = queue.shift();\n        var _path = path[path.length - 1],\n          col = _path.col,\n          row = _path.row;\n        if (col === goal.col && row === goal.row) return path;\n        for (var _i = 0, _arr = [[0, 1], [1, 0], [0, -1], [-1, 0]]; _i < _arr.length; _i++) {\n          var _arr$_i = _slicedToArray(_arr[_i], 2),\n            dc = _arr$_i[0],\n            dr = _arr$_i[1];\n          var nc = col + dc,\n            nr = row + dr;\n          if (nc < 0 || nr < 0 || nc >= width || nr >= height) continue;\n          if (!walkableTiles.includes(mapData[nr][nc])) continue;\n          var k = key(nc, nr);\n          if (visited.has(k)) continue;\n          visited.add(k);\n          queue.push([].concat(_toConsumableArray(path), [{\n            col: nc,\n            row: nr\n          }]));\n        }\n      }\n      return null;\n    }\n  }]);\n}();\n\nfunction makePFGrid(mapData, walkableTiles) {\n  var grid = [];\n  for (var r = 0; r < mapData.length; r++) {\n    var row = [];\n    for (var c = 0; c < mapData[0].length; c++) {\n      row.push(walkableTiles.includes(mapData[r][c]) ? 0 : 1);\n    }\n    grid.push(row);\n  }\n  return new (pathfinding__WEBPACK_IMPORTED_MODULE_0___default().Grid)(grid);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TWxGLEdBQUcsR0FBRyxFQUFFO0lBQ2QsS0FBSyxJQUFJaUYsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHM0YsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDRyxNQUFNLEVBQUV3RixDQUFDLEVBQUUsRUFBRTtNQUN4Q2pGLEdBQUcsQ0FBQzhHLElBQUksQ0FBQ3BCLGFBQWEsQ0FBQ2lCLFFBQVEsQ0FBQ3JILE9BQU8sQ0FBQzRGLENBQUMsQ0FBQyxDQUFDRCxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDM0Q7SUFDQWdDLElBQUksQ0FBQ0gsSUFBSSxDQUFDOUcsR0FBRyxDQUFDO0VBQ2xCO0VBQ0EsT0FBTyxJQUFJZix5REFBTyxDQUFDZ0ksSUFBSSxDQUFDO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYWNvbm1hbi8uL3Jlc291cmNlcy9hc3NldHMvanMvZ2hvc3QtZW50aXR5LmpzPzc5MzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZ2hvc3QtZW50aXR5LmpzXG4vLyBNaW5pbWFsLCBleHRlbnNpYmxlIEdob3N0RW50aXR5IGNsYXNzIGZvciBtb3ZlbWVudCwgY29sbGlzaW9uLCBhbmQgZnV0dXJlIHBhdGhmaW5kaW5nXG5cbmltcG9ydCBQRiBmcm9tICdwYXRoZmluZGluZyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdob3N0RW50aXR5IHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydENvbCwgc3RhcnRSb3csIHRpbGVTaXplLCBtYXBEYXRhLCBzcGVlZCA9IDIsIGNvbG9yID0gJyNGRjAwMDAnLCB0aWxlcyA9IG51bGwsIGltYWdlID0gbnVsbCkge1xuICAgICAgICB0aGlzLmNvbCA9IHN0YXJ0Q29sO1xuICAgICAgICB0aGlzLnJvdyA9IHN0YXJ0Um93O1xuICAgICAgICB0aGlzLnRpbGVTaXplID0gdGlsZVNpemU7XG4gICAgICAgIHRoaXMubWFwRGF0YSA9IG1hcERhdGE7IC8vIHJlZmVyZW5jZSB0byBjdXJyZW50IG1hcFxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9ICdsZWZ0JzsgLy8gZGVmYXVsdFxuICAgICAgICB0aGlzLm5leHREaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgICAgIHRoaXMueCA9IHRoaXMuY29sICogdGlsZVNpemU7XG4gICAgICAgIHRoaXMueSA9IHRoaXMucm93ICogdGlsZVNpemU7XG4gICAgICAgIHRoaXMudGFyZ2V0WCA9IHRoaXMueDtcbiAgICAgICAgdGhpcy50YXJnZXRZID0gdGhpcy55O1xuICAgICAgICB0aGlzLm1vdmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdpbl9wZW4nOyAvLyAnaW5fcGVuJywgJ2V4aXRpbmcnLCAnYWN0aXZlJ1xuICAgICAgICB0aGlzLmV4aXRUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXRoU3RlcCA9IDA7XG4gICAgICAgIHRoaXMuVElMRVMgPSB0aWxlcztcbiAgICAgICAgdGhpcy5sYXN0UG9zaXRpb24gPSBudWxsOyAvLyBUcmFjayBwcmV2aW91cyB0aWxlXG4gICAgfVxuXG4gICAgc2V0U3RhdGUoc3RhdGUsIGV4aXRUYXJnZXQgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5leGl0VGFyZ2V0ID0gZXhpdFRhcmdldDtcbiAgICAgICAgLy8gV2hlbiBlbnRlcmluZyAnZXhpdGluZycsIGNsZWFyIHByZXZpb3VzIGRlc3RpbmF0aW9uIGlmIGp1c3QgbGVmdCBwZW5cbiAgICAgICAgaWYoc3RhdGUgPT09ICdleGl0aW5nJyAmJiB0aGlzLmRlc3RpbmF0aW9uICYmIHRoaXMuc3RhdGUgIT09ICdleGl0aW5nJykge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wYXRoU3RlcCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXREaXJlY3Rpb24oZGlyKSB7XG4gICAgICAgIHRoaXMubmV4dERpcmVjdGlvbiA9IGRpcjtcbiAgICB9XG5cbiAgICBjYW5Nb3ZlKGRpcikge1xuICAgICAgICBsZXQgW2RDb2wsIGRSb3ddID0gR2hvc3RFbnRpdHkuZGlyZWN0aW9uRGVsdGEoZGlyKTtcbiAgICAgICAgbGV0IG5Db2wgPSB0aGlzLmNvbCArIGRDb2w7XG4gICAgICAgIGxldCBuUm93ID0gdGhpcy5yb3cgKyBkUm93O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBuQ29sIDwgMCB8fCBuUm93IDwgMCB8fFxuICAgICAgICAgICAgblJvdyA+PSB0aGlzLm1hcERhdGEubGVuZ3RoIHx8IG5Db2wgPj0gdGhpcy5tYXBEYXRhWzBdLmxlbmd0aFxuICAgICAgICApIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gQWxsb3cgbW92ZW1lbnQgb24gd2Fsa2FibGUgdGlsZXMgYWx3YXlzIGlmIG5vdCBpbl9wZW5cblxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2V4aXRpbmcnKSB7XG5cbi8vICAgICAgICAgICAgcmV0dXJuIHdhbGthYmxlLnNvbWUoQm9vbGVhbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2V4aXRpbmcnIHx8IHRoaXMuc3RhdGUgPT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgICBjb25zdCB3YWxrYWJsZSA9IFtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcERhdGFbblJvd11bbkNvbF0gPT09IHRoaXMuVElMRVMuRU1QVFksXG4gICAgICAgICAgICAgICAgdGhpcy5tYXBEYXRhW25Sb3ddW25Db2xdID09PSB0aGlzLlRJTEVTLkRPVCxcbiAgICAgICAgICAgICAgICB0aGlzLm1hcERhdGFbblJvd11bbkNvbF0gPT09IHRoaXMuVElMRVMuU1VQRVJfRE9ULFxuICAgICAgICAgICAgICAgIHRoaXMubWFwRGF0YVtuUm93XVtuQ29sXSA9PT0gdGhpcy5USUxFUy5HSE9TVF9ET09SLFxuICAgICAgICAgICAgICAgIHRoaXMubWFwRGF0YVtuUm93XVtuQ29sXSA9PT0gdGhpcy5USUxFUy5HSE9TVF9TUEFXTlxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiB3YWxrYWJsZS5zb21lKEJvb2xlYW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGluX3Blbiwgb25seSBhbGxvdyBtb3ZlbWVudCBpbnNpZGUgcGVuIChHSE9TVF9TUEFXTilcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRGF0YVtuUm93XVtuQ29sXSA9PT0gdGhpcy5USUxFUy5HSE9TVF9TUEFXTjtcbiAgICB9XG5cbiAgICBtb3ZlKCkge1xuICAgICAgICBpZiAoIXRoaXMubW92aW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0RGlyZWN0aW9uICYmIHRoaXMuY2FuTW92ZSh0aGlzLm5leHREaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSB0aGlzLm5leHREaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0RGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNhbk1vdmUodGhpcy5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgbGV0IFtkQ29sLCBkUm93XSA9IEdob3N0RW50aXR5LmRpcmVjdGlvbkRlbHRhKHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFggPSAodGhpcy5jb2wgKyBkQ29sKSAqIHRoaXMudGlsZVNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXRZID0gKHRoaXMucm93ICsgZFJvdykgKiB0aGlzLnRpbGVTaXplO1xuICAgICAgICAgICAgICAgIHRoaXMubW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb3ZpbmcpIHtcbiAgICAgICAgICAgIGxldCBkeCA9IHRoaXMudGFyZ2V0WCAtIHRoaXMueDtcbiAgICAgICAgICAgIGxldCBkeSA9IHRoaXMudGFyZ2V0WSAtIHRoaXMueTtcbiAgICAgICAgICAgIGxldCBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgIGlmIChkaXN0IDw9IHRoaXMuc3BlZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB0aGlzLnRhcmdldFg7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0gdGhpcy50YXJnZXRZO1xuICAgICAgICAgICAgICAgIGxldCBbZENvbCwgZFJvd10gPSBHaG9zdEVudGl0eS5kaXJlY3Rpb25EZWx0YSh0aGlzLmRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2wgKz0gZENvbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdyArPSBkUm93O1xuICAgICAgICAgICAgICAgIHRoaXMubW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoZHksIGR4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnggKz0gdGhpcy5zcGVlZCAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnkgKz0gdGhpcy5zcGVlZCAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBkaXJlY3Rpb25EZWx0YShkaXIpIHtcbiAgICAgICAgc3dpdGNoKGRpcikge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6IHJldHVybiBbLTEsIDBdO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOiByZXR1cm4gWzEsIDBdO1xuICAgICAgICAgICAgY2FzZSAndXAnOiByZXR1cm4gWzAsIC0xXTtcbiAgICAgICAgICAgIGNhc2UgJ2Rvd24nOiByZXR1cm4gWzAsIDFdO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIFswLCAwXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzQXQoY29sLCByb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sID09PSBjb2wgJiYgdGhpcy5yb3cgPT09IHJvdztcbiAgICB9XG5cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmICh0aGlzLmltYWdlKSB7XG4gICAgICAgICAgICAvLyBEcmF3IFBORy9TVkcgYXJ0XG4gICAgICAgICAgICBjb25zdCBpbWcgPSB0aGlzLl9hcnRJbWcgfHwgKHRoaXMuX2FydEltZyA9IG5ldyBJbWFnZSgpKTtcbiAgICAgICAgICAgIGlmICghaW1nLnNyYykgaW1nLnNyYyA9IHRoaXMuaW1hZ2U7XG4gICAgICAgICAgICBpZiAoaW1nLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgICAgICAgaW1nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLngsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aWxlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aWxlU2l6ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCB0aGlzLngsIHRoaXMueSwgdGhpcy50aWxlU2l6ZSwgdGhpcy50aWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyhcbiAgICAgICAgICAgICAgICB0aGlzLnggKyB0aGlzLnRpbGVTaXplIC8gMixcbiAgICAgICAgICAgICAgICB0aGlzLnkgKyB0aGlzLnRpbGVTaXplIC8gMixcbiAgICAgICAgICAgICAgICB0aGlzLnRpbGVTaXplIC8gMiAtIDIsXG4gICAgICAgICAgICAgICAgMCwgMiAqIE1hdGguUElcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGJmc1BhdGgobWFwRGF0YSwgc3RhcnQsIGdvYWwsIHdhbGthYmxlVGlsZXMgPSBbMCwgMSwgMywgNV0pIHtcbiAgICAgICAgY29uc3QgcXVldWUgPSBbW3N0YXJ0XV07XG4gICAgICAgIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGtleSA9IChjLCByKSA9PiBgJHtjfSwke3J9YDtcbiAgICAgICAgdmlzaXRlZC5hZGQoa2V5KHN0YXJ0LmNvbCwgc3RhcnQucm93KSk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IG1hcERhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCB3aWR0aCA9IG1hcERhdGFbMF0ubGVuZ3RoO1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHtjb2wsIHJvd30gPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoY29sID09PSBnb2FsLmNvbCAmJiByb3cgPT09IGdvYWwucm93KSByZXR1cm4gcGF0aDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2RjLCBkcl0gb2YgW1swLDFdLFsxLDBdLFswLC0xXSxbLTEsMF1dKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmMgPSBjb2wgKyBkYywgbnIgPSByb3cgKyBkcjtcbiAgICAgICAgICAgICAgICBpZiAobmMgPCAwIHx8IG5yIDwgMCB8fCBuYyA+PSB3aWR0aCB8fCBuciA+PSBoZWlnaHQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmICghd2Fsa2FibGVUaWxlcy5pbmNsdWRlcyhtYXBEYXRhW25yXVtuY10pKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBrID0ga2V5KG5jLCBucik7XG4gICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWQuaGFzKGspKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB2aXNpdGVkLmFkZChrKTtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKFsuLi5wYXRoLCB7Y29sOiBuYywgcm93OiBucn1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzZXREZXN0aW5hdGlvbihkZXN0LCBtYXBEYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmxhc3RQb3NpdGlvbiAmJiBkZXN0LmNvbCA9PT0gdGhpcy5sYXN0UG9zaXRpb24uY29sICYmIGRlc3Qucm93ID09PSB0aGlzLmxhc3RQb3NpdGlvbi5yb3cpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGFsbG93IGltbWVkaWF0ZSByZXZlcnNhbCB0byBwcmV2aW91cyBwb3NpdGlvblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0O1xuICAgICAgICAvLyBDb252ZXJ0IG1hcERhdGEgdG8gUEYgZ3JpZCBmb3IgZnVsbCBtYXplXG4gICAgICAgIGNvbnN0IHdhbGthYmxlID0gW3RoaXMuVElMRVMuRU1QVFksIHRoaXMuVElMRVMuRE9ULCB0aGlzLlRJTEVTLlNVUEVSX0RPVCwgdGhpcy5USUxFUy5HSE9TVF9ET09SLCB0aGlzLlRJTEVTLkdIT1NUX1NQQVdOXTtcbiAgICAgICAgY29uc3QgcGZHcmlkID0gbWFrZVBGR3JpZChtYXBEYXRhLCB3YWxrYWJsZSk7XG4gICAgICAgIGNvbnN0IGZpbmRlciA9IG5ldyBQRi5BU3RhckZpbmRlcigpO1xuICAgICAgICBjb25zdCBwYXRoQXJyID0gZmluZGVyLmZpbmRQYXRoKHRoaXMuY29sLCB0aGlzLnJvdywgZGVzdC5jb2wsIGRlc3Qucm93LCBwZkdyaWQpO1xuICAgICAgICAvLyBDb252ZXJ0IFtjb2wscm93XSBhcnJheSB0byBbe2NvbCxyb3d9XSBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoQXJyLm1hcCgoW2MsIHJdKSA9PiAoe2NvbDogYywgcm93OiByfSkpO1xuICAgICAgICB0aGlzLnBhdGhTdGVwID0gMTtcbiAgICB9XG5cbiAgICBtb3ZlVG9EZXN0aW5hdGlvbigpIHtcbiAgICAgICAgLy8gSWYgcGF0aCBpcyBtaXNzaW5nIG9yIGJsb2NrZWQsIHRyeSB0byByZWNvbXB1dGUgYSBuZXcgcGF0aFxuICAgICAgICBpZiAoIXRoaXMucGF0aCB8fCB0aGlzLnBhdGhTdGVwID49IHRoaXMucGF0aC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBHaG9zdEVudGl0eS5iZnNQYXRoKHRoaXMubWFwRGF0YSwge2NvbDogdGhpcy5jb2wsIHJvdzogdGhpcy5yb3d9LCB0aGlzLmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhTdGVwID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHN0aWxsIG5vIHBhdGgsIGFiYW5kb24gZGVzdGluYXRpb25cbiAgICAgICAgICAgIGlmICghdGhpcy5wYXRoIHx8IHRoaXMucGF0aC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhTdGVwID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0gRk9SQ0UgRVhJVCBMT0dJQyAtLS1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdleGl0aW5nJykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG5leHQgc3RlcCBpcyBhIEdIT1NUX0RPT1Igb3IgRU1QVFksIGFsd2F5cyB0YWtlIGl0IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5wYXRoW3RoaXMucGF0aFN0ZXBdO1xuICAgICAgICAgICAgaWYgKCFuZXh0KSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBuZXh0VHlwZSA9IHRoaXMubWFwRGF0YVtuZXh0LnJvd11bbmV4dC5jb2xdO1xuICAgICAgICAgICAgaWYgKG5leHRUeXBlID09PSB0aGlzLlRJTEVTLkdIT1NUX0RPT1IgfHwgbmV4dFR5cGUgPT09IHRoaXMuVElMRVMuRU1QVFkpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5jb2wgPiB0aGlzLmNvbCkgdGhpcy5zZXREaXJlY3Rpb24oJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dC5jb2wgPCB0aGlzLmNvbCkgdGhpcy5zZXREaXJlY3Rpb24oJ2xlZnQnKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0LnJvdyA+IHRoaXMucm93KSB0aGlzLnNldERpcmVjdGlvbignZG93bicpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQucm93IDwgdGhpcy5yb3cpIHRoaXMuc2V0RGlyZWN0aW9uKCd1cCcpO1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbCA9PT0gbmV4dC5jb2wgJiYgdGhpcy5yb3cgPT09IG5leHQucm93KSB0aGlzLnBhdGhTdGVwKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERlZmF1bHQ6IGZvbGxvdyBwYXRoXG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLnBhdGhbdGhpcy5wYXRoU3RlcF07XG4gICAgICAgIGlmICghbmV4dCkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5jb2wgPT09IG5leHQuY29sICYmIHRoaXMucm93ID09PSBuZXh0LnJvdykge1xuICAgICAgICAgICAgdGhpcy5sYXN0UG9zaXRpb24gPSB7IGNvbDogdGhpcy5jb2wsIHJvdzogdGhpcy5yb3cgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dC5jb2wgPiB0aGlzLmNvbCkgdGhpcy5zZXREaXJlY3Rpb24oJ3JpZ2h0Jyk7XG4gICAgICAgIGVsc2UgaWYgKG5leHQuY29sIDwgdGhpcy5jb2wpIHRoaXMuc2V0RGlyZWN0aW9uKCdsZWZ0Jyk7XG4gICAgICAgIGVsc2UgaWYgKG5leHQucm93ID4gdGhpcy5yb3cpIHRoaXMuc2V0RGlyZWN0aW9uKCdkb3duJyk7XG4gICAgICAgIGVsc2UgaWYgKG5leHQucm93IDwgdGhpcy5yb3cpIHRoaXMuc2V0RGlyZWN0aW9uKCd1cCcpO1xuICAgICAgICB0aGlzLm1vdmUoKTtcbiAgICAgICAgaWYgKHRoaXMuY29sID09PSBuZXh0LmNvbCAmJiB0aGlzLnJvdyA9PT0gbmV4dC5yb3cpIHRoaXMucGF0aFN0ZXArKztcbiAgICB9XG5cbiAgICBhdERlc3RpbmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXN0aW5hdGlvbiAmJiB0aGlzLmNvbCA9PT0gdGhpcy5kZXN0aW5hdGlvbi5jb2wgJiYgdGhpcy5yb3cgPT09IHRoaXMuZGVzdGluYXRpb24ucm93O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFrZVBGR3JpZChtYXBEYXRhLCB3YWxrYWJsZVRpbGVzKSB7XG4gICAgY29uc3QgZ3JpZCA9IFtdO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgbWFwRGF0YS5sZW5ndGg7IHIrKykge1xuICAgICAgICBjb25zdCByb3cgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBtYXBEYXRhWzBdLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICByb3cucHVzaCh3YWxrYWJsZVRpbGVzLmluY2x1ZGVzKG1hcERhdGFbcl1bY10pID8gMCA6IDEpO1xuICAgICAgICB9XG4gICAgICAgIGdyaWQucHVzaChyb3cpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFBGLkdyaWQoZ3JpZCk7XG59XG4iXSwibmFtZXMiOlsiUEYiLCJHaG9zdEVudGl0eSIsInN0YXJ0Q29sIiwic3RhcnRSb3ciLCJ0aWxlU2l6ZSIsIm1hcERhdGEiLCJzcGVlZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImNvbG9yIiwidGlsZXMiLCJpbWFnZSIsIl9jbGFzc0NhbGxDaGVjayIsImNvbCIsInJvdyIsImRpcmVjdGlvbiIsIm5leHREaXJlY3Rpb24iLCJ4IiwieSIsInRhcmdldFgiLCJ0YXJnZXRZIiwibW92aW5nIiwic3RhdGUiLCJleGl0VGFyZ2V0IiwiZGVzdGluYXRpb24iLCJwYXRoIiwicGF0aFN0ZXAiLCJUSUxFUyIsImxhc3RQb3NpdGlvbiIsIl9jcmVhdGVDbGFzcyIsImtleSIsInZhbHVlIiwic2V0U3RhdGUiLCJzZXREaXJlY3Rpb24iLCJkaXIiLCJjYW5Nb3ZlIiwiX0dob3N0RW50aXR5JGRpcmVjdGlvIiwiZGlyZWN0aW9uRGVsdGEiLCJfR2hvc3RFbnRpdHkkZGlyZWN0aW8yIiwiX3NsaWNlZFRvQXJyYXkiLCJkQ29sIiwiZFJvdyIsIm5Db2wiLCJuUm93Iiwid2Fsa2FibGUiLCJFTVBUWSIsIkRPVCIsIlNVUEVSX0RPVCIsIkdIT1NUX0RPT1IiLCJHSE9TVF9TUEFXTiIsInNvbWUiLCJCb29sZWFuIiwibW92ZSIsIl9HaG9zdEVudGl0eSRkaXJlY3RpbzMiLCJfR2hvc3RFbnRpdHkkZGlyZWN0aW80IiwiZHgiLCJkeSIsImRpc3QiLCJNYXRoIiwic3FydCIsIl9HaG9zdEVudGl0eSRkaXJlY3RpbzUiLCJfR2hvc3RFbnRpdHkkZGlyZWN0aW82IiwiYW5nbGUiLCJhdGFuMiIsImNvcyIsInNpbiIsImlzQXQiLCJyZW5kZXIiLCJjdHgiLCJfdGhpcyIsInNhdmUiLCJpbWciLCJfYXJ0SW1nIiwiSW1hZ2UiLCJzcmMiLCJjb21wbGV0ZSIsImRyYXdJbWFnZSIsIm9ubG9hZCIsImZpbGxTdHlsZSIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiZmlsbCIsInJlc3RvcmUiLCJzZXREZXN0aW5hdGlvbiIsImRlc3QiLCJwZkdyaWQiLCJtYWtlUEZHcmlkIiwiZmluZGVyIiwiQVN0YXJGaW5kZXIiLCJwYXRoQXJyIiwiZmluZFBhdGgiLCJtYXAiLCJfcmVmIiwiX3JlZjIiLCJjIiwiciIsIm1vdmVUb0Rlc3RpbmF0aW9uIiwiYmZzUGF0aCIsIm5leHQiLCJuZXh0VHlwZSIsImF0RGVzdGluYXRpb24iLCJzdGFydCIsImdvYWwiLCJ3YWxrYWJsZVRpbGVzIiwicXVldWUiLCJ2aXNpdGVkIiwiU2V0IiwiY29uY2F0IiwiYWRkIiwiaGVpZ2h0Iiwid2lkdGgiLCJzaGlmdCIsIl9wYXRoIiwiX2kiLCJfYXJyIiwiX2FyciRfaSIsImRjIiwiZHIiLCJuYyIsIm5yIiwiaW5jbHVkZXMiLCJrIiwiaGFzIiwicHVzaCIsIl90b0NvbnN1bWFibGVBcnJheSIsImRlZmF1bHQiLCJncmlkIiwiR3JpZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/assets/js/ghost-entity.js\n\n}");

/***/ }),

/***/ "./resources/assets/js/input-handler.js":
/*!**********************************************!*\
  !*** ./resources/assets/js/input-handler.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// Modern ES6 InputHandler module for laraconman\nvar InputHandler = /*#__PURE__*/function () {\n  function InputHandler() {\n    _classCallCheck(this, InputHandler);\n    this.keys = {};\n    this.currentDirection = null;\n    this.queuedDirection = null;\n\n    // Direction constants\n    this.DIRECTIONS = {\n      UP: 'up',\n      DOWN: 'down',\n      LEFT: 'left',\n      RIGHT: 'right'\n    };\n\n    // Key mapping for navigation\n    this.keyMap = {\n      'ArrowUp': this.DIRECTIONS.UP,\n      'KeyW': this.DIRECTIONS.UP,\n      'ArrowDown': this.DIRECTIONS.DOWN,\n      'KeyS': this.DIRECTIONS.DOWN,\n      'ArrowLeft': this.DIRECTIONS.LEFT,\n      'KeyA': this.DIRECTIONS.LEFT,\n      'ArrowRight': this.DIRECTIONS.RIGHT,\n      'KeyD': this.DIRECTIONS.RIGHT\n    };\n    this.callbacks = {\n      onDirectionChange: null,\n      onKeyPress: null,\n      // NEW: generic key press\n      onPause: null,\n      onReset: null\n    };\n    this.setupEventListeners();\n  }\n  return _createClass(InputHandler, [{\n    key: \"setCallbacks\",\n    value: function setCallbacks(callbacks) {\n      this.callbacks = _objectSpread(_objectSpread({}, this.callbacks), callbacks);\n    }\n  }, {\n    key: \"getCurrentDirection\",\n    value: function getCurrentDirection() {\n      return this.currentDirection;\n    }\n  }, {\n    key: \"getQueuedDirection\",\n    value: function getQueuedDirection() {\n      return this.queuedDirection;\n    }\n  }, {\n    key: \"setupEventListeners\",\n    value: function setupEventListeners() {\n      var _this = this;\n      document.addEventListener('keydown', function (e) {\n        // Prevent browser scroll for arrow keys\n        if ([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"].includes(e.key)) {\n          e.preventDefault();\n        }\n        // Navigation keys\n        if (_this.keyMap[e.code]) {\n          _this.handleDirectionInput(e.code);\n        }\n        // Pause (Escape)\n        else if (e.code === 'Escape' && _this.callbacks.onPause) {\n          _this.callbacks.onPause();\n        }\n        // Reset (R)\n        else if ((e.code === 'KeyR' || e.code === 'F5') && _this.callbacks.onReset) {\n          _this.callbacks.onReset();\n        }\n        // Enter/Return\n        else if ((e.code === 'Enter' || e.code === 'NumpadEnter') && _this.callbacks.onKeyPress) {\n          _this.callbacks.onKeyPress('enter', e);\n        }\n        // Any other key\n        else if (_this.callbacks.onKeyPress) {\n          _this.callbacks.onKeyPress(e.code, e);\n        }\n      }, {\n        passive: false\n      });\n    }\n  }, {\n    key: \"handleDirectionInput\",\n    value: function handleDirectionInput(code) {\n      var direction = this.keyMap[code];\n      if (direction && direction !== this.currentDirection) {\n        this.queuedDirection = direction;\n        this.currentDirection = direction;\n        if (this.callbacks.onDirectionChange) {\n          this.callbacks.onDirectionChange(direction);\n        }\n      }\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InputHandler);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SjtFQUFDO0FBQUE7QUFHTCxpRUFBZWpDLFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhY29ubWFuLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9pbnB1dC1oYW5kbGVyLmpzP2IzMDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTW9kZXJuIEVTNiBJbnB1dEhhbmRsZXIgbW9kdWxlIGZvciBsYXJhY29ubWFuXG5jbGFzcyBJbnB1dEhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmtleXMgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5xdWV1ZWREaXJlY3Rpb24gPSBudWxsO1xuXG4gICAgICAgIC8vIERpcmVjdGlvbiBjb25zdGFudHNcbiAgICAgICAgdGhpcy5ESVJFQ1RJT05TID0ge1xuICAgICAgICAgICAgVVA6ICd1cCcsXG4gICAgICAgICAgICBET1dOOiAnZG93bicsXG4gICAgICAgICAgICBMRUZUOiAnbGVmdCcsXG4gICAgICAgICAgICBSSUdIVDogJ3JpZ2h0J1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEtleSBtYXBwaW5nIGZvciBuYXZpZ2F0aW9uXG4gICAgICAgIHRoaXMua2V5TWFwID0ge1xuICAgICAgICAgICAgJ0Fycm93VXAnOiB0aGlzLkRJUkVDVElPTlMuVVAsXG4gICAgICAgICAgICAnS2V5Vyc6IHRoaXMuRElSRUNUSU9OUy5VUCxcbiAgICAgICAgICAgICdBcnJvd0Rvd24nOiB0aGlzLkRJUkVDVElPTlMuRE9XTixcbiAgICAgICAgICAgICdLZXlTJzogdGhpcy5ESVJFQ1RJT05TLkRPV04sXG4gICAgICAgICAgICAnQXJyb3dMZWZ0JzogdGhpcy5ESVJFQ1RJT05TLkxFRlQsXG4gICAgICAgICAgICAnS2V5QSc6IHRoaXMuRElSRUNUSU9OUy5MRUZULFxuICAgICAgICAgICAgJ0Fycm93UmlnaHQnOiB0aGlzLkRJUkVDVElPTlMuUklHSFQsXG4gICAgICAgICAgICAnS2V5RCc6IHRoaXMuRElSRUNUSU9OUy5SSUdIVFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgb25EaXJlY3Rpb25DaGFuZ2U6IG51bGwsXG4gICAgICAgICAgICBvbktleVByZXNzOiBudWxsLCAvLyBORVc6IGdlbmVyaWMga2V5IHByZXNzXG4gICAgICAgICAgICBvblBhdXNlOiBudWxsLFxuICAgICAgICAgICAgb25SZXNldDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHNldENhbGxiYWNrcyhjYWxsYmFja3MpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB7IC4uLnRoaXMuY2FsbGJhY2tzLCAuLi5jYWxsYmFja3MgfTtcbiAgICB9XG5cbiAgICBnZXRDdXJyZW50RGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RGlyZWN0aW9uO1xuICAgIH1cblxuICAgIGdldFF1ZXVlZERpcmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWVkRGlyZWN0aW9uO1xuICAgIH1cblxuICAgIHNldHVwRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgICAgICAgLy8gUHJldmVudCBicm93c2VyIHNjcm9sbCBmb3IgYXJyb3cga2V5c1xuICAgICAgICAgICAgaWYgKFtcIkFycm93VXBcIiwgXCJBcnJvd0Rvd25cIiwgXCJBcnJvd0xlZnRcIiwgXCJBcnJvd1JpZ2h0XCJdLmluY2x1ZGVzKGUua2V5KSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5hdmlnYXRpb24ga2V5c1xuICAgICAgICAgICAgaWYgKHRoaXMua2V5TWFwW2UuY29kZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpcmVjdGlvbklucHV0KGUuY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXVzZSAoRXNjYXBlKVxuICAgICAgICAgICAgZWxzZSBpZiAoZS5jb2RlID09PSAnRXNjYXBlJyAmJiB0aGlzLmNhbGxiYWNrcy5vblBhdXNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25QYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVzZXQgKFIpXG4gICAgICAgICAgICBlbHNlIGlmICgoZS5jb2RlID09PSAnS2V5UicgfHwgZS5jb2RlID09PSAnRjUnKSAmJiB0aGlzLmNhbGxiYWNrcy5vblJlc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25SZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRW50ZXIvUmV0dXJuXG4gICAgICAgICAgICBlbHNlIGlmICgoZS5jb2RlID09PSAnRW50ZXInIHx8IGUuY29kZSA9PT0gJ051bXBhZEVudGVyJykgJiYgdGhpcy5jYWxsYmFja3Mub25LZXlQcmVzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uS2V5UHJlc3MoJ2VudGVyJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBbnkgb3RoZXIga2V5XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNhbGxiYWNrcy5vbktleVByZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25LZXlQcmVzcyhlLmNvZGUsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIGhhbmRsZURpcmVjdGlvbklucHV0KGNvZGUpIHtcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5rZXlNYXBbY29kZV07XG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiYgZGlyZWN0aW9uICE9PSB0aGlzLmN1cnJlbnREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMucXVldWVkRGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tzLm9uRGlyZWN0aW9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3Mub25EaXJlY3Rpb25DaGFuZ2UoZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRIYW5kbGVyOyJdLCJuYW1lcyI6WyJJbnB1dEhhbmRsZXIiLCJfY2xhc3NDYWxsQ2hlY2siLCJrZXlzIiwiY3VycmVudERpcmVjdGlvbiIsInF1ZXVlZERpcmVjdGlvbiIsIkRJUkVDVElPTlMiLCJVUCIsIkRPV04iLCJMRUZUIiwiUklHSFQiLCJrZXlNYXAiLCJjYWxsYmFja3MiLCJvbkRpcmVjdGlvbkNoYW5nZSIsIm9uS2V5UHJlc3MiLCJvblBhdXNlIiwib25SZXNldCIsInNldHVwRXZlbnRMaXN0ZW5lcnMiLCJfY3JlYXRlQ2xhc3MiLCJrZXkiLCJ2YWx1ZSIsInNldENhbGxiYWNrcyIsIl9vYmplY3RTcHJlYWQiLCJnZXRDdXJyZW50RGlyZWN0aW9uIiwiZ2V0UXVldWVkRGlyZWN0aW9uIiwiX3RoaXMiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwiaW5jbHVkZXMiLCJwcmV2ZW50RGVmYXVsdCIsImNvZGUiLCJoYW5kbGVEaXJlY3Rpb25JbnB1dCIsInBhc3NpdmUiLCJkaXJlY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/assets/js/input-handler.js\n\n}");

/***/ }),

/***/ "./resources/assets/js/map-renderer.js":
/*!*********************************************!*\
  !*** ./resources/assets/js/map-renderer.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar MapRenderer = /*#__PURE__*/function () {\n  function MapRenderer(canvas) {\n    var tileSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;\n    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, MapRenderer);\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d');\n    this.tileSize = tileSize;\n    this.mapData = null;\n    this.rawMapData = null; // Store the original map data before border enforcement\n    this.width = 0;\n    this.height = 0;\n\n    // Tile type constants (matching your factory)\n    this.TILES = {\n      EMPTY: 0,\n      WALL: 1,\n      DOT: 2,\n      GHOST_DOOR: 3,\n      TUNNEL: 4,\n      CORNER: 6,\n      GHOST_SPAWN: 7,\n      PORTAL: 8,\n      SUPER_DOT: 9,\n      PORTAL_BLOCKER: 10,\n      FRUIT: 11\n    };\n\n    // Colors for different tile types\n    this.colors = {\n      wall: '#0031FF',\n      // Pac-Man blue\n      dot: '#FFFFB8',\n      // Pac-Man dot yellow\n      ghostDoor: '#FF69B4',\n      tunnel: '#000000',\n      // tunnel is background color\n      background: '#000000',\n      path: '#000080',\n      corner: '#FF0000',\n      ghostSpawn: '#00FF00',\n      portal: '#0000FF',\n      superDot: '#FFFF00'\n    };\n    this.applyConfig(config);\n  }\n\n  /**\n   * Accepts a config object to override colors.\n   * @param {object} config - Optional config object with color overrides\n   */\n  return _createClass(MapRenderer, [{\n    key: \"applyConfig\",\n    value: function applyConfig() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (config.colors) {\n        this.colors = _objectSpread(_objectSpread({}, this.colors), config.colors);\n      }\n    }\n\n    /**\n     * Load map data from CSV string format\n     * @param {string} csvData - CSV formatted map data\n     * @param {number} width - Map width in tiles\n     * @param {number} height - Map height in tiles\n     */\n  }, {\n    key: \"loadMap\",\n    value: function loadMap(csvData, width, height) {\n      var _this = this;\n      this.width = width + 2;\n      this.height = height + 2;\n      var rows = csvData.trim().split('\\n');\n      var raw = rows.map(function (row) {\n        return row.split(',').map(function (cell) {\n          return _this.mapTileCode(parseInt(cell.trim(), 10));\n        });\n      });\n      // Find portal columns/rows on edges\n      var portalColsTop = [];\n      var portalColsBottom = [];\n      var portalRowsLeft = [];\n      var portalRowsRight = [];\n      for (var c = 0; c < width; c++) {\n        if (raw[0][c] === this.TILES.PORTAL) portalColsTop.push(c);\n        if (raw[height - 1][c] === this.TILES.PORTAL) portalColsBottom.push(c);\n        console.log('crap2');\n      }\n      for (var r = 0; r < height; r++) {\n        if (raw[r][0] === this.TILES.PORTAL) portalRowsLeft.push(r);\n        if (raw[r][width - 1] === this.TILES.PORTAL) portalRowsRight.push(r);\n        console.log('crap1');\n      }\n      // Build bordered map\n      this.mapData = [];\n      // Top border\n      var topRow = [];\n      for (var _c = 0; _c < width + 2; _c++) {\n        if (_c > 0 && _c < width + 1 && portalColsTop.includes(_c - 1)) topRow.push(this.TILES.PORTAL_BLOCKER);else topRow.push(this.TILES.WALL);\n      }\n      this.mapData.push(topRow);\n      // Middle rows\n      for (var _r = 0; _r < height; _r++) {\n        var row = [];\n        // Left border\n        if (portalRowsLeft.includes(_r)) row.push(this.TILES.PORTAL_BLOCKER);else row.push(this.TILES.WALL);\n        // Original row\n        for (var _c2 = 0; _c2 < width; _c2++) row.push(raw[_r][_c2]);\n        // Right border\n        if (portalRowsRight.includes(_r)) row.push(this.TILES.PORTAL_BLOCKER);else row.push(this.TILES.WALL);\n        this.mapData.push(row);\n      }\n      // Bottom border\n      var bottomRow = [];\n      for (var _c3 = 0; _c3 < width + 2; _c3++) {\n        if (_c3 > 0 && _c3 < width + 1 && portalColsBottom.includes(_c3 - 1)) bottomRow.push(this.TILES.PORTAL_BLOCKER);else bottomRow.push(this.TILES.WALL);\n      }\n      this.mapData.push(bottomRow);\n\n      // --- Add PORTAL_BLOCKER behind each portal ---\n      // Only place blocker if the tile is truly EMPTY (do not overwrite super dots, dots, fruit, etc)\n      var blockableTiles = [this.TILES.EMPTY];\n      // Top portals: place blocker below\n      for (var _i = 0, _portalColsTop = portalColsTop; _i < _portalColsTop.length; _i++) {\n        var _c4 = _portalColsTop[_i];\n        if (blockableTiles.includes(this.mapData[1][_c4 + 1])) {\n          this.mapData[1][_c4 + 1] = this.TILES.PORTAL_BLOCKER;\n        }\n      }\n      // Bottom portals: place blocker above\n      for (var _i2 = 0, _portalColsBottom = portalColsBottom; _i2 < _portalColsBottom.length; _i2++) {\n        var _c5 = _portalColsBottom[_i2];\n        if (blockableTiles.includes(this.mapData[this.mapData.length - 2][_c5 + 1])) {\n          this.mapData[this.mapData.length - 2][_c5 + 1] = this.TILES.PORTAL_BLOCKER;\n        }\n      }\n      // Left portals: place blocker right\n      for (var _i3 = 0, _portalRowsLeft = portalRowsLeft; _i3 < _portalRowsLeft.length; _i3++) {\n        var _r2 = _portalRowsLeft[_i3];\n        if (blockableTiles.includes(this.mapData[_r2 + 1][1])) {\n          this.mapData[_r2 + 1][1] = this.TILES.PORTAL_BLOCKER;\n        }\n      }\n      // Right portals: place blocker left\n      for (var _i4 = 0, _portalRowsRight = portalRowsRight; _i4 < _portalRowsRight.length; _i4++) {\n        var _r3 = _portalRowsRight[_i4];\n        if (blockableTiles.includes(this.mapData[_r3 + 1][this.mapData[0].length - 2])) {\n          this.mapData[_r3 + 1][this.mapData[0].length - 2] = this.TILES.PORTAL_BLOCKER;\n        }\n      }\n      this.canvas.width = this.width * this.tileSize;\n      this.canvas.height = this.height * this.tileSize;\n      console.log(\"Map loaded with border: \".concat(this.width, \"x\").concat(this.height), this.mapData);\n    }\n\n    /**\n     * Map legacy/demo tile codes to internal tile types\n     * @param {number} code - raw tile code from CSV\n     * @returns {number} mapped tile code\n     */\n  }, {\n    key: \"mapTileCode\",\n    value: function mapTileCode(code) {\n      // Tile code meanings:\n      // 0 = wall, 1 = empty/path, 2 = super dot (corners), 3 = ghost spawn, 4 = portal, 5 = ghost door\n      switch (code) {\n        case 0:\n          return this.TILES.WALL;\n        case 1:\n          return this.TILES.EMPTY;\n        case 2:\n          return this.TILES.SUPER_DOT;\n        case 3:\n          return this.TILES.GHOST_SPAWN;\n        case 4:\n          return this.TILES.PORTAL;\n        case 5:\n          return this.TILES.GHOST_DOOR;\n        default:\n          return this.TILES.EMPTY;\n      }\n    }\n\n    /**\n     * Ensure there is always a border of walls around the map,\n     * except for tunnel/portal tiles (TUNNEL) at the border.\n     * This modifies mapData in-place after loading.\n     */\n  }, {\n    key: \"ensureWallBorder\",\n    value: function ensureWallBorder() {\n      if (!this.mapData) return;\n      var h = this.mapData.length;\n      var w = this.mapData[0].length;\n      for (var r = 0; r < h; r++) {\n        for (var c = 0; c < w; c++) {\n          var isEdge = r === 0 || r === h - 1 || c === 0 || c === w - 1;\n          if (isEdge) {\n            // If this is a tunnel/portal, preserve it\n            if (this.mapData[r][c] === this.TILES.TUNNEL) continue;\n            // Otherwise, enforce wall\n            this.mapData[r][c] = this.TILES.WALL;\n          }\n        }\n      }\n    }\n\n    /**\n     * Render the entire map to canvas\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (!this.mapData) {\n        console.error('No map data loaded');\n        return;\n      }\n\n      // Clear canvas\n      this.ctx.fillStyle = this.colors.background;\n      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n      // Render each tile\n      for (var row = 0; row < this.height; row++) {\n        for (var col = 0; col < this.width; col++) {\n          var tileType = this.mapData[row][col];\n          this.renderTile(col, row, tileType);\n        }\n      }\n    }\n\n    /**\n     * Render a single tile at the specified position\n     * @param {number} col - Column position\n     * @param {number} row - Row position  \n     * @param {number} tileType - Type of tile to render\n     */\n  }, {\n    key: \"renderTile\",\n    value: function renderTile(col, row, tileType) {\n      var x = col * this.tileSize;\n      var y = row * this.tileSize;\n\n      // If this is a wall at the border and the *original* tile was a tunnel, skip rendering (transparent)\n      var isEdge = row === 0 || row === this.height - 1 || col === 0 || col === this.width - 1;\n      // Use the raw map data (before wall border enforcement) to check for tunnel\n      if (tileType === this.TILES.WALL && isEdge && this.rawMapData && this.rawMapData[row][col] === this.TILES.TUNNEL) {\n        return; // Don't render wall at tunnel/portal\n      }\n      if (tileType === this.TILES.WALL) {\n        this.renderWall(x, y);\n      } else switch (tileType) {\n        case this.TILES.DOT:\n          this.renderPath(x, y);\n          this.renderDot(x, y);\n          break;\n        case this.TILES.GHOST_DOOR:\n          this.renderPath(x, y);\n          this.renderGhostDoor(x, y);\n          break;\n        case this.TILES.TUNNEL:\n          this.renderPath(x, y);\n          break;\n        case this.TILES.CORNER:\n          this.renderPath(x, y);\n          this.renderCorner(x, y);\n          break;\n        case this.TILES.GHOST_SPAWN:\n          this.renderPath(x, y);\n          this.renderGhostSpawn(x, y);\n          break;\n        case this.TILES.PORTAL:\n          this.renderPath(x, y);\n          this.renderPortal(x, y);\n          break;\n        case this.TILES.SUPER_DOT:\n          this.renderPath(x, y);\n          this.renderSuperDot(x, y);\n          break;\n        default:\n          this.renderPath(x, y);\n      }\n    }\n\n    /**\n     * Render a wall tile\n     */\n  }, {\n    key: \"renderWall\",\n    value: function renderWall(x, y) {\n      this.ctx.fillStyle = this.colors.wall;\n      this.ctx.fillRect(x, y, this.tileSize, this.tileSize);\n\n      // Add wall border for definition\n      this.ctx.strokeStyle = '#4444FF';\n      this.ctx.lineWidth = 1;\n      this.ctx.strokeRect(x, y, this.tileSize, this.tileSize);\n    }\n\n    /**\n     * Render a path/corridor background\n     */\n  }, {\n    key: \"renderPath\",\n    value: function renderPath(x, y) {\n      this.ctx.fillStyle = this.colors.path;\n      this.ctx.fillRect(x, y, this.tileSize, this.tileSize);\n    }\n\n    /**\n     * Render a dot (pellet)\n     */\n  }, {\n    key: \"renderDot\",\n    value: function renderDot(x, y) {\n      var centerX = x + this.tileSize / 2;\n      var centerY = y + this.tileSize / 2;\n      var radius = Math.max(2, this.tileSize / 8);\n      this.ctx.fillStyle = this.colors.dot;\n      this.ctx.beginPath();\n      this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n      this.ctx.fill();\n    }\n\n    /**\n     * Render a ghost door (special gate)\n     */\n  }, {\n    key: \"renderGhostDoor\",\n    value: function renderGhostDoor(x, y) {\n      // Horizontal line across the middle\n      this.ctx.strokeStyle = this.colors.ghostDoor;\n      this.ctx.lineWidth = 3;\n      this.ctx.beginPath();\n      this.ctx.moveTo(x, y + this.tileSize / 2);\n      this.ctx.lineTo(x + this.tileSize, y + this.tileSize / 2);\n      this.ctx.stroke();\n    }\n\n    /**\n     * Render a tunnel entrance\n     */\n  }, {\n    key: \"renderTunnel\",\n    value: function renderTunnel(x, y) {\n      this.ctx.fillStyle = this.colors.tunnel;\n      this.ctx.fillRect(x, y, this.tileSize, this.tileSize);\n\n      // Add some tunnel indicators\n      this.ctx.fillStyle = '#008888';\n      this.ctx.fillRect(x + 2, y + 2, this.tileSize - 4, this.tileSize - 4);\n    }\n\n    /**\n     * Render a corner\n     */\n  }, {\n    key: \"renderCorner\",\n    value: function renderCorner(x, y) {\n      this.ctx.fillStyle = this.colors.corner;\n      this.ctx.fillRect(x, y, this.tileSize, this.tileSize);\n    }\n\n    /**\n     * Render a ghost spawn\n     */\n  }, {\n    key: \"renderGhostSpawn\",\n    value: function renderGhostSpawn(x, y) {\n      this.ctx.fillStyle = this.colors.ghostSpawn;\n      this.ctx.fillRect(x, y, this.tileSize, this.tileSize);\n    }\n\n    /**\n     * Render a portal\n     */\n  }, {\n    key: \"renderPortal\",\n    value: function renderPortal(x, y) {\n      this.ctx.fillStyle = this.colors.portal;\n      this.ctx.fillRect(x, y, this.tileSize, this.tileSize);\n    }\n\n    /**\n     * Render a super dot\n     */\n  }, {\n    key: \"renderSuperDot\",\n    value: function renderSuperDot(x, y) {\n      var centerX = x + this.tileSize / 2;\n      var centerY = y + this.tileSize / 2;\n      var radius = Math.max(4, this.tileSize / 4);\n      this.ctx.fillStyle = this.colors.superDot;\n      this.ctx.beginPath();\n      this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n      this.ctx.fill();\n    }\n\n    /**\n     * Get tile type at world coordinates\n     * @param {number} worldX - X coordinate in pixels\n     * @param {number} worldY - Y coordinate in pixels\n     * @returns {number} Tile type\n     */\n  }, {\n    key: \"getTileAt\",\n    value: function getTileAt(worldX, worldY) {\n      var col = Math.floor(worldX / this.tileSize);\n      var row = Math.floor(worldY / this.tileSize);\n      if (row < 0 || row >= this.height || col < 0 || col >= this.width) {\n        return this.TILES.WALL; // Treat out-of-bounds as walls\n      }\n      return this.mapData[row][col];\n    }\n\n    /**\n     * Convert grid coordinates to world coordinates\n     * @param {number} col - Column\n     * @param {number} row - Row\n     * @returns {object} World coordinates {x, y}\n     */\n  }, {\n    key: \"gridToWorld\",\n    value: function gridToWorld(col, row) {\n      return {\n        x: col * this.tileSize + this.tileSize / 2,\n        y: row * this.tileSize + this.tileSize / 2\n      };\n    }\n\n    /**\n     * Convert world coordinates to grid coordinates\n     * @param {number} worldX - World X coordinate\n     * @param {number} worldY - World Y coordinate\n     * @returns {object} Grid coordinates {col, row}\n     */\n  }, {\n    key: \"worldToGrid\",\n    value: function worldToGrid(worldX, worldY) {\n      return {\n        col: Math.floor(worldX / this.tileSize),\n        row: Math.floor(worldY / this.tileSize)\n      };\n    }\n\n    /**\n     * Find all tiles of a specific type\n     * @param {number} tileType - Type to search for\n     * @returns {Array} Array of {col, row} positions\n     */\n  }, {\n    key: \"findTiles\",\n    value: function findTiles(tileType) {\n      var positions = [];\n      for (var row = 0; row < this.height; row++) {\n        for (var col = 0; col < this.width; col++) {\n          if (this.mapData[row][col] === tileType) {\n            positions.push({\n              col: col,\n              row: row\n            });\n          }\n        }\n      }\n      return positions;\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapRenderer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QztJQUNMOztJQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUxJO0lBQUFxQyxHQUFBO0lBQUFDLEtBQUEsRUFNQSxTQUFBK0UsV0FBV0EsQ0FBQ0osTUFBTSxFQUFFQyxNQUFNLEVBQUU7TUFDeEIsT0FBTztRQUNIL0IsR0FBRyxFQUFFbUIsSUFBSSxDQUFDYSxLQUFLLENBQUNGLE1BQU0sR0FBRyxJQUFJLENBQUNqSCxRQUFRLENBQUM7UUFDdkNnRCxHQUFHLEVBQUVzRCxJQUFJLENBQUNhLEtBQUssQ0FBQ0QsTUFBTSxHQUFHLElBQUksQ0FBQ2xILFFBQVE7TUFDMUMsQ0FBQztJQUNMOztJQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7RUFKSTtJQUFBcUMsR0FBQTtJQUFBQyxLQUFBLEVBS0EsU0FBQWdGLFNBQVNBLENBQUNsQyxRQUFRLEVBQUU7TUFDaEIsSUFBTW1DLFNBQVMsR0FBRyxFQUFFO01BRXBCLEtBQUssSUFBSXZFLEdBQUcsR0FBRyxDQUFDLEVBQUVBLEdBQUcsR0FBRyxJQUFJLENBQUNyQyxNQUFNLEVBQUVxQyxHQUFHLEVBQUUsRUFBRTtRQUN4QyxLQUFLLElBQUltQyxHQUFHLEdBQUcsQ0FBQyxFQUFFQSxHQUFHLEdBQUcsSUFBSSxDQUFDekUsS0FBSyxFQUFFeUUsR0FBRyxFQUFFLEVBQUU7VUFDdkMsSUFBSSxJQUFJLENBQUMzRSxPQUFPLENBQUN3QyxHQUFHLENBQUMsQ0FBQ21DLEdBQUcsQ0FBQyxLQUFLQyxRQUFRLEVBQUU7WUFDckNtQyxTQUFTLENBQUM5RCxJQUFJLENBQUM7Y0FBQzBCLEdBQUcsRUFBSEEsR0FBRztjQUFFbkMsR0FBRyxFQUFIQTtZQUFHLENBQUMsQ0FBQztVQUM5QjtRQUNKO01BQ0o7TUFFQSxPQUFPdUUsU0FBUztJQUNwQjtFQUFDO0FBQUE7QUFHTCxpRUFBZXpILFdBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhY29ubWFuLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9tYXAtcmVuZGVyZXIuanM/NWNhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBNYXBSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoY2FudmFzLCB0aWxlU2l6ZSA9IDI0LCBjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5jdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdGhpcy50aWxlU2l6ZSA9IHRpbGVTaXplO1xuICAgICAgICB0aGlzLm1hcERhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnJhd01hcERhdGEgPSBudWxsOyAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgbWFwIGRhdGEgYmVmb3JlIGJvcmRlciBlbmZvcmNlbWVudFxuICAgICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICBcbiAgICAgICAgLy8gVGlsZSB0eXBlIGNvbnN0YW50cyAobWF0Y2hpbmcgeW91ciBmYWN0b3J5KVxuICAgICAgICB0aGlzLlRJTEVTID0ge1xuICAgICAgICAgICAgRU1QVFk6IDAsXG4gICAgICAgICAgICBXQUxMOiAxLFxuICAgICAgICAgICAgRE9UOiAyLCBcbiAgICAgICAgICAgIEdIT1NUX0RPT1I6IDMsXG4gICAgICAgICAgICBUVU5ORUw6IDQsXG4gICAgICAgICAgICBDT1JORVI6IDYsXG4gICAgICAgICAgICBHSE9TVF9TUEFXTjogNyxcbiAgICAgICAgICAgIFBPUlRBTDogOCxcbiAgICAgICAgICAgIFNVUEVSX0RPVDogOSxcbiAgICAgICAgICAgIFBPUlRBTF9CTE9DS0VSOiAxMCxcbiAgICAgICAgICAgIEZSVUlUOiAxMVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gQ29sb3JzIGZvciBkaWZmZXJlbnQgdGlsZSB0eXBlc1xuICAgICAgICB0aGlzLmNvbG9ycyA9IHtcbiAgICAgICAgICAgIHdhbGw6ICcjMDAzMUZGJywgLy8gUGFjLU1hbiBibHVlXG4gICAgICAgICAgICBkb3Q6ICcjRkZGRkI4JywgLy8gUGFjLU1hbiBkb3QgeWVsbG93XG4gICAgICAgICAgICBnaG9zdERvb3I6ICcjRkY2OUI0JyxcbiAgICAgICAgICAgIHR1bm5lbDogJyMwMDAwMDAnLCAvLyB0dW5uZWwgaXMgYmFja2dyb3VuZCBjb2xvclxuICAgICAgICAgICAgYmFja2dyb3VuZDogJyMwMDAwMDAnLFxuICAgICAgICAgICAgcGF0aDogJyMwMDAwODAnLFxuICAgICAgICAgICAgY29ybmVyOiAnI0ZGMDAwMCcsXG4gICAgICAgICAgICBnaG9zdFNwYXduOiAnIzAwRkYwMCcsXG4gICAgICAgICAgICBwb3J0YWw6ICcjMDAwMEZGJyxcbiAgICAgICAgICAgIHN1cGVyRG90OiAnI0ZGRkYwMCdcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcHBseUNvbmZpZyhjb25maWcpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBBY2NlcHRzIGEgY29uZmlnIG9iamVjdCB0byBvdmVycmlkZSBjb2xvcnMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyAtIE9wdGlvbmFsIGNvbmZpZyBvYmplY3Qgd2l0aCBjb2xvciBvdmVycmlkZXNcbiAgICAgKi9cbiAgICBhcHBseUNvbmZpZyhjb25maWcgPSB7fSkge1xuICAgICAgICBpZiAoY29uZmlnLmNvbG9ycykge1xuICAgICAgICAgICAgdGhpcy5jb2xvcnMgPSB7IC4uLnRoaXMuY29sb3JzLCAuLi5jb25maWcuY29sb3JzIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogTG9hZCBtYXAgZGF0YSBmcm9tIENTViBzdHJpbmcgZm9ybWF0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNzdkRhdGEgLSBDU1YgZm9ybWF0dGVkIG1hcCBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gTWFwIHdpZHRoIGluIHRpbGVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIE1hcCBoZWlnaHQgaW4gdGlsZXNcbiAgICAgKi9cbiAgICBsb2FkTWFwKGNzdkRhdGEsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICsgMjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKyAyO1xuICAgICAgICBjb25zdCByb3dzID0gY3N2RGF0YS50cmltKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICBjb25zdCByYXcgPSByb3dzLm1hcChyb3cgPT4gcm93LnNwbGl0KCcsJykubWFwKGNlbGwgPT4gdGhpcy5tYXBUaWxlQ29kZShwYXJzZUludChjZWxsLnRyaW0oKSwgMTApKSkpO1xuICAgICAgICAvLyBGaW5kIHBvcnRhbCBjb2x1bW5zL3Jvd3Mgb24gZWRnZXNcbiAgICAgICAgY29uc3QgcG9ydGFsQ29sc1RvcCA9IFtdO1xuICAgICAgICBjb25zdCBwb3J0YWxDb2xzQm90dG9tID0gW107XG4gICAgICAgIGNvbnN0IHBvcnRhbFJvd3NMZWZ0ID0gW107XG4gICAgICAgIGNvbnN0IHBvcnRhbFJvd3NSaWdodCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHdpZHRoOyBjKyspIHtcbiAgICAgICAgICAgIGlmIChyYXdbMF1bY10gPT09IHRoaXMuVElMRVMuUE9SVEFMKSBwb3J0YWxDb2xzVG9wLnB1c2goYyk7XG4gICAgICAgICAgICBpZiAocmF3W2hlaWdodC0xXVtjXSA9PT0gdGhpcy5USUxFUy5QT1JUQUwpIHBvcnRhbENvbHNCb3R0b20ucHVzaChjKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjcmFwMicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgaGVpZ2h0OyByKyspIHtcbiAgICAgICAgICAgIGlmIChyYXdbcl1bMF0gPT09IHRoaXMuVElMRVMuUE9SVEFMKSBwb3J0YWxSb3dzTGVmdC5wdXNoKHIpO1xuICAgICAgICAgICAgaWYgKHJhd1tyXVt3aWR0aC0xXSA9PT0gdGhpcy5USUxFUy5QT1JUQUwpIHBvcnRhbFJvd3NSaWdodC5wdXNoKHIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2NyYXAxJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQnVpbGQgYm9yZGVyZWQgbWFwXG4gICAgICAgIHRoaXMubWFwRGF0YSA9IFtdO1xuICAgICAgICAvLyBUb3AgYm9yZGVyXG4gICAgICAgIGNvbnN0IHRvcFJvdyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHdpZHRoICsgMjsgYysrKSB7XG4gICAgICAgICAgICBpZiAoYyA+IDAgJiYgYyA8IHdpZHRoICsgMSAmJiBwb3J0YWxDb2xzVG9wLmluY2x1ZGVzKGMtMSkpIHRvcFJvdy5wdXNoKHRoaXMuVElMRVMuUE9SVEFMX0JMT0NLRVIpO1xuICAgICAgICAgICAgZWxzZSB0b3BSb3cucHVzaCh0aGlzLlRJTEVTLldBTEwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFwRGF0YS5wdXNoKHRvcFJvdyk7XG4gICAgICAgIC8vIE1pZGRsZSByb3dzXG4gICAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgaGVpZ2h0OyByKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgICAgICAgICAgLy8gTGVmdCBib3JkZXJcbiAgICAgICAgICAgIGlmIChwb3J0YWxSb3dzTGVmdC5pbmNsdWRlcyhyKSkgcm93LnB1c2godGhpcy5USUxFUy5QT1JUQUxfQkxPQ0tFUik7XG4gICAgICAgICAgICBlbHNlIHJvdy5wdXNoKHRoaXMuVElMRVMuV0FMTCk7XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCByb3dcbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgd2lkdGg7IGMrKykgcm93LnB1c2gocmF3W3JdW2NdKTtcbiAgICAgICAgICAgIC8vIFJpZ2h0IGJvcmRlclxuICAgICAgICAgICAgaWYgKHBvcnRhbFJvd3NSaWdodC5pbmNsdWRlcyhyKSkgcm93LnB1c2godGhpcy5USUxFUy5QT1JUQUxfQkxPQ0tFUik7XG4gICAgICAgICAgICBlbHNlIHJvdy5wdXNoKHRoaXMuVElMRVMuV0FMTCk7XG4gICAgICAgICAgICB0aGlzLm1hcERhdGEucHVzaChyb3cpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJvdHRvbSBib3JkZXJcbiAgICAgICAgY29uc3QgYm90dG9tUm93ID0gW107XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgd2lkdGggKyAyOyBjKyspIHtcbiAgICAgICAgICAgIGlmIChjID4gMCAmJiBjIDwgd2lkdGggKyAxICYmIHBvcnRhbENvbHNCb3R0b20uaW5jbHVkZXMoYy0xKSkgYm90dG9tUm93LnB1c2godGhpcy5USUxFUy5QT1JUQUxfQkxPQ0tFUik7XG4gICAgICAgICAgICBlbHNlIGJvdHRvbVJvdy5wdXNoKHRoaXMuVElMRVMuV0FMTCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXBEYXRhLnB1c2goYm90dG9tUm93KTtcblxuICAgICAgICAvLyAtLS0gQWRkIFBPUlRBTF9CTE9DS0VSIGJlaGluZCBlYWNoIHBvcnRhbCAtLS1cbiAgICAgICAgLy8gT25seSBwbGFjZSBibG9ja2VyIGlmIHRoZSB0aWxlIGlzIHRydWx5IEVNUFRZIChkbyBub3Qgb3ZlcndyaXRlIHN1cGVyIGRvdHMsIGRvdHMsIGZydWl0LCBldGMpXG4gICAgICAgIGNvbnN0IGJsb2NrYWJsZVRpbGVzID0gW3RoaXMuVElMRVMuRU1QVFldO1xuICAgICAgICAvLyBUb3AgcG9ydGFsczogcGxhY2UgYmxvY2tlciBiZWxvd1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgcG9ydGFsQ29sc1RvcCkge1xuICAgICAgICAgICAgaWYgKGJsb2NrYWJsZVRpbGVzLmluY2x1ZGVzKHRoaXMubWFwRGF0YVsxXVtjKzFdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFwRGF0YVsxXVtjKzFdID0gdGhpcy5USUxFUy5QT1JUQUxfQkxPQ0tFUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCb3R0b20gcG9ydGFsczogcGxhY2UgYmxvY2tlciBhYm92ZVxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgcG9ydGFsQ29sc0JvdHRvbSkge1xuICAgICAgICAgICAgaWYgKGJsb2NrYWJsZVRpbGVzLmluY2x1ZGVzKHRoaXMubWFwRGF0YVt0aGlzLm1hcERhdGEubGVuZ3RoLTJdW2MrMV0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXBEYXRhW3RoaXMubWFwRGF0YS5sZW5ndGgtMl1bYysxXSA9IHRoaXMuVElMRVMuUE9SVEFMX0JMT0NLRVI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGVmdCBwb3J0YWxzOiBwbGFjZSBibG9ja2VyIHJpZ2h0XG4gICAgICAgIGZvciAoY29uc3QgciBvZiBwb3J0YWxSb3dzTGVmdCkge1xuICAgICAgICAgICAgaWYgKGJsb2NrYWJsZVRpbGVzLmluY2x1ZGVzKHRoaXMubWFwRGF0YVtyKzFdWzFdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFwRGF0YVtyKzFdWzFdID0gdGhpcy5USUxFUy5QT1JUQUxfQkxPQ0tFUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSaWdodCBwb3J0YWxzOiBwbGFjZSBibG9ja2VyIGxlZnRcbiAgICAgICAgZm9yIChjb25zdCByIG9mIHBvcnRhbFJvd3NSaWdodCkge1xuICAgICAgICAgICAgaWYgKGJsb2NrYWJsZVRpbGVzLmluY2x1ZGVzKHRoaXMubWFwRGF0YVtyKzFdW3RoaXMubWFwRGF0YVswXS5sZW5ndGgtMl0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXBEYXRhW3IrMV1bdGhpcy5tYXBEYXRhWzBdLmxlbmd0aC0yXSA9IHRoaXMuVElMRVMuUE9SVEFMX0JMT0NLRVI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGggKiB0aGlzLnRpbGVTaXplO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodCAqIHRoaXMudGlsZVNpemU7XG4gICAgICAgIGNvbnNvbGUubG9nKGBNYXAgbG9hZGVkIHdpdGggYm9yZGVyOiAke3RoaXMud2lkdGh9eCR7dGhpcy5oZWlnaHR9YCwgdGhpcy5tYXBEYXRhKTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogTWFwIGxlZ2FjeS9kZW1vIHRpbGUgY29kZXMgdG8gaW50ZXJuYWwgdGlsZSB0eXBlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlIC0gcmF3IHRpbGUgY29kZSBmcm9tIENTVlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG1hcHBlZCB0aWxlIGNvZGVcbiAgICAgKi9cbiAgICBtYXBUaWxlQ29kZShjb2RlKSB7XG4gICAgICAgIC8vIFRpbGUgY29kZSBtZWFuaW5nczpcbiAgICAgICAgLy8gMCA9IHdhbGwsIDEgPSBlbXB0eS9wYXRoLCAyID0gc3VwZXIgZG90IChjb3JuZXJzKSwgMyA9IGdob3N0IHNwYXduLCA0ID0gcG9ydGFsLCA1ID0gZ2hvc3QgZG9vclxuICAgICAgICBzd2l0Y2goY29kZSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlRJTEVTLldBTEw7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuVElMRVMuRU1QVFk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuVElMRVMuU1VQRVJfRE9UO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlRJTEVTLkdIT1NUX1NQQVdOO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlRJTEVTLlBPUlRBTDtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5USUxFUy5HSE9TVF9ET09SO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5USUxFUy5FTVBUWTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhlcmUgaXMgYWx3YXlzIGEgYm9yZGVyIG9mIHdhbGxzIGFyb3VuZCB0aGUgbWFwLFxuICAgICAqIGV4Y2VwdCBmb3IgdHVubmVsL3BvcnRhbCB0aWxlcyAoVFVOTkVMKSBhdCB0aGUgYm9yZGVyLlxuICAgICAqIFRoaXMgbW9kaWZpZXMgbWFwRGF0YSBpbi1wbGFjZSBhZnRlciBsb2FkaW5nLlxuICAgICAqL1xuICAgIGVuc3VyZVdhbGxCb3JkZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXBEYXRhKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLm1hcERhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy5tYXBEYXRhWzBdLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBoOyByKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdzsgYysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNFZGdlID0gKHIgPT09IDAgfHwgciA9PT0gaC0xIHx8IGMgPT09IDAgfHwgYyA9PT0gdy0xKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSB0dW5uZWwvcG9ydGFsLCBwcmVzZXJ2ZSBpdFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXBEYXRhW3JdW2NdID09PSB0aGlzLlRJTEVTLlRVTk5FTCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZW5mb3JjZSB3YWxsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwRGF0YVtyXVtjXSA9IHRoaXMuVElMRVMuV0FMTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSBlbnRpcmUgbWFwIHRvIGNhbnZhc1xuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hcERhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIG1hcCBkYXRhIGxvYWRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciBjYW52YXNcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcnMuYmFja2dyb3VuZDtcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW5kZXIgZWFjaCB0aWxlXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMuaGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy53aWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aWxlVHlwZSA9IHRoaXMubWFwRGF0YVtyb3ddW2NvbF07XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaWxlKGNvbCwgcm93LCB0aWxlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgc2luZ2xlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2wgLSBDb2x1bW4gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93IC0gUm93IHBvc2l0aW9uICBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGlsZVR5cGUgLSBUeXBlIG9mIHRpbGUgdG8gcmVuZGVyXG4gICAgICovXG4gICAgcmVuZGVyVGlsZShjb2wsIHJvdywgdGlsZVR5cGUpIHtcbiAgICAgICAgY29uc3QgeCA9IGNvbCAqIHRoaXMudGlsZVNpemU7XG4gICAgICAgIGNvbnN0IHkgPSByb3cgKiB0aGlzLnRpbGVTaXplO1xuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSB3YWxsIGF0IHRoZSBib3JkZXIgYW5kIHRoZSAqb3JpZ2luYWwqIHRpbGUgd2FzIGEgdHVubmVsLCBza2lwIHJlbmRlcmluZyAodHJhbnNwYXJlbnQpXG4gICAgICAgIGNvbnN0IGlzRWRnZSA9IChyb3cgPT09IDAgfHwgcm93ID09PSB0aGlzLmhlaWdodC0xIHx8IGNvbCA9PT0gMCB8fCBjb2wgPT09IHRoaXMud2lkdGgtMSk7XG4gICAgICAgIC8vIFVzZSB0aGUgcmF3IG1hcCBkYXRhIChiZWZvcmUgd2FsbCBib3JkZXIgZW5mb3JjZW1lbnQpIHRvIGNoZWNrIGZvciB0dW5uZWxcbiAgICAgICAgaWYgKHRpbGVUeXBlID09PSB0aGlzLlRJTEVTLldBTEwgJiYgaXNFZGdlICYmIHRoaXMucmF3TWFwRGF0YSAmJiB0aGlzLnJhd01hcERhdGFbcm93XVtjb2xdID09PSB0aGlzLlRJTEVTLlRVTk5FTCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBEb24ndCByZW5kZXIgd2FsbCBhdCB0dW5uZWwvcG9ydGFsXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbGVUeXBlID09PSB0aGlzLlRJTEVTLldBTEwpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyV2FsbCh4LCB5KTtcbiAgICAgICAgfSBlbHNlIHN3aXRjaCh0aWxlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSB0aGlzLlRJTEVTLkRPVDpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclBhdGgoeCwgeSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJEb3QoeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuVElMRVMuR0hPU1RfRE9PUjpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclBhdGgoeCwgeSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJHaG9zdERvb3IoeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuVElMRVMuVFVOTkVMOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUGF0aCh4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5USUxFUy5DT1JORVI6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJQYXRoKHgsIHkpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQ29ybmVyKHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0aGlzLlRJTEVTLkdIT1NUX1NQQVdOOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUGF0aCh4LCB5KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckdob3N0U3Bhd24oeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuVElMRVMuUE9SVEFMOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUGF0aCh4LCB5KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclBvcnRhbCh4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5USUxFUy5TVVBFUl9ET1Q6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJQYXRoKHgsIHkpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyU3VwZXJEb3QoeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUGF0aCh4LCB5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSB3YWxsIHRpbGVcbiAgICAgKi9cbiAgICByZW5kZXJXYWxsKHgsIHkpIHtcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcnMud2FsbDtcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoeCwgeSwgdGhpcy50aWxlU2l6ZSwgdGhpcy50aWxlU2l6ZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgd2FsbCBib3JkZXIgZm9yIGRlZmluaXRpb25cbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSAnIzQ0NDRGRic7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVJlY3QoeCwgeSwgdGhpcy50aWxlU2l6ZSwgdGhpcy50aWxlU2l6ZSk7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFJlbmRlciBhIHBhdGgvY29ycmlkb3IgYmFja2dyb3VuZFxuICAgICAqL1xuICAgIHJlbmRlclBhdGgoeCwgeSkge1xuICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9ycy5wYXRoO1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCh4LCB5LCB0aGlzLnRpbGVTaXplLCB0aGlzLnRpbGVTaXplKTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgZG90IChwZWxsZXQpXG4gICAgICovXG4gICAgcmVuZGVyRG90KHgsIHkpIHtcbiAgICAgICAgY29uc3QgY2VudGVyWCA9IHggKyB0aGlzLnRpbGVTaXplIC8gMjtcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IHkgKyB0aGlzLnRpbGVTaXplIC8gMjtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5tYXgoMiwgdGhpcy50aWxlU2l6ZSAvIDgpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcnMuZG90O1xuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5jdHguYXJjKGNlbnRlclgsIGNlbnRlclksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICB0aGlzLmN0eC5maWxsKCk7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFJlbmRlciBhIGdob3N0IGRvb3IgKHNwZWNpYWwgZ2F0ZSlcbiAgICAgKi9cbiAgICByZW5kZXJHaG9zdERvb3IoeCwgeSkge1xuICAgICAgICAvLyBIb3Jpem9udGFsIGxpbmUgYWNyb3NzIHRoZSBtaWRkbGVcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9ycy5naG9zdERvb3I7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IDM7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oeCwgeSArIHRoaXMudGlsZVNpemUgLyAyKTtcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKHggKyB0aGlzLnRpbGVTaXplLCB5ICsgdGhpcy50aWxlU2l6ZSAvIDIpO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgdHVubmVsIGVudHJhbmNlXG4gICAgICovXG4gICAgcmVuZGVyVHVubmVsKHgsIHkpIHtcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcnMudHVubmVsO1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCh4LCB5LCB0aGlzLnRpbGVTaXplLCB0aGlzLnRpbGVTaXplKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBzb21lIHR1bm5lbCBpbmRpY2F0b3JzXG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9ICcjMDA4ODg4JztcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoeCArIDIsIHkgKyAyLCB0aGlzLnRpbGVTaXplIC0gNCwgdGhpcy50aWxlU2l6ZSAtIDQpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBjb3JuZXJcbiAgICAgKi9cbiAgICByZW5kZXJDb3JuZXIoeCwgeSkge1xuICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9ycy5jb3JuZXI7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KHgsIHksIHRoaXMudGlsZVNpemUsIHRoaXMudGlsZVNpemUpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBnaG9zdCBzcGF3blxuICAgICAqL1xuICAgIHJlbmRlckdob3N0U3Bhd24oeCwgeSkge1xuICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9ycy5naG9zdFNwYXduO1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCh4LCB5LCB0aGlzLnRpbGVTaXplLCB0aGlzLnRpbGVTaXplKTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgcG9ydGFsXG4gICAgICovXG4gICAgcmVuZGVyUG9ydGFsKHgsIHkpIHtcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcnMucG9ydGFsO1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCh4LCB5LCB0aGlzLnRpbGVTaXplLCB0aGlzLnRpbGVTaXplKTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgc3VwZXIgZG90XG4gICAgICovXG4gICAgcmVuZGVyU3VwZXJEb3QoeCwgeSkge1xuICAgICAgICBjb25zdCBjZW50ZXJYID0geCArIHRoaXMudGlsZVNpemUgLyAyO1xuICAgICAgICBjb25zdCBjZW50ZXJZID0geSArIHRoaXMudGlsZVNpemUgLyAyO1xuICAgICAgICBjb25zdCByYWRpdXMgPSBNYXRoLm1heCg0LCB0aGlzLnRpbGVTaXplIC8gNCk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9ycy5zdXBlckRvdDtcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4LmFyYyhjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgdGhpcy5jdHguZmlsbCgpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBHZXQgdGlsZSB0eXBlIGF0IHdvcmxkIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdvcmxkWCAtIFggY29vcmRpbmF0ZSBpbiBwaXhlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd29ybGRZIC0gWSBjb29yZGluYXRlIGluIHBpeGVsc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRpbGUgdHlwZVxuICAgICAqL1xuICAgIGdldFRpbGVBdCh3b3JsZFgsIHdvcmxkWSkge1xuICAgICAgICBjb25zdCBjb2wgPSBNYXRoLmZsb29yKHdvcmxkWCAvIHRoaXMudGlsZVNpemUpO1xuICAgICAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKHdvcmxkWSAvIHRoaXMudGlsZVNpemUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJvdyA8IDAgfHwgcm93ID49IHRoaXMuaGVpZ2h0IHx8IGNvbCA8IDAgfHwgY29sID49IHRoaXMud2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlRJTEVTLldBTEw7IC8vIFRyZWF0IG91dC1vZi1ib3VuZHMgYXMgd2FsbHNcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRGF0YVtyb3ddW2NvbF07XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgZ3JpZCBjb29yZGluYXRlcyB0byB3b3JsZCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2wgLSBDb2x1bW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93IC0gUm93XG4gICAgICogQHJldHVybnMge29iamVjdH0gV29ybGQgY29vcmRpbmF0ZXMge3gsIHl9XG4gICAgICovXG4gICAgZ3JpZFRvV29ybGQoY29sLCByb3cpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGNvbCAqIHRoaXMudGlsZVNpemUgKyB0aGlzLnRpbGVTaXplIC8gMixcbiAgICAgICAgICAgIHk6IHJvdyAqIHRoaXMudGlsZVNpemUgKyB0aGlzLnRpbGVTaXplIC8gMlxuICAgICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHdvcmxkIGNvb3JkaW5hdGVzIHRvIGdyaWQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd29ybGRYIC0gV29ybGQgWCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdvcmxkWSAtIFdvcmxkIFkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IEdyaWQgY29vcmRpbmF0ZXMge2NvbCwgcm93fVxuICAgICAqL1xuICAgIHdvcmxkVG9HcmlkKHdvcmxkWCwgd29ybGRZKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2w6IE1hdGguZmxvb3Iod29ybGRYIC8gdGhpcy50aWxlU2l6ZSksXG4gICAgICAgICAgICByb3c6IE1hdGguZmxvb3Iod29ybGRZIC8gdGhpcy50aWxlU2l6ZSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogRmluZCBhbGwgdGlsZXMgb2YgYSBzcGVjaWZpYyB0eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbGVUeXBlIC0gVHlwZSB0byBzZWFyY2ggZm9yXG4gICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiB7Y29sLCByb3d9IHBvc2l0aW9uc1xuICAgICAqL1xuICAgIGZpbmRUaWxlcyh0aWxlVHlwZSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMuaGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy53aWR0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXBEYXRhW3Jvd11bY29sXSA9PT0gdGlsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goe2NvbCwgcm93fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcG9zaXRpb25zO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWFwUmVuZGVyZXI7Il0sIm5hbWVzIjpbIk1hcFJlbmRlcmVyIiwiY2FudmFzIiwidGlsZVNpemUiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJjb25maWciLCJfY2xhc3NDYWxsQ2hlY2siLCJjdHgiLCJnZXRDb250ZXh0IiwibWFwRGF0YSIsInJhd01hcERhdGEiLCJ3aWR0aCIsImhlaWdodCIsIlRJTEVTIiwiRU1QVFkiLCJXQUxMIiwiRE9UIiwiR0hPU1RfRE9PUiIsIlRVTk5FTCIsIkNPUk5FUiIsIkdIT1NUX1NQQVdOIiwiUE9SVEFMIiwiU1VQRVJfRE9UIiwiUE9SVEFMX0JMT0NLRVIiLCJGUlVJVCIsImNvbG9ycyIsIndhbGwiLCJkb3QiLCJnaG9zdERvb3IiLCJ0dW5uZWwiLCJiYWNrZ3JvdW5kIiwicGF0aCIsImNvcm5lciIsImdob3N0U3Bhd24iLCJwb3J0YWwiLCJzdXBlckRvdCIsImFwcGx5Q29uZmlnIiwiX2NyZWF0ZUNsYXNzIiwia2V5IiwidmFsdWUiLCJfb2JqZWN0U3ByZWFkIiwibG9hZE1hcCIsImNzdkRhdGEiLCJfdGhpcyIsInJvd3MiLCJ0cmltIiwic3BsaXQiLCJyYXciLCJtYXAiLCJyb3ciLCJjZWxsIiwibWFwVGlsZUNvZGUiLCJwYXJzZUludCIsInBvcnRhbENvbHNUb3AiLCJwb3J0YWxDb2xzQm90dG9tIiwicG9ydGFsUm93c0xlZnQiLCJwb3J0YWxSb3dzUmlnaHQiLCJjIiwicHVzaCIsImNvbnNvbGUiLCJsb2ciLCJyIiwidG9wUm93IiwiaW5jbHVkZXMiLCJib3R0b21Sb3ciLCJibG9ja2FibGVUaWxlcyIsIl9pIiwiX3BvcnRhbENvbHNUb3AiLCJfaTIiLCJfcG9ydGFsQ29sc0JvdHRvbSIsIl9pMyIsIl9wb3J0YWxSb3dzTGVmdCIsIl9pNCIsIl9wb3J0YWxSb3dzUmlnaHQiLCJjb25jYXQiLCJjb2RlIiwiZW5zdXJlV2FsbEJvcmRlciIsImgiLCJ3IiwiaXNFZGdlIiwicmVuZGVyIiwiZXJyb3IiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImNvbCIsInRpbGVUeXBlIiwicmVuZGVyVGlsZSIsIngiLCJ5IiwicmVuZGVyV2FsbCIsInJlbmRlclBhdGgiLCJyZW5kZXJEb3QiLCJyZW5kZXJHaG9zdERvb3IiLCJyZW5kZXJDb3JuZXIiLCJyZW5kZXJHaG9zdFNwYXduIiwicmVuZGVyUG9ydGFsIiwicmVuZGVyU3VwZXJEb3QiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInN0cm9rZVJlY3QiLCJjZW50ZXJYIiwiY2VudGVyWSIsInJhZGl1cyIsIk1hdGgiLCJtYXgiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImZpbGwiLCJtb3ZlVG8iLCJsaW5lVG8iLCJzdHJva2UiLCJyZW5kZXJUdW5uZWwiLCJnZXRUaWxlQXQiLCJ3b3JsZFgiLCJ3b3JsZFkiLCJmbG9vciIsImdyaWRUb1dvcmxkIiwid29ybGRUb0dyaWQiLCJmaW5kVGlsZXMiLCJwb3NpdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/assets/js/map-renderer.js\n\n}");

/***/ }),

/***/ "./resources/assets/js/player-entity.js":
/*!**********************************************!*\
  !*** ./resources/assets/js/player-entity.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PlayerEntity)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n// player-entity.js\n// KISS: minimal, extensible player entity for movement/collision, future-proof for ghosts\nvar PlayerEntity = /*#__PURE__*/function () {\n  function PlayerEntity(startCol, startRow, tileSize, mapData, settings) {\n    var speed = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 4;\n    _classCallCheck(this, PlayerEntity);\n    this.col = startCol;\n    this.row = startRow;\n    this.tileSize = tileSize;\n    this.mapData = mapData; // reference to current map\n    this.direction = null; // default: no movement until input\n    this.nextDirection = null;\n    this.state = 'normal'; // 'normal' or 'super'\n    this.defaultSpeed = settings.playerSpeed || 2;\n    this.superSpeed = settings.playerSuperSpeed || 4;\n    this.speed = this.defaultSpeed;\n    // tileSize is fixed for logic; visual scale only\n    this.x = this.col * this.tileSize;\n    this.y = this.row * this.tileSize;\n    this.targetX = this.x;\n    this.targetY = this.y;\n    this.moving = false;\n    this.type = 'player'; // added type property\n  }\n  return _createClass(PlayerEntity, [{\n    key: \"setDirection\",\n    value: function setDirection(dir) {\n      this.nextDirection = dir;\n    }\n\n    // Check if a direction is walkable (not a wall or ghost door for player)\n  }, {\n    key: \"canMove\",\n    value: function canMove(dir) {\n      var _PlayerEntity$directi = PlayerEntity.directionDelta(dir),\n        _PlayerEntity$directi2 = _slicedToArray(_PlayerEntity$directi, 2),\n        dCol = _PlayerEntity$directi2[0],\n        dRow = _PlayerEntity$directi2[1];\n      var nCol = this.col + dCol;\n      var nRow = this.row + dRow;\n      if (nCol < 0 || nRow < 0 || nRow >= this.mapData.length || nCol >= this.mapData[0].length) return false;\n      var nextTile = this.mapData[nRow][nCol];\n\n      /**\n       *  Block movement into custom portal-blocker tile (e.g., 10 = PORTAL_BLOCKER)\n       *  We also check siblings for out of bounds.\n       */\n      if (nextTile === 10) {\n        return false;\n      }\n      if (nextTile === 8 &&\n      // 8 = PORTAL\n      this.mapData[this.row][this.col] === 8) {\n        return false;\n      }\n      // Prevent player from entering ghost door\n      if (nextTile === 1 ||\n      // wall\n      nextTile === 3 && this.type === 'player' // 3 = GHOST_DOOR\n      ) {\n        return false;\n      }\n      return true;\n    }\n\n    // Move one step if possible, handle direction changes\n  }, {\n    key: \"move\",\n    value: function move() {\n      // If not moving, check for direction and set target\n      if (!this.moving) {\n        if (this.nextDirection && this.canMove(this.nextDirection)) {\n          this.direction = this.nextDirection;\n          this.nextDirection = null;\n        }\n        if (this.canMove(this.direction)) {\n          var _PlayerEntity$directi3 = PlayerEntity.directionDelta(this.direction),\n            _PlayerEntity$directi4 = _slicedToArray(_PlayerEntity$directi3, 2),\n            dCol = _PlayerEntity$directi4[0],\n            dRow = _PlayerEntity$directi4[1];\n          // Prevent moving out of bounds\n          var nextCol = this.col + dCol;\n          var nextRow = this.row + dRow;\n          if (nextCol < 0 || nextRow < 0 || nextRow >= this.mapData.length || nextCol >= this.mapData[0].length || this.mapData[nextRow][nextCol] === 1 // wall\n          ) {\n            this.moving = false;\n            return;\n          }\n          this.targetX = nextCol * this.tileSize;\n          this.targetY = nextRow * this.tileSize;\n          this.moving = true;\n        }\n      }\n      // If moving, interpolate toward target\n      if (this.moving) {\n        var dx = this.targetX - this.x;\n        var dy = this.targetY - this.y;\n        var dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist <= this.speed) {\n          // Snap to target\n          this.x = this.targetX;\n          this.y = this.targetY;\n          var _PlayerEntity$directi5 = PlayerEntity.directionDelta(this.direction),\n            _PlayerEntity$directi6 = _slicedToArray(_PlayerEntity$directi5, 2),\n            _dCol = _PlayerEntity$directi6[0],\n            _dRow = _PlayerEntity$directi6[1];\n          this.col += _dCol;\n          this.row += _dRow;\n          this.moving = false;\n        } else {\n          // Move toward target\n          var angle = Math.atan2(dy, dx);\n          this.x += this.speed * Math.cos(angle);\n          this.y += this.speed * Math.sin(angle);\n        }\n      }\n    }\n  }, {\n    key: \"setSuperState\",\n    value: function setSuperState(isSuper) {\n      if (isSuper) {\n        this.state = 'super';\n        this.speed = this.superSpeed;\n      } else {\n        this.state = 'normal';\n        this.speed = this.defaultSpeed;\n      }\n    }\n\n    // Utility: direction string to delta\n  }, {\n    key: \"isAt\",\n    value:\n    // For collision with ghosts or dots\n    function isAt(col, row) {\n      return this.col === col && this.row === row;\n    }\n\n    // Render Player (simple yellow circle for now)\n  }, {\n    key: \"render\",\n    value: function render(ctx) {\n      ctx.save();\n      var scale = this.state === 'super' ? 1.2 : 1;\n      var centerX = this.x + this.tileSize / 2;\n      var centerY = this.y + this.tileSize / 2;\n      ctx.translate(centerX, centerY);\n      ctx.scale(scale, scale);\n      ctx.translate(-centerX, -centerY);\n      ctx.fillStyle = '#FFFF00';\n      ctx.beginPath();\n      ctx.arc(centerX, centerY, this.tileSize / 2 - 2, 0, 2 * Math.PI);\n      ctx.fill();\n      ctx.restore();\n    }\n  }], [{\n    key: \"directionDelta\",\n    value: function directionDelta(dir) {\n      switch (dir) {\n        case 'left':\n          return [-1, 0];\n        case 'right':\n          return [1, 0];\n        case 'up':\n          return [0, -1];\n        case 'down':\n          return [0, 1];\n        default:\n          return [0, 0];\n      }\n    }\n  }]);\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3BsYXllci1lbnRpdHkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQSxJQUVxQkEsWUFBWTtFQUM3QixTQUFBQSxhQUFZQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsRUFBYTtJQUFBLElBQVhDLEtBQUssR0FBQUMsU0FBQSxDQUFBQyxNQUFBLFFBQUFELFNBQUEsUUFBQUUsU0FBQSxHQUFBRixTQUFBLE1BQUcsQ0FBQztJQUFBRyxlQUFBLE9BQUFWLFlBQUE7SUFDbEUsSUFBSSxDQUFDVyxHQUFHLEdBQUdWLFFBQVE7SUFDbkIsSUFBSSxDQUFDVyxHQUFHLEdBQUdWLFFBQVE7SUFDbkIsSUFBSSxDQUFDQyxRQUFRLEdBQUdBLFFBQVE7SUFDeEIsSUFBSSxDQUFDQyxPQUFPLEdBQUdBLE9BQU8sQ0FBQyxDQUFDO0lBQ3hCLElBQUksQ0FBQ1MsU0FBUyxHQUFHLElBQUksQ0FBQyxDQUFDO0lBQ3ZCLElBQUksQ0FBQ0MsYUFBYSxHQUFHLElBQUk7SUFDekIsSUFBSSxDQUFDQyxLQUFLLEdBQUcsUUFBUSxDQUFDLENBQUM7SUFDdkIsSUFBSSxDQUFDQyxZQUFZLEdBQUdYLFFBQVEsQ0FBQ1ksV0FBVyxJQUFJLENBQUM7SUFDN0MsSUFBSSxDQUFDQyxVQUFVLEdBQUdiLFFBQVEsQ0FBQ2MsZ0JBQWdCLElBQUksQ0FBQztJQUNoRCxJQUFJLENBQUNiLEtBQUssR0FBRyxJQUFJLENBQUNVLFlBQVk7SUFDOUI7SUFDQSxJQUFJLENBQUNJLENBQUMsR0FBRyxJQUFJLENBQUNULEdBQUcsR0FBRyxJQUFJLENBQUNSLFFBQVE7SUFDakMsSUFBSSxDQUFDa0IsQ0FBQyxHQUFHLElBQUksQ0FBQ1QsR0FBRyxHQUFHLElBQUksQ0FBQ1QsUUFBUTtJQUNqQyxJQUFJLENBQUNtQixPQUFPLEdBQUcsSUFBSSxDQUFDRixDQUFDO0lBQ3JCLElBQUksQ0FBQ0csT0FB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QUMsRUFBRSxDQUFDLENBQUM7UUFDMUI7VUFBUyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztNQUMxQjtJQUNKO0VBQUM7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmFjb25tYW4vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3BsYXllci1lbnRpdHkuanM/MTFiZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBwbGF5ZXItZW50aXR5LmpzXG4vLyBLSVNTOiBtaW5pbWFsLCBleHRlbnNpYmxlIHBsYXllciBlbnRpdHkgZm9yIG1vdmVtZW50L2NvbGxpc2lvbiwgZnV0dXJlLXByb29mIGZvciBnaG9zdHNcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxheWVyRW50aXR5IHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydENvbCwgc3RhcnRSb3csIHRpbGVTaXplLCBtYXBEYXRhLCBzZXR0aW5ncywgc3BlZWQgPSA0KSB7XG4gICAgICAgIHRoaXMuY29sID0gc3RhcnRDb2w7XG4gICAgICAgIHRoaXMucm93ID0gc3RhcnRSb3c7XG4gICAgICAgIHRoaXMudGlsZVNpemUgPSB0aWxlU2l6ZTtcbiAgICAgICAgdGhpcy5tYXBEYXRhID0gbWFwRGF0YTsgLy8gcmVmZXJlbmNlIHRvIGN1cnJlbnQgbWFwXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gbnVsbDsgLy8gZGVmYXVsdDogbm8gbW92ZW1lbnQgdW50aWwgaW5wdXRcbiAgICAgICAgdGhpcy5uZXh0RGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdub3JtYWwnOyAvLyAnbm9ybWFsJyBvciAnc3VwZXInXG4gICAgICAgIHRoaXMuZGVmYXVsdFNwZWVkID0gc2V0dGluZ3MucGxheWVyU3BlZWQgfHwgMjtcbiAgICAgICAgdGhpcy5zdXBlclNwZWVkID0gc2V0dGluZ3MucGxheWVyU3VwZXJTcGVlZCB8fCA0O1xuICAgICAgICB0aGlzLnNwZWVkID0gdGhpcy5kZWZhdWx0U3BlZWQ7XG4gICAgICAgIC8vIHRpbGVTaXplIGlzIGZpeGVkIGZvciBsb2dpYzsgdmlzdWFsIHNjYWxlIG9ubHlcbiAgICAgICAgdGhpcy54ID0gdGhpcy5jb2wgKiB0aGlzLnRpbGVTaXplO1xuICAgICAgICB0aGlzLnkgPSB0aGlzLnJvdyAqIHRoaXMudGlsZVNpemU7XG4gICAgICAgIHRoaXMudGFyZ2V0WCA9IHRoaXMueDtcbiAgICAgICAgdGhpcy50YXJnZXRZID0gdGhpcy55O1xuICAgICAgICB0aGlzLm1vdmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnR5cGUgPSAncGxheWVyJzsgLy8gYWRkZWQgdHlwZSBwcm9wZXJ0eVxuICAgIH1cblxuICAgIHNldERpcmVjdGlvbihkaXIpIHtcbiAgICAgICAgdGhpcy5uZXh0RGlyZWN0aW9uID0gZGlyO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGEgZGlyZWN0aW9uIGlzIHdhbGthYmxlIChub3QgYSB3YWxsIG9yIGdob3N0IGRvb3IgZm9yIHBsYXllcilcbiAgICBjYW5Nb3ZlKGRpcikge1xuICAgICAgICBsZXQgW2RDb2wsIGRSb3ddID0gUGxheWVyRW50aXR5LmRpcmVjdGlvbkRlbHRhKGRpcik7XG4gICAgICAgIGxldCBuQ29sID0gdGhpcy5jb2wgKyBkQ29sO1xuICAgICAgICBsZXQgblJvdyA9IHRoaXMucm93ICsgZFJvdztcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbkNvbCA8IDAgfHwgblJvdyA8IDAgfHxcbiAgICAgICAgICAgIG5Sb3cgPj0gdGhpcy5tYXBEYXRhLmxlbmd0aCB8fCBuQ29sID49IHRoaXMubWFwRGF0YVswXS5sZW5ndGhcbiAgICAgICAgKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgbmV4dFRpbGUgPSB0aGlzLm1hcERhdGFbblJvd11bbkNvbF07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICBCbG9jayBtb3ZlbWVudCBpbnRvIGN1c3RvbSBwb3J0YWwtYmxvY2tlciB0aWxlIChlLmcuLCAxMCA9IFBPUlRBTF9CTE9DS0VSKVxuICAgICAgICAgKiAgV2UgYWxzbyBjaGVjayBzaWJsaW5ncyBmb3Igb3V0IG9mIGJvdW5kcy5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChuZXh0VGlsZSA9PT0gMTApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBuZXh0VGlsZSA9PT0gOCAmJiAvLyA4ID0gUE9SVEFMXG4gICAgICAgICAgICB0aGlzLm1hcERhdGFbdGhpcy5yb3ddW3RoaXMuY29sXSA9PT0gOFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IHBsYXllciBmcm9tIGVudGVyaW5nIGdob3N0IGRvb3JcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmV4dFRpbGUgPT09IDEgfHwgLy8gd2FsbFxuICAgICAgICAgICAgKG5leHRUaWxlID09PSAzICYmIHRoaXMudHlwZSA9PT0gJ3BsYXllcicpIC8vIDMgPSBHSE9TVF9ET09SXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE1vdmUgb25lIHN0ZXAgaWYgcG9zc2libGUsIGhhbmRsZSBkaXJlY3Rpb24gY2hhbmdlc1xuICAgIG1vdmUoKSB7XG4gICAgICAgIC8vIElmIG5vdCBtb3ZpbmcsIGNoZWNrIGZvciBkaXJlY3Rpb24gYW5kIHNldCB0YXJnZXRcbiAgICAgICAgaWYgKCF0aGlzLm1vdmluZykge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dERpcmVjdGlvbiAmJiB0aGlzLmNhbk1vdmUodGhpcy5uZXh0RGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gdGhpcy5uZXh0RGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dERpcmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5Nb3ZlKHRoaXMuZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIGxldCBbZENvbCwgZFJvd10gPSBQbGF5ZXJFbnRpdHkuZGlyZWN0aW9uRGVsdGEodGhpcy5kaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbW92aW5nIG91dCBvZiBib3VuZHNcbiAgICAgICAgICAgICAgICBsZXQgbmV4dENvbCA9IHRoaXMuY29sICsgZENvbDtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFJvdyA9IHRoaXMucm93ICsgZFJvdztcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIG5leHRDb2wgPCAwIHx8IG5leHRSb3cgPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIG5leHRSb3cgPj0gdGhpcy5tYXBEYXRhLmxlbmd0aCB8fCBuZXh0Q29sID49IHRoaXMubWFwRGF0YVswXS5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBEYXRhW25leHRSb3ddW25leHRDb2xdID09PSAxIC8vIHdhbGxcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFggPSBuZXh0Q29sICogdGhpcy50aWxlU2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFkgPSBuZXh0Um93ICogdGhpcy50aWxlU2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbW92aW5nLCBpbnRlcnBvbGF0ZSB0b3dhcmQgdGFyZ2V0XG4gICAgICAgIGlmICh0aGlzLm1vdmluZykge1xuICAgICAgICAgICAgbGV0IGR4ID0gdGhpcy50YXJnZXRYIC0gdGhpcy54O1xuICAgICAgICAgICAgbGV0IGR5ID0gdGhpcy50YXJnZXRZIC0gdGhpcy55O1xuICAgICAgICAgICAgbGV0IGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgaWYgKGRpc3QgPD0gdGhpcy5zcGVlZCkge1xuICAgICAgICAgICAgICAgIC8vIFNuYXAgdG8gdGFyZ2V0XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy50YXJnZXRYO1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMudGFyZ2V0WTtcbiAgICAgICAgICAgICAgICBsZXQgW2RDb2wsIGRSb3ddID0gUGxheWVyRW50aXR5LmRpcmVjdGlvbkRlbHRhKHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbCArPSBkQ29sO1xuICAgICAgICAgICAgICAgIHRoaXMucm93ICs9IGRSb3c7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0b3dhcmQgdGFyZ2V0XG4gICAgICAgICAgICAgICAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuICAgICAgICAgICAgICAgIHRoaXMueCArPSB0aGlzLnNwZWVkICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMueSArPSB0aGlzLnNwZWVkICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0U3VwZXJTdGF0ZShpc1N1cGVyKSB7XG4gICAgICAgIGlmIChpc1N1cGVyKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3N1cGVyJztcbiAgICAgICAgICAgIHRoaXMuc3BlZWQgPSB0aGlzLnN1cGVyU3BlZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ25vcm1hbCc7XG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gdGhpcy5kZWZhdWx0U3BlZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVdGlsaXR5OiBkaXJlY3Rpb24gc3RyaW5nIHRvIGRlbHRhXG4gICAgc3RhdGljIGRpcmVjdGlvbkRlbHRhKGRpcikge1xuICAgICAgICBzd2l0Y2goZGlyKSB7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzogcmV0dXJuIFstMSwgMF07XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6IHJldHVybiBbMSwgMF07XG4gICAgICAgICAgICBjYXNlICd1cCc6IHJldHVybiBbMCwgLTFdO1xuICAgICAgICAgICAgY2FzZSAnZG93bic6IHJldHVybiBbMCwgMV07XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gWzAsIDBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIGNvbGxpc2lvbiB3aXRoIGdob3N0cyBvciBkb3RzXG4gICAgaXNBdChjb2wsIHJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2wgPT09IGNvbCAmJiB0aGlzLnJvdyA9PT0gcm93O1xuICAgIH1cblxuICAgIC8vIFJlbmRlciBQbGF5ZXIgKHNpbXBsZSB5ZWxsb3cgY2lyY2xlIGZvciBub3cpXG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBsZXQgc2NhbGUgPSAodGhpcy5zdGF0ZSA9PT0gJ3N1cGVyJykgPyAxLjIgOiAxO1xuICAgICAgICBsZXQgY2VudGVyWCA9IHRoaXMueCArIHRoaXMudGlsZVNpemUgLyAyO1xuICAgICAgICBsZXQgY2VudGVyWSA9IHRoaXMueSArIHRoaXMudGlsZVNpemUgLyAyO1xuICAgICAgICBjdHgudHJhbnNsYXRlKGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICBjdHguc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY2VudGVyWCwgLWNlbnRlclkpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNGRkZGMDAnO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5hcmMoY2VudGVyWCwgY2VudGVyWSwgdGhpcy50aWxlU2l6ZSAvIDIgLSAyLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIlBsYXllckVudGl0eSIsInN0YXJ0Q29sIiwic3RhcnRSb3ciLCJ0aWxlU2l6ZSIsIm1hcERhdGEiLCJzZXR0aW5ncyIsInNwZWVkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiX2NsYXNzQ2FsbENoZWNrIiwiY29sIiwicm93IiwiZGlyZWN0aW9uIiwibmV4dERpcmVjdGlvbiIsInN0YXRlIiwiZGVmYXVsdFNwZWVkIiwicGxheWVyU3BlZWQiLCJzdXBlclNwZWVkIiwicGxheWVyU3VwZXJTcGVlZCIsIngiLCJ5IiwidGFyZ2V0WCIsInRhcmdldFkiLCJtb3ZpbmciLCJ0eXBlIiwiX2NyZWF0ZUNsYXNzIiwia2V5IiwidmFsdWUiLCJzZXREaXJlY3Rpb24iLCJkaXIiLCJjYW5Nb3ZlIiwiX1BsYXllckVudGl0eSRkaXJlY3RpIiwiZGlyZWN0aW9uRGVsdGEiLCJfUGxheWVyRW50aXR5JGRpcmVjdGkyIiwiX3NsaWNlZFRvQXJyYXkiLCJkQ29sIiwiZFJvdyIsIm5Db2wiLCJuUm93IiwibmV4dFRpbGUiLCJtb3ZlIiwiX1BsYXllckVudGl0eSRkaXJlY3RpMyIsIl9QbGF5ZXJFbnRpdHkkZGlyZWN0aTQiLCJuZXh0Q29sIiwibmV4dFJvdyIsImR4IiwiZHkiLCJkaXN0IiwiTWF0aCIsInNxcnQiLCJfUGxheWVyRW50aXR5JGRpcmVjdGk1IiwiX1BsYXllckVudGl0eSRkaXJlY3RpNiIsImFuZ2xlIiwiYXRhbjIiLCJjb3MiLCJzaW4iLCJzZXRTdXBlclN0YXRlIiwiaXNTdXBlciIsImlzQXQiLCJyZW5kZXIiLCJjdHgiLCJzYXZlIiwic2NhbGUiLCJjZW50ZXJYIiwiY2VudGVyWSIsInRyYW5zbGF0ZSIsImZpbGxTdHlsZSIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiZmlsbCIsInJlc3RvcmUiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/assets/js/player-entity.js\n\n}");

/***/ }),

/***/ "./resources/assets/js/settings.js":
/*!*****************************************!*\
  !*** ./resources/assets/js/settings.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// Modern ES6 settings module for laraconman Pac-Man clone\n// Export a plain object with all settings, no globals or sessionStorage side-effects\n\nvar settings = {\n  score: 0,\n  lives: 3,\n  level: 1,\n  moveInc: 2,\n  // must divide 10 evenly: 1,2,5,10\n  speed: 10,\n  // see comments in legacy for tuning\n  gameTime: 10000,\n  // ms\n  mazeSource: 'designed',\n  basicVision: false,\n  resetModeOnResetGame: true,\n  excludeReverseDirectionInRandomMode: true,\n  fx: true,\n  extras: false,\n  ghostPenTimeout: 2,\n  // seconds ghosts wait in pen before forced exit (change as needed)\n  megaPelletDuration: 5,\n  // seconds Pac-Man stays enhanced after mega pellet\n  maxGhosts: 6,\n  // maximum number of ghosts in play\n  playerSpeed: 2,\n  // normal speed\n  playerSize: 24,\n  // normal size (px)\n  playerSuperSpeed: 4,\n  // speed during super state\n  playerSuperSize: 32,\n  // size during super state (px)\n  dotPoints: 10,\n  superDotPoints: 50,\n  fruitTypes: [{\n    type: 'cherry',\n    points: 100,\n    image: '/vendor/laraconman/images/fruit-cherry.svg'\n  }, {\n    type: 'strawberry',\n    points: 300,\n    image: '/vendor/laraconman/images/fruit-strawberry.svg'\n  }, {\n    type: 'orange',\n    points: 500,\n    image: '/vendor/laraconman/images/fruit-orange.svg'\n  }, {\n    type: 'apple',\n    points: 700,\n    image: '/vendor/laraconman/images/fruit-apple.svg'\n  }\n  // Add more as desired\n  ]\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (settings);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3NldHRpbmdzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBOztBQUVBLElBQU1BLFFBQVEsR0FBRztFQUNmQyxLQUFLLEVBQUUsQ0FBQztFQUNSQyxLQUFLLEVBQUUsQ0FBQztFQUNSQyxLQUFLLEVBQUUsQ0FBQztFQUNSQyxPQUFPLEVBQUUsQ0FBQztFQUFFO0VBQ1pDLEtBQUssRUFBRSxFQUFFO0VBQUU7RUFDWEMsUUFBUSxFQUFFLEtBQUs7RUFBRTtFQUNqQkMsVUFBVSxFQUFFLFVBQVU7RUFDdEJDLFdBQVcsRUFBRSxLQUFLO0VBQ2xCQyxvQkFBb0IsRUFBRSxJQUFJO0VBQzFCQyxtQ0FBbUMsRUFBRSxJQUFJO0VBQ3pDQyxFQUFFLEVBQUUsSUFBSTtFQUNSQyxNQUFNLEVBQUUsS0FBSztFQUNiQyxlQUFlLEVBQUUsQ0FBQztFQUFFO0VBQ3BCQyxrQkFBa0IsRUFBRSxDQUFDO0VBQUU7RUFDdkJDLFNBQVMsRUFBRSxDQUFDO0VBQUU7RUFDZEMsV0FBVyxFQUFFLENBQUM7RUFBRTtFQUNoQkMsVUFBVSxFQUFFLEVBQUU7RUFBRTtFQUNoQkMsZ0JBQWdCLEVBQUUsQ0FBQztFQUFFO0VBQ3JCQyxlQUFlLEVBQUUsRUFBRTtFQUFFO0VBQ3JCQyxTQUFTLEVBQUUsRUFBRTtFQUNiQyxjQUFjLEVBQUUsRUFBRTtFQUNsQkMsVUFBVSxFQUFFLENBQ1Y7SUFBRUMsSUFBSSxFQUFFLFFBQVE7SUFBRUMsTUFBTSxFQUFFLEdBQUc7SUFBRUMsS0FBSyxFQUFFO0VBQTZDLENBQUMsRUFDcEY7SUFBRUYsSUFBSSxFQUFFLFlBQVk7SUFBRUMsTUFBTSxFQUFFLEdBQUc7SUFBRUMsS0FBSyxFQUFFO0VBQWlELENBQUMsRUFDNUY7SUFBRUYsSUFBSSxFQUFFLFFBQVE7SUFBRUMsTUFBTSxFQUFFLEdBQUc7SUFBRUMsS0FBSyxFQUFFO0VBQTZDLENBQUMsRUFDcEY7SUFBRUYsSUFBSSxFQUFFLE9BQU87SUFBRUMsTUFBTSxFQUFFLEdBQUc7SUFBRUMsS0FBSyxFQUFFO0VBQTRDO0VBQ2pGO0VBQUE7QUFFSixDQUFDO0FBRUQsaUVBQWV6QixRQUFRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYWNvbm1hbi8uL3Jlc291cmNlcy9hc3NldHMvanMvc2V0dGluZ3MuanM/Mzc3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNb2Rlcm4gRVM2IHNldHRpbmdzIG1vZHVsZSBmb3IgbGFyYWNvbm1hbiBQYWMtTWFuIGNsb25lXG4vLyBFeHBvcnQgYSBwbGFpbiBvYmplY3Qgd2l0aCBhbGwgc2V0dGluZ3MsIG5vIGdsb2JhbHMgb3Igc2Vzc2lvblN0b3JhZ2Ugc2lkZS1lZmZlY3RzXG5cbmNvbnN0IHNldHRpbmdzID0ge1xuICBzY29yZTogMCxcbiAgbGl2ZXM6IDMsXG4gIGxldmVsOiAxLFxuICBtb3ZlSW5jOiAyLCAvLyBtdXN0IGRpdmlkZSAxMCBldmVubHk6IDEsMiw1LDEwXG4gIHNwZWVkOiAxMCwgLy8gc2VlIGNvbW1lbnRzIGluIGxlZ2FjeSBmb3IgdHVuaW5nXG4gIGdhbWVUaW1lOiAxMDAwMCwgLy8gbXNcbiAgbWF6ZVNvdXJjZTogJ2Rlc2lnbmVkJyxcbiAgYmFzaWNWaXNpb246IGZhbHNlLFxuICByZXNldE1vZGVPblJlc2V0R2FtZTogdHJ1ZSxcbiAgZXhjbHVkZVJldmVyc2VEaXJlY3Rpb25JblJhbmRvbU1vZGU6IHRydWUsXG4gIGZ4OiB0cnVlLFxuICBleHRyYXM6IGZhbHNlLFxuICBnaG9zdFBlblRpbWVvdXQ6IDIsIC8vIHNlY29uZHMgZ2hvc3RzIHdhaXQgaW4gcGVuIGJlZm9yZSBmb3JjZWQgZXhpdCAoY2hhbmdlIGFzIG5lZWRlZClcbiAgbWVnYVBlbGxldER1cmF0aW9uOiA1LCAvLyBzZWNvbmRzIFBhYy1NYW4gc3RheXMgZW5oYW5jZWQgYWZ0ZXIgbWVnYSBwZWxsZXRcbiAgbWF4R2hvc3RzOiA2LCAvLyBtYXhpbXVtIG51bWJlciBvZiBnaG9zdHMgaW4gcGxheVxuICBwbGF5ZXJTcGVlZDogMiwgLy8gbm9ybWFsIHNwZWVkXG4gIHBsYXllclNpemU6IDI0LCAvLyBub3JtYWwgc2l6ZSAocHgpXG4gIHBsYXllclN1cGVyU3BlZWQ6IDQsIC8vIHNwZWVkIGR1cmluZyBzdXBlciBzdGF0ZVxuICBwbGF5ZXJTdXBlclNpemU6IDMyLCAvLyBzaXplIGR1cmluZyBzdXBlciBzdGF0ZSAocHgpXG4gIGRvdFBvaW50czogMTAsXG4gIHN1cGVyRG90UG9pbnRzOiA1MCxcbiAgZnJ1aXRUeXBlczogW1xuICAgIHsgdHlwZTogJ2NoZXJyeScsIHBvaW50czogMTAwLCBpbWFnZTogJy92ZW5kb3IvbGFyYWNvbm1hbi9pbWFnZXMvZnJ1aXQtY2hlcnJ5LnN2ZycgfSxcbiAgICB7IHR5cGU6ICdzdHJhd2JlcnJ5JywgcG9pbnRzOiAzMDAsIGltYWdlOiAnL3ZlbmRvci9sYXJhY29ubWFuL2ltYWdlcy9mcnVpdC1zdHJhd2JlcnJ5LnN2ZycgfSxcbiAgICB7IHR5cGU6ICdvcmFuZ2UnLCBwb2ludHM6IDUwMCwgaW1hZ2U6ICcvdmVuZG9yL2xhcmFjb25tYW4vaW1hZ2VzL2ZydWl0LW9yYW5nZS5zdmcnIH0sXG4gICAgeyB0eXBlOiAnYXBwbGUnLCBwb2ludHM6IDcwMCwgaW1hZ2U6ICcvdmVuZG9yL2xhcmFjb25tYW4vaW1hZ2VzL2ZydWl0LWFwcGxlLnN2ZycgfSxcbiAgICAvLyBBZGQgbW9yZSBhcyBkZXNpcmVkXG4gIF0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzZXR0aW5nczsiXSwibmFtZXMiOlsic2V0dGluZ3MiLCJzY29yZSIsImxpdmVzIiwibGV2ZWwiLCJtb3ZlSW5jIiwic3BlZWQiLCJnYW1lVGltZSIsIm1hemVTb3VyY2UiLCJiYXNpY1Zpc2lvbiIsInJlc2V0TW9kZU9uUmVzZXRHYW1lIiwiZXhjbHVkZVJldmVyc2VEaXJlY3Rpb25JblJhbmRvbU1vZGUiLCJmeCIsImV4dHJhcyIsImdob3N0UGVuVGltZW91dCIsIm1lZ2FQZWxsZXREdXJhdGlvbiIsIm1heEdob3N0cyIsInBsYXllclNwZWVkIiwicGxheWVyU2l6ZSIsInBsYXllclN1cGVyU3BlZWQiLCJwbGF5ZXJTdXBlclNpemUiLCJkb3RQb2ludHMiLCJzdXBlckRvdFBvaW50cyIsImZydWl0VHlwZXMiLCJ0eXBlIiwicG9pbnRzIiwiaW1hZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/assets/js/settings.js\n\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/laraconman": 0,
/******/ 			"css/laraconman": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunklaraconman"] = self["webpackChunklaraconman"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/laraconman"], () => (__webpack_require__("./resources/assets/js/game.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/laraconman"], () => (__webpack_require__("./resources/assets/css/game.css")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;