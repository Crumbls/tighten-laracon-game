{"version":3,"file":"/js/laraconman.js","mappings":"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","sources":["webpack://laraconman/webpack/runtime/chunk loaded","webpack://laraconman/./node_modules/events/events.js","webpack://laraconman/./node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js","webpack://laraconman/./node_modules/pathfinding/src/core/Util.js","webpack://laraconman/./resources/assets/js/settings.js","webpack://laraconman/./resources/assets/js/input-handler.js","webpack://laraconman/./resources/assets/js/map-renderer.js","webpack://laraconman/./resources/assets/js/player-entity.js","webpack://laraconman/./resources/assets/js/ghost-entity.js","webpack://laraconman/./resources/assets/js/entity-art.js","webpack://laraconman/./resources/assets/js/collectible-entity.js","webpack://laraconman/./resources/assets/js/collectible-spawner.js","webpack://laraconman/./resources/assets/js/game.js","webpack://laraconman/./node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js","webpack://laraconman/./node_modules/heap/lib/heap.js","webpack://laraconman/./node_modules/pathfinding/src/finders/JumpPointFinder.js","webpack://laraconman/./node_modules/pathfinding/src/core/Node.js","webpack://laraconman/./node_modules/pathfinding/src/finders/BiAStarFinder.js","webpack://laraconman/./node_modules/pathfinding/src/finders/IDAStarFinder.js","webpack://laraconman/./node_modules/pathfinding/src/core/Heuristic.js","webpack://laraconman/./node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js","webpack://laraconman/./node_modules/pathfinding/src/finders/BestFirstFinder.js","webpack://laraconman/./node_modules/pathfinding/src/core/Grid.js","webpack://laraconman/./node_modules/pathfinding/src/finders/BiBestFirstFinder.js","webpack://laraconman/./node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js","webpack://laraconman/./node_modules/heap/index.js","webpack://laraconman/./node_modules/pathfinding/src/finders/BiDijkstraFinder.js","webpack://laraconman/./node_modules/pathfinding/src/core/DiagonalMovement.js","webpack://laraconman/./node_modules/pathfinding/src/finders/BreadthFirstFinder.js","webpack://laraconman/./node_modules/pathfinding/src/finders/JumpPointFinderBase.js","webpack://laraconman/./node_modules/pathfinding/src/PathFinding.js","webpack://laraconman/./node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js","webpack://laraconman/./node_modules/pathfinding/src/finders/AStarFinder.js","webpack://laraconman/./node_modules/pathfinding/src/finders/DijkstraFinder.js","webpack://laraconman/./node_modules/pathfinding/index.js","webpack://laraconman/webpack/bootstrap","webpack://laraconman/webpack/runtime/compat get default export","webpack://laraconman/webpack/runtime/define property getters","webpack://laraconman/webpack/runtime/hasOwnProperty shorthand","webpack://laraconman/webpack/runtime/node module decorator","webpack://laraconman/webpack/runtime/jsonp chunk loading","webpack://laraconman/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm allowing only horizontal\r\n * or vertical movements.\r\n */\r\nfunction JPFNeverMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    if (dx !== 0) {\r\n        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else if (dy !== 0) {\r\n        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        //When moving vertically, must check for horizontal jump points\r\n        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(\"Only horizontal and vertical movements are allowed\");\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        if (dx !== 0) {\r\n            if (grid.isWalkableAt(x, y - 1)) {\r\n                neighbors.push([x, y - 1]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + 1)) {\r\n                neighbors.push([x, y + 1]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if (grid.isWalkableAt(x - 1, y)) {\r\n                neighbors.push([x - 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + 1, y)) {\r\n                neighbors.push([x + 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFNeverMoveDiagonally;\r\n","/**\r\n * Backtrace according to the parent records and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node} node End node\r\n * @return {Array<Array<number>>} the path\r\n */\r\nfunction backtrace(node) {\r\n    var path = [[node.x, node.y]];\r\n    while (node.parent) {\r\n        node = node.parent;\r\n        path.push([node.x, node.y]);\r\n    }\r\n    return path.reverse();\r\n}\r\nexports.backtrace = backtrace;\r\n\r\n/**\r\n * Backtrace from start and end node, and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node}\r\n * @param {Node}\r\n */\r\nfunction biBacktrace(nodeA, nodeB) {\r\n    var pathA = backtrace(nodeA),\r\n        pathB = backtrace(nodeB);\r\n    return pathA.concat(pathB.reverse());\r\n}\r\nexports.biBacktrace = biBacktrace;\r\n\r\n/**\r\n * Compute the length of the path.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {number} The length of the path\r\n */\r\nfunction pathLength(path) {\r\n    var i, sum = 0, a, b, dx, dy;\r\n    for (i = 1; i < path.length; ++i) {\r\n        a = path[i - 1];\r\n        b = path[i];\r\n        dx = a[0] - b[0];\r\n        dy = a[1] - b[1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    return sum;\r\n}\r\nexports.pathLength = pathLength;\r\n\r\n\r\n/**\r\n * Given the start and end coordinates, return all the coordinates lying\r\n * on the line formed by these coordinates, based on Bresenham's algorithm.\r\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\r\n * @param {number} x0 Start x coordinate\r\n * @param {number} y0 Start y coordinate\r\n * @param {number} x1 End x coordinate\r\n * @param {number} y1 End y coordinate\r\n * @return {Array<Array<number>>} The coordinates on the line\r\n */\r\nfunction interpolate(x0, y0, x1, y1) {\r\n    var abs = Math.abs,\r\n        line = [],\r\n        sx, sy, dx, dy, err, e2;\r\n\r\n    dx = abs(x1 - x0);\r\n    dy = abs(y1 - y0);\r\n\r\n    sx = (x0 < x1) ? 1 : -1;\r\n    sy = (y0 < y1) ? 1 : -1;\r\n\r\n    err = dx - dy;\r\n\r\n    while (true) {\r\n        line.push([x0, y0]);\r\n\r\n        if (x0 === x1 && y0 === y1) {\r\n            break;\r\n        }\r\n        \r\n        e2 = 2 * err;\r\n        if (e2 > -dy) {\r\n            err = err - dy;\r\n            x0 = x0 + sx;\r\n        }\r\n        if (e2 < dx) {\r\n            err = err + dx;\r\n            y0 = y0 + sy;\r\n        }\r\n    }\r\n\r\n    return line;\r\n}\r\nexports.interpolate = interpolate;\r\n\r\n\r\n/**\r\n * Given a compressed path, return a new path that has all the segments\r\n * in it interpolated.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} expanded path\r\n */\r\nfunction expandPath(path) {\r\n    var expanded = [],\r\n        len = path.length,\r\n        coord0, coord1,\r\n        interpolated,\r\n        interpolatedLen,\r\n        i, j;\r\n\r\n    if (len < 2) {\r\n        return expanded;\r\n    }\r\n\r\n    for (i = 0; i < len - 1; ++i) {\r\n        coord0 = path[i];\r\n        coord1 = path[i + 1];\r\n\r\n        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\r\n        interpolatedLen = interpolated.length;\r\n        for (j = 0; j < interpolatedLen - 1; ++j) {\r\n            expanded.push(interpolated[j]);\r\n        }\r\n    }\r\n    expanded.push(path[len - 1]);\r\n\r\n    return expanded;\r\n}\r\nexports.expandPath = expandPath;\r\n\r\n\r\n/**\r\n * Smoothen the give path.\r\n * The original path will not be modified; a new path will be returned.\r\n * @param {PF.Grid} grid\r\n * @param {Array<Array<number>>} path The path\r\n */\r\nfunction smoothenPath(grid, path) {\r\n    var len = path.length,\r\n        x0 = path[0][0],        // path start x\r\n        y0 = path[0][1],        // path start y\r\n        x1 = path[len - 1][0],  // path end x\r\n        y1 = path[len - 1][1],  // path end y\r\n        sx, sy,                 // current start coordinate\r\n        ex, ey,                 // current end coordinate\r\n        newPath,\r\n        i, j, coord, line, testCoord, blocked;\r\n\r\n    sx = x0;\r\n    sy = y0;\r\n    newPath = [[sx, sy]];\r\n\r\n    for (i = 2; i < len; ++i) {\r\n        coord = path[i];\r\n        ex = coord[0];\r\n        ey = coord[1];\r\n        line = interpolate(sx, sy, ex, ey);\r\n\r\n        blocked = false;\r\n        for (j = 1; j < line.length; ++j) {\r\n            testCoord = line[j];\r\n\r\n            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\r\n                blocked = true;\r\n                break;\r\n            }\r\n        }\r\n        if (blocked) {\r\n            lastValidCoord = path[i - 1];\r\n            newPath.push(lastValidCoord);\r\n            sx = lastValidCoord[0];\r\n            sy = lastValidCoord[1];\r\n        }\r\n    }\r\n    newPath.push([x1, y1]);\r\n\r\n    return newPath;\r\n}\r\nexports.smoothenPath = smoothenPath;\r\n\r\n\r\n/**\r\n * Compress a path, remove redundant nodes without altering the shape\r\n * The original path is not modified\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} The compressed path\r\n */\r\nfunction compressPath(path) {\r\n\r\n    // nothing to compress\r\n    if(path.length < 3) {\r\n        return path;\r\n    }\r\n\r\n    var compressed = [],\r\n        sx = path[0][0], // start x\r\n        sy = path[0][1], // start y\r\n        px = path[1][0], // second point x\r\n        py = path[1][1], // second point y\r\n        dx = px - sx, // direction between the two points\r\n        dy = py - sy, // direction between the two points\r\n        lx, ly,\r\n        ldx, ldy,\r\n        sq, i;\r\n\r\n    // normalize the direction\r\n    sq = Math.sqrt(dx*dx + dy*dy);\r\n    dx /= sq;\r\n    dy /= sq;\r\n\r\n    // start the new path\r\n    compressed.push([sx,sy]);\r\n\r\n    for(i = 2; i < path.length; i++) {\r\n\r\n        // store the last point\r\n        lx = px;\r\n        ly = py;\r\n\r\n        // store the last direction\r\n        ldx = dx;\r\n        ldy = dy;\r\n\r\n        // next point\r\n        px = path[i][0];\r\n        py = path[i][1];\r\n\r\n        // next direction\r\n        dx = px - lx;\r\n        dy = py - ly;\r\n\r\n        // normalize\r\n        sq = Math.sqrt(dx*dx + dy*dy);\r\n        dx /= sq;\r\n        dy /= sq;\r\n\r\n        // if the direction has changed, store the point\r\n        if ( dx !== ldx || dy !== ldy ) {\r\n            compressed.push([lx,ly]);\r\n        }\r\n    }\r\n\r\n    // store the last point\r\n    compressed.push([px,py]);\r\n\r\n    return compressed;\r\n}\r\nexports.compressPath = compressPath;\r\n","// Modern ES6 settings module for laraconman Pac-Man clone\n// Export a plain object with all settings, no globals or sessionStorage side-effects\n\nconst settings = {\n  score: 0,\n  lives: 3,\n  level: 1,\n  moveInc: 2, // must divide 10 evenly: 1,2,5,10\n  speed: 10, // see comments in legacy for tuning\n  gameTime: 10000, // ms\n  mazeSource: 'designed',\n  basicVision: false,\n  resetModeOnResetGame: true,\n  excludeReverseDirectionInRandomMode: true,\n  fx: true,\n  extras: false,\n  ghostPenTimeout: 2, // seconds ghosts wait in pen before forced exit (change as needed)\n  megaPelletDuration: 5, // seconds Pac-Man stays enhanced after mega pellet\n  maxGhosts: 6, // maximum number of ghosts in play\n  playerSpeed: 2, // normal speed\n  playerSize: 24, // normal size (px)\n  playerSuperSpeed: 4, // speed during super state\n  playerSuperSize: 32, // size during super state (px)\n  dotPoints: 10,\n  superDotPoints: 50,\n  fruitTypes: [\n    { type: 'cherry', points: 100, image: '/vendor/laraconman/images/fruit-cherry.svg' },\n    { type: 'strawberry', points: 300, image: '/vendor/laraconman/images/fruit-strawberry.svg' },\n    { type: 'orange', points: 500, image: '/vendor/laraconman/images/fruit-orange.svg' },\n    { type: 'apple', points: 700, image: '/vendor/laraconman/images/fruit-apple.svg' },\n    // Add more as desired\n  ],\n};\n\nexport default settings;","// Modern ES6 InputHandler module for laraconman\nclass InputHandler {\n    constructor() {\n        this.keys = {};\n        this.currentDirection = null;\n        this.queuedDirection = null;\n\n        // Direction constants\n        this.DIRECTIONS = {\n            UP: 'up',\n            DOWN: 'down',\n            LEFT: 'left',\n            RIGHT: 'right'\n        };\n\n        // Key mapping for navigation\n        this.keyMap = {\n            'ArrowUp': this.DIRECTIONS.UP,\n            'KeyW': this.DIRECTIONS.UP,\n            'ArrowDown': this.DIRECTIONS.DOWN,\n            'KeyS': this.DIRECTIONS.DOWN,\n            'ArrowLeft': this.DIRECTIONS.LEFT,\n            'KeyA': this.DIRECTIONS.LEFT,\n            'ArrowRight': this.DIRECTIONS.RIGHT,\n            'KeyD': this.DIRECTIONS.RIGHT\n        };\n\n        this.callbacks = {\n            onDirectionChange: null,\n            onKeyPress: null, // NEW: generic key press\n            onPause: null,\n            onReset: null\n        };\n\n        this.setupEventListeners();\n    }\n\n    setCallbacks(callbacks) {\n        this.callbacks = { ...this.callbacks, ...callbacks };\n    }\n\n    getCurrentDirection() {\n        return this.currentDirection;\n    }\n\n    getQueuedDirection() {\n        return this.queuedDirection;\n    }\n\n    setupEventListeners() {\n        document.addEventListener('keydown', (e) => {\n            // Navigation keys\n            if (this.keyMap[e.code]) {\n                this.handleDirectionInput(e.code);\n            }\n            // Pause (Escape)\n            else if (e.code === 'Escape' && this.callbacks.onPause) {\n                this.callbacks.onPause();\n            }\n            // Reset (R)\n            else if ((e.code === 'KeyR' || e.code === 'F5') && this.callbacks.onReset) {\n                this.callbacks.onReset();\n            }\n            // Enter/Return\n            else if ((e.code === 'Enter' || e.code === 'NumpadEnter') && this.callbacks.onKeyPress) {\n                this.callbacks.onKeyPress('enter', e);\n            }\n            // Any other key\n            else if (this.callbacks.onKeyPress) {\n                this.callbacks.onKeyPress(e.code, e);\n            }\n        });\n    }\n\n    handleDirectionInput(code) {\n        const direction = this.keyMap[code];\n        if (direction && direction !== this.currentDirection) {\n            this.queuedDirection = direction;\n            this.currentDirection = direction;\n            if (this.callbacks.onDirectionChange) {\n                this.callbacks.onDirectionChange(direction);\n            }\n        }\n    }\n}\n\nexport default InputHandler;","class MapRenderer {\n    constructor(canvas, tileSize = 24, config = {}) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.tileSize = tileSize;\n        this.mapData = null;\n        this.rawMapData = null; // Store the original map data before border enforcement\n        this.width = 0;\n        this.height = 0;\n        \n        // Tile type constants (matching your factory)\n        this.TILES = {\n            WALL: 1,\n            DOT: 2, \n            GHOST_DOOR: 3,\n            TUNNEL: 4,\n            EMPTY: 0,\n            CORNER: 6,\n            GHOST_SPAWN: 7,\n            PORTAL: 8,\n            SUPER_DOT: 9\n        };\n        \n        // Colors for different tile types\n        this.colors = {\n            wall: '#0031FF', // Pac-Man blue\n            dot: '#FFFFB8', // Pac-Man dot yellow\n            ghostDoor: '#FF69B4',\n            tunnel: '#000000', // tunnel is background color\n            background: '#000000',\n            path: '#000080',\n            corner: '#FF0000',\n            ghostSpawn: '#00FF00',\n            portal: '#0000FF',\n            superDot: '#FFFF00'\n        };\n        this.applyConfig(config);\n    }\n    \n    /**\n     * Accepts a config object to override colors.\n     * @param {object} config - Optional config object with color overrides\n     */\n    applyConfig(config = {}) {\n        if (config.colors) {\n            this.colors = { ...this.colors, ...config.colors };\n        }\n    }\n    \n    /**\n     * Load map data from CSV string format\n     * @param {string} csvData - CSV formatted map data\n     * @param {number} width - Map width in tiles\n     * @param {number} height - Map height in tiles\n     */\n    loadMap(csvData, width, height) {\n        this.width = width + 2;\n        this.height = height + 2;\n        const rows = csvData.trim().split('\\n');\n        const raw = rows.map(row => row.split(',').map(cell => this.mapTileCode(parseInt(cell.trim(), 10))));\n        // Find portal columns/rows on edges\n        const portalColsTop = [];\n        const portalColsBottom = [];\n        const portalRowsLeft = [];\n        const portalRowsRight = [];\n        for (let c = 0; c < width; c++) {\n            if (raw[0][c] === this.TILES.PORTAL) portalColsTop.push(c);\n            if (raw[height-1][c] === this.TILES.PORTAL) portalColsBottom.push(c);\n        }\n        for (let r = 0; r < height; r++) {\n            if (raw[r][0] === this.TILES.PORTAL) portalRowsLeft.push(r);\n            if (raw[r][width-1] === this.TILES.PORTAL) portalRowsRight.push(r);\n        }\n        // Build bordered map\n        this.mapData = [];\n        // Top border\n        const topRow = [];\n        for (let c = 0; c < width + 2; c++) {\n            if (c > 0 && c < width + 1 && portalColsTop.includes(c-1)) topRow.push(this.TILES.EMPTY);\n            else topRow.push(this.TILES.WALL);\n        }\n        this.mapData.push(topRow);\n        // Middle rows\n        for (let r = 0; r < height; r++) {\n            const row = [];\n            // Left border\n            if (portalRowsLeft.includes(r)) row.push(this.TILES.EMPTY);\n            else row.push(this.TILES.WALL);\n            // Original row\n            for (let c = 0; c < width; c++) row.push(raw[r][c]);\n            // Right border\n            if (portalRowsRight.includes(r)) row.push(this.TILES.EMPTY);\n            else row.push(this.TILES.WALL);\n            this.mapData.push(row);\n        }\n        // Bottom border\n        const bottomRow = [];\n        for (let c = 0; c < width + 2; c++) {\n            if (c > 0 && c < width + 1 && portalColsBottom.includes(c-1)) bottomRow.push(this.TILES.EMPTY);\n            else bottomRow.push(this.TILES.WALL);\n        }\n        this.mapData.push(bottomRow);\n        this.canvas.width = this.width * this.tileSize;\n        this.canvas.height = this.height * this.tileSize;\n        console.log(`Map loaded with border: ${this.width}x${this.height}`, this.mapData);\n    }\n    \n    /**\n     * Map legacy/demo tile codes to internal tile types\n     * @param {number} code - raw tile code from CSV\n     * @returns {number} mapped tile code\n     */\n    mapTileCode(code) {\n        // Tile code meanings:\n        // 0 = wall, 1 = empty/path, 2 = super dot (corners), 3 = ghost spawn, 4 = portal, 5 = ghost door\n        switch(code) {\n            case 0:\n                return this.TILES.WALL;\n            case 1:\n                return this.TILES.EMPTY;\n            case 2:\n                return this.TILES.SUPER_DOT;\n            case 3:\n                return this.TILES.GHOST_SPAWN;\n            case 4:\n                return this.TILES.PORTAL;\n            case 5:\n                return this.TILES.GHOST_DOOR;\n            default:\n                return this.TILES.EMPTY;\n        }\n    }\n    \n    /**\n     * Ensure there is always a border of walls around the map,\n     * except for tunnel/portal tiles (TUNNEL) at the border.\n     * This modifies mapData in-place after loading.\n     */\n    ensureWallBorder() {\n        if (!this.mapData) return;\n        const h = this.mapData.length;\n        const w = this.mapData[0].length;\n        for (let r = 0; r < h; r++) {\n            for (let c = 0; c < w; c++) {\n                const isEdge = (r === 0 || r === h-1 || c === 0 || c === w-1);\n                if (isEdge) {\n                    // If this is a tunnel/portal, preserve it\n                    if (this.mapData[r][c] === this.TILES.TUNNEL) continue;\n                    // Otherwise, enforce wall\n                    this.mapData[r][c] = this.TILES.WALL;\n                }\n            }\n        }\n    }\n    \n    /**\n     * Render the entire map to canvas\n     */\n    render() {\n        if (!this.mapData) {\n            console.error('No map data loaded');\n            return;\n        }\n        \n        // Clear canvas\n        this.ctx.fillStyle = this.colors.background;\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        // Render each tile\n        for (let row = 0; row < this.height; row++) {\n            for (let col = 0; col < this.width; col++) {\n                const tileType = this.mapData[row][col];\n                this.renderTile(col, row, tileType);\n            }\n        }\n    }\n    \n    /**\n     * Render a single tile at the specified position\n     * @param {number} col - Column position\n     * @param {number} row - Row position  \n     * @param {number} tileType - Type of tile to render\n     */\n    renderTile(col, row, tileType) {\n        const x = col * this.tileSize;\n        const y = row * this.tileSize;\n\n        // If this is a wall at the border and the *original* tile was a tunnel, skip rendering (transparent)\n        const isEdge = (row === 0 || row === this.height-1 || col === 0 || col === this.width-1);\n        // Use the raw map data (before wall border enforcement) to check for tunnel\n        if (tileType === this.TILES.WALL && isEdge && this.rawMapData && this.rawMapData[row][col] === this.TILES.TUNNEL) {\n            return; // Don't render wall at tunnel/portal\n        }\n        if (tileType === this.TILES.WALL) {\n            this.renderWall(x, y);\n        } else switch(tileType) {\n            case this.TILES.DOT:\n                this.renderPath(x, y);\n                this.renderDot(x, y);\n                break;\n            case this.TILES.GHOST_DOOR:\n                this.renderPath(x, y);\n                this.renderGhostDoor(x, y);\n                break;\n            case this.TILES.TUNNEL:\n                this.renderPath(x, y);\n                break;\n            case this.TILES.CORNER:\n                this.renderPath(x, y);\n                this.renderCorner(x, y);\n                break;\n            case this.TILES.GHOST_SPAWN:\n                this.renderPath(x, y);\n                this.renderGhostSpawn(x, y);\n                break;\n            case this.TILES.PORTAL:\n                this.renderPath(x, y);\n                this.renderPortal(x, y);\n                break;\n            case this.TILES.SUPER_DOT:\n                this.renderPath(x, y);\n                this.renderSuperDot(x, y);\n                break;\n            default:\n                this.renderPath(x, y);\n        }\n    }\n    \n    /**\n     * Render a wall tile\n     */\n    renderWall(x, y) {\n        this.ctx.fillStyle = this.colors.wall;\n        this.ctx.fillRect(x, y, this.tileSize, this.tileSize);\n        \n        // Add wall border for definition\n        this.ctx.strokeStyle = '#4444FF';\n        this.ctx.lineWidth = 1;\n        this.ctx.strokeRect(x, y, this.tileSize, this.tileSize);\n    }\n    \n    /**\n     * Render a path/corridor background\n     */\n    renderPath(x, y) {\n        this.ctx.fillStyle = this.colors.path;\n        this.ctx.fillRect(x, y, this.tileSize, this.tileSize);\n    }\n    \n    /**\n     * Render a dot (pellet)\n     */\n    renderDot(x, y) {\n        const centerX = x + this.tileSize / 2;\n        const centerY = y + this.tileSize / 2;\n        const radius = Math.max(2, this.tileSize / 8);\n        \n        this.ctx.fillStyle = this.colors.dot;\n        this.ctx.beginPath();\n        this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n        this.ctx.fill();\n    }\n    \n    /**\n     * Render a ghost door (special gate)\n     */\n    renderGhostDoor(x, y) {\n        // Horizontal line across the middle\n        this.ctx.strokeStyle = this.colors.ghostDoor;\n        this.ctx.lineWidth = 3;\n        this.ctx.beginPath();\n        this.ctx.moveTo(x, y + this.tileSize / 2);\n        this.ctx.lineTo(x + this.tileSize, y + this.tileSize / 2);\n        this.ctx.stroke();\n    }\n    \n    /**\n     * Render a tunnel entrance\n     */\n    renderTunnel(x, y) {\n        this.ctx.fillStyle = this.colors.tunnel;\n        this.ctx.fillRect(x, y, this.tileSize, this.tileSize);\n        \n        // Add some tunnel indicators\n        this.ctx.fillStyle = '#008888';\n        this.ctx.fillRect(x + 2, y + 2, this.tileSize - 4, this.tileSize - 4);\n    }\n    \n    /**\n     * Render a corner\n     */\n    renderCorner(x, y) {\n        this.ctx.fillStyle = this.colors.corner;\n        this.ctx.fillRect(x, y, this.tileSize, this.tileSize);\n    }\n    \n    /**\n     * Render a ghost spawn\n     */\n    renderGhostSpawn(x, y) {\n        this.ctx.fillStyle = this.colors.ghostSpawn;\n        this.ctx.fillRect(x, y, this.tileSize, this.tileSize);\n    }\n    \n    /**\n     * Render a portal\n     */\n    renderPortal(x, y) {\n        this.ctx.fillStyle = this.colors.portal;\n        this.ctx.fillRect(x, y, this.tileSize, this.tileSize);\n    }\n    \n    /**\n     * Render a super dot\n     */\n    renderSuperDot(x, y) {\n        const centerX = x + this.tileSize / 2;\n        const centerY = y + this.tileSize / 2;\n        const radius = Math.max(4, this.tileSize / 4);\n        \n        this.ctx.fillStyle = this.colors.superDot;\n        this.ctx.beginPath();\n        this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n        this.ctx.fill();\n    }\n    \n    /**\n     * Get tile type at world coordinates\n     * @param {number} worldX - X coordinate in pixels\n     * @param {number} worldY - Y coordinate in pixels\n     * @returns {number} Tile type\n     */\n    getTileAt(worldX, worldY) {\n        const col = Math.floor(worldX / this.tileSize);\n        const row = Math.floor(worldY / this.tileSize);\n        \n        if (row < 0 || row >= this.height || col < 0 || col >= this.width) {\n            return this.TILES.WALL; // Treat out-of-bounds as walls\n        }\n        \n        return this.mapData[row][col];\n    }\n    \n    /**\n     * Convert grid coordinates to world coordinates\n     * @param {number} col - Column\n     * @param {number} row - Row\n     * @returns {object} World coordinates {x, y}\n     */\n    gridToWorld(col, row) {\n        return {\n            x: col * this.tileSize + this.tileSize / 2,\n            y: row * this.tileSize + this.tileSize / 2\n        };\n    }\n    \n    /**\n     * Convert world coordinates to grid coordinates\n     * @param {number} worldX - World X coordinate\n     * @param {number} worldY - World Y coordinate\n     * @returns {object} Grid coordinates {col, row}\n     */\n    worldToGrid(worldX, worldY) {\n        return {\n            col: Math.floor(worldX / this.tileSize),\n            row: Math.floor(worldY / this.tileSize)\n        };\n    }\n    \n    /**\n     * Find all tiles of a specific type\n     * @param {number} tileType - Type to search for\n     * @returns {Array} Array of {col, row} positions\n     */\n    findTiles(tileType) {\n        const positions = [];\n        \n        for (let row = 0; row < this.height; row++) {\n            for (let col = 0; col < this.width; col++) {\n                if (this.mapData[row][col] === tileType) {\n                    positions.push({col, row});\n                }\n            }\n        }\n        \n        return positions;\n    }\n    \n    /**\n     * Check if a position is walkable (not a wall)\n     * @param {number} col - Column\n     * @param {number} row - Row\n     * @returns {boolean} True if walkable\n     */\n    isWalkable(col, row) {\n        if (row < 0 || row >= this.height || col < 0 || col >= this.width) {\n            return false;\n        }\n        \n        return this.mapData[row][col] !== this.TILES.WALL;\n    }\n}\n\nexport default MapRenderer;","// player-entity.js\n// KISS: minimal, extensible player entity for movement/collision, future-proof for ghosts\n\nexport default class PlayerEntity {\n    constructor(startCol, startRow, tileSize, mapData, settings, speed = 4) {\n        this.col = startCol;\n        this.row = startRow;\n        this.tileSize = tileSize;\n        this.mapData = mapData; // reference to current map\n        this.direction = null; // default: no movement until input\n        this.nextDirection = null;\n        this.state = 'normal'; // 'normal' or 'super'\n        this.defaultSpeed = settings.playerSpeed || 2;\n        this.superSpeed = settings.playerSuperSpeed || 4;\n        this.speed = this.defaultSpeed;\n        // tileSize is fixed for logic; visual scale only\n        this.x = this.col * this.tileSize;\n        this.y = this.row * this.tileSize;\n        this.targetX = this.x;\n        this.targetY = this.y;\n        this.moving = false;\n    }\n\n    setDirection(dir) {\n        this.nextDirection = dir;\n    }\n\n    // Check if a direction is walkable (not a wall)\n    canMove(dir) {\n        let [dCol, dRow] = PlayerEntity.directionDelta(dir);\n        let nCol = this.col + dCol;\n        let nRow = this.row + dRow;\n        if (\n            nCol < 0 || nRow < 0 ||\n            nRow >= this.mapData.length || nCol >= this.mapData[0].length\n        ) return false;\n        return this.mapData[nRow][nCol] !== 1; // 1 = wall\n    }\n\n    // Move one step if possible, handle direction changes\n    move() {\n        // If not moving, check for direction and set target\n        if (!this.moving) {\n            if (this.nextDirection && this.canMove(this.nextDirection)) {\n                this.direction = this.nextDirection;\n                this.nextDirection = null;\n            }\n            if (this.canMove(this.direction)) {\n                let [dCol, dRow] = PlayerEntity.directionDelta(this.direction);\n                // Prevent moving out of bounds\n                let nextCol = this.col + dCol;\n                let nextRow = this.row + dRow;\n                if (\n                    nextCol < 0 || nextRow < 0 ||\n                    nextRow >= this.mapData.length || nextCol >= this.mapData[0].length ||\n                    this.mapData[nextRow][nextCol] === 1 // wall\n                ) {\n                    this.moving = false;\n                    return;\n                }\n                this.targetX = nextCol * this.tileSize;\n                this.targetY = nextRow * this.tileSize;\n                this.moving = true;\n            }\n        }\n        // If moving, interpolate toward target\n        if (this.moving) {\n            let dx = this.targetX - this.x;\n            let dy = this.targetY - this.y;\n            let dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist <= this.speed) {\n                // Snap to target\n                this.x = this.targetX;\n                this.y = this.targetY;\n                let [dCol, dRow] = PlayerEntity.directionDelta(this.direction);\n                this.col += dCol;\n                this.row += dRow;\n                this.moving = false;\n            } else {\n                // Move toward target\n                let angle = Math.atan2(dy, dx);\n                this.x += this.speed * Math.cos(angle);\n                this.y += this.speed * Math.sin(angle);\n            }\n        }\n    }\n\n    setSuperState(isSuper) {\n        if (isSuper) {\n            this.state = 'super';\n            this.speed = this.superSpeed;\n        } else {\n            this.state = 'normal';\n            this.speed = this.defaultSpeed;\n        }\n    }\n\n    // Utility: direction string to delta\n    static directionDelta(dir) {\n        switch(dir) {\n            case 'left': return [-1, 0];\n            case 'right': return [1, 0];\n            case 'up': return [0, -1];\n            case 'down': return [0, 1];\n            default: return [0, 0];\n        }\n    }\n\n    // For collision with ghosts or dots\n    isAt(col, row) {\n        return this.col === col && this.row === row;\n    }\n\n    // Render Player (simple yellow circle for now)\n    render(ctx) {\n        ctx.save();\n        let scale = (this.state === 'super') ? 1.2 : 1;\n        let centerX = this.x + this.tileSize / 2;\n        let centerY = this.y + this.tileSize / 2;\n        ctx.translate(centerX, centerY);\n        ctx.scale(scale, scale);\n        ctx.translate(-centerX, -centerY);\n        ctx.fillStyle = '#FFFF00';\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, this.tileSize / 2 - 2, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.restore();\n    }\n}\n","// ghost-entity.js\n// Minimal, extensible GhostEntity class for movement, collision, and future pathfinding\n\nimport PF from 'pathfinding';\n\nexport default class GhostEntity {\n    constructor(startCol, startRow, tileSize, mapData, speed = 2, color = '#FF0000', tiles = null, image = null) {\n        this.col = startCol;\n        this.row = startRow;\n        this.tileSize = tileSize;\n        this.mapData = mapData; // reference to current map\n        this.direction = 'left'; // default\n        this.nextDirection = null;\n        this.speed = speed;\n        this.x = this.col * tileSize;\n        this.y = this.row * tileSize;\n        this.targetX = this.x;\n        this.targetY = this.y;\n        this.moving = false;\n        this.color = color;\n        this.image = image;\n        this.state = 'in_pen'; // 'in_pen', 'exiting', 'active'\n        this.exitTarget = null;\n        this.destination = null;\n        this.path = null;\n        this.pathStep = 0;\n        this.TILES = tiles;\n        this.lastPosition = null; // Track previous tile\n    }\n\n    setState(state, exitTarget = null) {\n        this.state = state;\n        this.exitTarget = exitTarget;\n        // When entering 'exiting', clear previous destination if just left pen\n        if(state === 'exiting' && this.destination && this.state !== 'exiting') {\n            this.destination = null;\n            this.path = null;\n            this.pathStep = 0;\n        }\n    }\n\n    setDirection(dir) {\n        this.nextDirection = dir;\n    }\n\n    canMove(dir) {\n        let [dCol, dRow] = GhostEntity.directionDelta(dir);\n        let nCol = this.col + dCol;\n        let nRow = this.row + dRow;\n        if (\n            nCol < 0 || nRow < 0 ||\n            nRow >= this.mapData.length || nCol >= this.mapData[0].length\n        ) return false;\n        // Allow movement on walkable tiles always if not in_pen\n\n        if (this.state === 'exiting') {\n\n//            return walkable.some(Boolean);\n        }\n\n        if (this.state === 'exiting' || this.state === 'active') {\n            const walkable = [\n                this.mapData[nRow][nCol] === this.TILES.EMPTY,\n                this.mapData[nRow][nCol] === this.TILES.DOT,\n                this.mapData[nRow][nCol] === this.TILES.SUPER_DOT,\n                this.mapData[nRow][nCol] === this.TILES.GHOST_DOOR,\n                this.mapData[nRow][nCol] === this.TILES.GHOST_SPAWN\n            ];\n            return walkable.some(Boolean);\n        }\n        // If in_pen, only allow movement inside pen (GHOST_SPAWN)\n        return this.mapData[nRow][nCol] === this.TILES.GHOST_SPAWN;\n    }\n\n    move() {\n        if (!this.moving) {\n            if (this.nextDirection && this.canMove(this.nextDirection)) {\n                this.direction = this.nextDirection;\n                this.nextDirection = null;\n            }\n            if (this.canMove(this.direction)) {\n                let [dCol, dRow] = GhostEntity.directionDelta(this.direction);\n                this.targetX = (this.col + dCol) * this.tileSize;\n                this.targetY = (this.row + dRow) * this.tileSize;\n                this.moving = true;\n            }\n        }\n        if (this.moving) {\n            let dx = this.targetX - this.x;\n            let dy = this.targetY - this.y;\n            let dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist <= this.speed) {\n                this.x = this.targetX;\n                this.y = this.targetY;\n                let [dCol, dRow] = GhostEntity.directionDelta(this.direction);\n                this.col += dCol;\n                this.row += dRow;\n                this.moving = false;\n            } else {\n                let angle = Math.atan2(dy, dx);\n                this.x += this.speed * Math.cos(angle);\n                this.y += this.speed * Math.sin(angle);\n            }\n        }\n    }\n\n    static directionDelta(dir) {\n        switch(dir) {\n            case 'left': return [-1, 0];\n            case 'right': return [1, 0];\n            case 'up': return [0, -1];\n            case 'down': return [0, 1];\n            default: return [0, 0];\n        }\n    }\n\n    isAt(col, row) {\n        return this.col === col && this.row === row;\n    }\n\n    render(ctx) {\n        ctx.save();\n        if (this.image) {\n            // Draw PNG/SVG art\n            const img = this._artImg || (this._artImg = new Image());\n            if (!img.src) img.src = this.image;\n            if (img.complete) {\n                ctx.drawImage(\n                    img,\n                    this.x,\n                    this.y,\n                    this.tileSize,\n                    this.tileSize\n                );\n            } else {\n                img.onload = () => {\n                    ctx.drawImage(img, this.x, this.y, this.tileSize, this.tileSize);\n                };\n            }\n        } else {\n            ctx.fillStyle = this.color;\n            ctx.beginPath();\n            ctx.arc(\n                this.x + this.tileSize / 2,\n                this.y + this.tileSize / 2,\n                this.tileSize / 2 - 2,\n                0, 2 * Math.PI\n            );\n            ctx.fill();\n        }\n        ctx.restore();\n    }\n\n    static bfsPath(mapData, start, goal, walkableTiles = [0, 1, 3, 5]) {\n        const queue = [[start]];\n        const visited = new Set();\n        const key = (c, r) => `${c},${r}`;\n        visited.add(key(start.col, start.row));\n        const height = mapData.length;\n        const width = mapData[0].length;\n        while (queue.length) {\n            const path = queue.shift();\n            const {col, row} = path[path.length - 1];\n            if (col === goal.col && row === goal.row) return path;\n            for (const [dc, dr] of [[0,1],[1,0],[0,-1],[-1,0]]) {\n                const nc = col + dc, nr = row + dr;\n                if (nc < 0 || nr < 0 || nc >= width || nr >= height) continue;\n                if (!walkableTiles.includes(mapData[nr][nc])) continue;\n                const k = key(nc, nr);\n                if (visited.has(k)) continue;\n                visited.add(k);\n                queue.push([...path, {col: nc, row: nr}]);\n            }\n        }\n        return null;\n    }\n\n    setDestination(dest, mapData) {\n        if (this.lastPosition && dest.col === this.lastPosition.col && dest.row === this.lastPosition.row) {\n            // Don't allow immediate reversal to previous position\n            return;\n        }\n        this.destination = dest;\n        // Convert mapData to PF grid for full maze\n        const walkable = [this.TILES.EMPTY, this.TILES.DOT, this.TILES.SUPER_DOT, this.TILES.GHOST_DOOR, this.TILES.GHOST_SPAWN];\n        const pfGrid = makePFGrid(mapData, walkable);\n        const finder = new PF.AStarFinder();\n        const pathArr = finder.findPath(this.col, this.row, dest.col, dest.row, pfGrid);\n        // Convert [col,row] array to [{col,row}] for compatibility\n        this.path = pathArr.map(([c, r]) => ({col: c, row: r}));\n        this.pathStep = 1;\n    }\n\n    moveToDestination() {\n        // If path is missing or blocked, try to recompute a new path\n        if (!this.path || this.pathStep >= this.path.length) {\n\n            if (this.destination) {\n                this.path = GhostEntity.bfsPath(this.mapData, {col: this.col, row: this.row}, this.destination);\n                this.pathStep = 1;\n            }\n            // If still no path, abandon destination\n            if (!this.path || this.path.length < 2) {\n                this.destination = null;\n                this.path = null;\n                this.pathStep = 0;\n                return;\n            }\n        }\n\n        // --- FORCE EXIT LOGIC ---\n        if (this.state === 'exiting') {\n            // If the next step is a GHOST_DOOR or EMPTY, always take it immediately\n            const next = this.path[this.pathStep];\n            if (!next) return;\n            const nextType = this.mapData[next.row][next.col];\n            if (nextType === this.TILES.GHOST_DOOR || nextType === this.TILES.EMPTY) {\n                if (next.col > this.col) this.setDirection('right');\n                else if (next.col < this.col) this.setDirection('left');\n                else if (next.row > this.row) this.setDirection('down');\n                else if (next.row < this.row) this.setDirection('up');\n                this.move();\n                if (this.col === next.col && this.row === next.row) this.pathStep++;\n                return;\n            }\n        }\n        // Default: follow path\n        const next = this.path[this.pathStep];\n        if (!next) return;\n        if (this.col === next.col && this.row === next.row) {\n            this.lastPosition = { col: this.col, row: this.row };\n        }\n        if (next.col > this.col) this.setDirection('right');\n        else if (next.col < this.col) this.setDirection('left');\n        else if (next.row > this.row) this.setDirection('down');\n        else if (next.row < this.row) this.setDirection('up');\n        this.move();\n        if (this.col === next.col && this.row === next.row) this.pathStep++;\n    }\n\n    atDestination() {\n        return this.destination && this.col === this.destination.col && this.row === this.destination.row;\n    }\n}\n\nfunction makePFGrid(mapData, walkableTiles) {\n    const grid = [];\n    for (let r = 0; r < mapData.length; r++) {\n        const row = [];\n        for (let c = 0; c < mapData[0].length; c++) {\n            row.push(walkableTiles.includes(mapData[r][c]) ? 0 : 1);\n        }\n        grid.push(row);\n    }\n    return new PF.Grid(grid);\n}\n","// Central config for entity art assets and metadata\n// Use PNG or SVG paths (relative to public/vendor/laraconman/images/)\n\nexport default {\n    player: {\n        name: 'Player',\n        image: '/vendor/laraconman/images/player.svg',\n        size: 32\n    },\n    ghosts: [\n        { name: 'NullPointer',    image: '/vendor/laraconman/images/ghost-blinky.svg', size: 32 },\n        { name: 'PushProduction',       image: '/vendor/laraconman/images/ghost-pinky.svg',  size: 32 },\n        { name: 'Glitchy',        image: '/vendor/laraconman/images/ghost-inky.svg',   size: 32 },\n        { name: 'Regexorcist',    image: '/vendor/laraconman/images/ghost-clyde.svg',  size: 32 },\n        { name: 'RaceCondition',  image: '/vendor/laraconman/images/ghost-blinky.svg', size: 32 },\n        { name: 'HeapReaper',     image: '/vendor/laraconman/images/ghost-pinky.svg',  size: 32 },\n        { name: 'GhostException', image: '/vendor/laraconman/images/ghost-inky.svg',   size: 32 },\n        { name: 'StackOverghost', image: '/vendor/laraconman/images/ghost-clyde.svg',  size: 32 },\n        { name: 'SyntaxTerror',   image: '/vendor/laraconman/images/ghost-blinky.svg', size: 32 }\n    ],\n    dot: {\n        image: '/vendor/laraconman/images/dot.svg',\n        size: 8\n    },\n    powerPellets: [\n        { name: 'Classic', image: '/vendor/laraconman/images/power-pellet-classic.svg', size: 16 },\n        { name: 'Star',    image: '/vendor/laraconman/images/power-pellet-star.svg',    size: 16 }\n    ],\n    fruit: [\n        { name: 'Cherry',  image: '/vendor/laraconman/images/fruit-cherry.svg',  size: 20 },\n        { name: 'Strawberry', image: '/vendor/laraconman/images/fruit-strawberry.svg', size: 20 }\n    ]\n};\n","// CollectibleEntity: base class for dots and fruit\nexport default class CollectibleEntity {\n    constructor(col, row, type = 'dot', options = {}) {\n        this.col = col;\n        this.row = row;\n        this.type = type; // 'dot', 'superdot', 'fruit', etc.\n        this.active = true;\n        this.options = options; // e.g., fruit type, points, image\n    }\n\n    render(ctx, tileSize, art) {\n        if (!this.active) return;\n        if (this.type === 'dot') {\n            ctx.save();\n            ctx.fillStyle = '#fff';\n            ctx.beginPath();\n            ctx.arc(\n                this.col * tileSize + tileSize / 2,\n                this.row * tileSize + tileSize / 2,\n                tileSize / 8,\n                0, 2 * Math.PI\n            );\n            ctx.fill();\n            ctx.restore();\n        } else if (this.type === 'superdot') {\n            ctx.save();\n            ctx.fillStyle = '#ffd700';\n            ctx.beginPath();\n            ctx.arc(\n                this.col * tileSize + tileSize / 2,\n                this.row * tileSize + tileSize / 2,\n                tileSize / 4,\n                0, 2 * Math.PI\n            );\n            ctx.fill();\n            ctx.restore();\n        } else if (this.type === 'fruit') {\n            ctx.save();\n            if (art && art.fruit && art.fruit.image) {\n                ctx.drawImage(\n                    art.fruit.image,\n                    this.col * tileSize,\n                    this.row * tileSize,\n                    tileSize, tileSize\n                );\n            } else {\n                ctx.fillStyle = '#f00';\n                ctx.beginPath();\n                ctx.arc(\n                    this.col * tileSize + tileSize / 2,\n                    this.row * tileSize + tileSize / 2,\n                    tileSize / 3,\n                    0, 2 * Math.PI\n                );\n                ctx.fill();\n            }\n            ctx.restore();\n        }\n    }\n}\n","// CollectibleSpawner: generates dots and fruit on valid tiles\nimport CollectibleEntity from './collectible-entity.js';\nimport settings from './settings.js';\n\nexport default class CollectibleSpawner {\n    constructor(mapData, tileTypes, options = {}) {\n        this.mapData = mapData;\n        this.tileTypes = tileTypes; // { EMPTY, PORTAL, GHOST_SPAWN, GHOST_DOOR, ... }\n        this.options = options;\n    }\n\n    // Returns: { dots: [], fruit: [] }\n    spawnCollectibles(existingEntities = []) {\n        const dots = [];\n        const fruit = [];\n        const occupied = new Set(existingEntities.map(e => `${e.col},${e.row}`));\n        // Pick a random fruit type\n        const fruitType = settings.fruitTypes[Math.floor(Math.random() * settings.fruitTypes.length)];\n        // Optionally, allow caller to pass fruit locations\n        let fruitLocations = this.options.fruitLocations || [];\n        if (fruitLocations.length === 0) {\n            fruitLocations = [this._pickRandomValidTile(occupied)];\n        }\n        for (const loc of fruitLocations) {\n            if (loc) {\n                fruit.push(new CollectibleEntity(loc.col, loc.row, 'fruit', {\n                    ...fruitType\n                }));\n                occupied.add(`${loc.col},${loc.row}`);\n            }\n        }\n        for (let row = 0; row < this.mapData.length; row++) {\n            for (let col = 0; col < this.mapData[0].length; col++) {\n                if (\n                    this.mapData[row][col] === this.tileTypes.EMPTY &&\n                    !occupied.has(`${col},${row}`) &&\n                    !this._isInPen(col, row) &&\n                    !this._isInPortalOrTunnel(col, row)\n                ) {\n                    dots.push(new CollectibleEntity(col, row, 'dot', { points: settings.dotPoints }));\n                }\n            }\n        }\n        return { dots, fruit };\n    }\n\n    _pickRandomValidTile(occupied) {\n        const valid = [];\n        for (let row = 0; row < this.mapData.length; row++) {\n            for (let col = 0; col < this.mapData[0].length; col++) {\n                if (\n                    this.mapData[row][col] === this.tileTypes.EMPTY &&\n                    !occupied.has(`${col},${row}`) &&\n                    !this._isInPen(col, row) &&\n                    !this._isInPortalOrTunnel(col, row)\n                ) {\n                    valid.push({ col, row });\n                }\n            }\n        }\n        if (valid.length === 0) return null;\n        return valid[Math.floor(Math.random() * valid.length)];\n    }\n\n    _isInPen(col, row) {\n        // Pen is GHOST_SPAWN or GHOST_DOOR\n        return (\n            this.mapData[row][col] === this.tileTypes.GHOST_SPAWN ||\n            this.mapData[row][col] === this.tileTypes.GHOST_DOOR\n        );\n    }\n\n    _isInPortalOrTunnel(col, row) {\n        // Exclude portals and the empty tunnel path between them\n        if (this.mapData[row][col] === this.tileTypes.PORTAL) return true;\n        // Optionally: Exclude direct tunnel path (left/right edge)\n        if (col === 0 || col === this.mapData[0].length - 1) return true;\n        return false;\n    }\n}\n","import settings from './settings.js';\nimport InputHandler from './input-handler.js';\nimport MapRenderer from './map-renderer.js';\nimport PlayerEntity from './player-entity.js';\nimport GhostEntity from './ghost-entity.js';\nimport PF from 'pathfinding'; // Import PathFinding.js\nimport entityArt from './entity-art.js';\nimport EventEmitter from 'events';\nimport CollectibleEntity from './collectible-entity.js';\nimport CollectibleSpawner from './collectible-spawner.js';\n\n// Main game coordination using modular architecture\nclass Game {\n    ghosts = [];\n    constructor() {\n        this.canvas = null;\n        this.mapRenderer = null;\n        this.inputHandler = null;\n        this.gameState = 'stopped'; // stopped, playing, paused\n        this.currentMap = null;\n        this.player = null;\n\n        // Game elements initialized from settings\n        this.score = settings.score;\n        this.lives = settings.lives;\n        this.level = settings.level;\n        this.moveInc = settings.moveInc;\n        this.speed = settings.speed;\n        this.gameTime = settings.gameTime;\n        this.mazeSource = settings.mazeSource;\n        this.basicVision = settings.basicVision;\n        this.resetModeOnResetGame = settings.resetModeOnResetGame;\n        this.excludeReverseDirectionInRandomMode = settings.excludeReverseDirectionInRandomMode;\n        this.fx = settings.fx;\n        this.extras = settings.extras;\n        this.maxGhosts = (settings && settings.maxGhosts) || 3;\n\n        // Input handler: dump all input to console\n        this.inputHandler = new InputHandler();\n\n        this.inputHandler.setCallbacks({\n            onDirectionChange: dir => console.log('Direction:', dir),\n            onKeyPress: (code, event) => console.log('Key:', code, event),\n            onPause: () => console.log('Pause requested'),\n            onReset: () => console.log('Reset requested')\n        });\n\n        // Initialize when DOM is ready\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', () => this.init());\n        } else {\n            this.init();\n        }\n\n        // Add event emitter for tile events\n        this.tileEventEmitter = new TileEventEmitter();\n        this.ghostReleaseTimer = 0;\n        this.ghostReleaseInterval = 200; // frames between releases (adjustable)\n        this.ghostPool = [...entityArt.ghosts]; // All possible ghosts\n        this.activeGhosts = []; // Ghosts currently in play\n        this.collisionEmitter = new EventEmitter();\n\n        // Add default event handlers for collisions\n        this.collisionEmitter.on('player-ghost', ({player, ghost}) => {\n            console.log('Player collided with ghost:', ghost.displayName || ghost.color);\n        });\n        this.collisionEmitter.on('player-dot', ({player, pellet}) => {\n            console.log('Player collected dot at:', pellet.col, pellet.row);\n        });\n        this.collisionEmitter.on('player-mega-pellet', ({ player, col, row }) => {\n            console.log(`Mega pellet collected at (${col}, ${row}) by player`, player);\n        });\n\n        this.ghostPenTimers = new Map(); // Track time each ghost spends in pen\n        this.ghostExitTimers = new Map(); // Track how long a ghost has been trying to exit\n        this.ghostExitTimeout = 2 * 60; // 2 seconds at 60fps\n        // Ghost pen timeout (in frames, from settings)\n        this.ghostPenTimeout = (settings.ghostPenTimeout || 2) * 60;\n        this.collisionCooldowns = new Map(); // Track entity collision cooldowns\n        this.collisionCooldownFrames = 30; // Half a second at 60fps\n        \n        // Ghost freeze detection\n        this.ghostPositions = new Map(); // Track last known positions\n        this.ghostStuckCounters = new Map(); // Count frames a ghost has been stuck\n        this.ghostStuckThreshold = 60; // 1 second at 60fps\n        \n        // Portal teleportation cooldowns to prevent loops\n        this.portalCooldowns = new Map(); // Track entity portal usage\n        this.portalCooldownFrames = 30; // Half second cooldown after teleport\n\n        // Listen for superdot pickup events\n        this.tileEventEmitter.on(event => {\n            if (event.type === 'superdot') {\n                console.log('Superdot event triggered:', event);\n                // Set player super state\n                if (this.player && typeof this.player.setSuperState === 'function') {\n                    this.player.setSuperState(true);\n                    setTimeout(() => {\n                        this.player.setSuperState(false);\n                    }, (settings.megaPelletDuration || 5) * 1000);\n                }\n                // For each ghost not in pen, pick a random destination away from player\n                const player = this.player;\n                const ghosts = this.ghosts || [];\n                const mapData = this.mapRenderer.mapData;\n                const minDistance = 6; // tiles away from player\n                const usedSpots = new Set();\n                ghosts.forEach((ghost, idx) => {\n                    if (ghost.state !== 'in_pen' && ghost.state !== 'exiting') {\n                        let tries = 0;\n                        let dest;\n                        do {\n                            const angle = Math.random() * 2 * Math.PI;\n                            const dist = minDistance + Math.floor(Math.random() * 4) + idx;\n                            const col = Math.max(1, Math.min(mapData[0].length - 2, player.col + Math.round(Math.cos(angle) * dist)));\n                            const row = Math.max(1, Math.min(mapData.length - 2, player.row + Math.round(Math.sin(angle) * dist)));\n                            dest = {col, row};\n                            tries++;\n                        } while (\n                            (mapData[dest.row][dest.col] !== this.mapRenderer.TILES.EMPTY || usedSpots.has(`${dest.col},${dest.row}`)) && tries < 10\n                        );\n                        usedSpots.add(`${dest.col},${dest.row}`);\n                        ghost.setDestination(dest, mapData);\n                        // Immediately update ghost direction and path\n                        if (typeof ghost.moveToDestination === 'function') {\n                            ghost.pathStep = 1;\n                            ghost.moveToDestination();\n                        }\n                    }\n                });\n            }\n        });\n    }\n\n    /**\n     * Initialize the game\n     */\n    init() {\n        this.canvas = document.getElementById('gameCanvas');\n        if (!this.canvas) {\n            console.error('Game canvas not found');\n            return;\n        }\n\n        console.log(this.canvas);\n\n        // --- Maze rendering integration ---\n        const csv = window.laraconmanMazeCsv;\n        if (csv) {\n            // Parse CSV and load into MapRenderer\n            const mapArray = Game.parseAndAdaptMazeCsv(csv);\n            const width = mapArray[0]?.length || 0;\n            const height = mapArray.length;\n            this.mapRenderer = new MapRenderer(this.canvas);\n            // MapRenderer expects CSV string, so rejoin for compatibility\n            const normalizedCsv = mapArray.map(row => row.join(',')).join('\\n');\n            this.mapRenderer.loadMap(normalizedCsv, width, height);\n            this.mapRenderer.render();\n            this.initPlayer(this.mapRenderer.mapData, this.mapRenderer.tileSize);\n            this.initCollectibles();\n            this.gameLoop();\n        }\n\n        console.log('Game initialized');\n    }\n\n    initCollectibles() {\n        // Use the map and tile types from mapRenderer\n        const mapData = this.mapRenderer.mapData;\n        const tileTypes = this.mapRenderer.TILES;\n        const spawner = new CollectibleSpawner(mapData, tileTypes);\n        const { dots, fruit } = spawner.spawnCollectibles();\n        this.dots = dots;\n        this.fruit = fruit;\n    }\n\n    /**\n     * Utility: Parse and adapt CSV maze data from Blade\n     * Converts pass-through tunnel (4) to renderer's tunnel (5) if needed\n     */\n    static parseAndAdaptMazeCsv(csvString) {\n        const rows = csvString.trim().split('\\n');\n        return rows.map(row =>\n            row.trim().split(',').map(val => {\n                let n = Number(val.trim());\n                // Example: adapt 4 to 5 if renderer expects 5 for tunnel\n                // If MapRenderer expects 4 for tunnel, no change needed\n                return n;\n            })\n        );\n    }\n\n    /**\n     * Set up UI event listeners\n     */\n    setupUI() {\n        const startBtn = document.getElementById('startBtn');\n        const pauseBtn = document.getElementById('pauseBtn');\n        const resetBtn = document.getElementById('resetBtn');\n\n        if (startBtn) {\n            startBtn.addEventListener('click', () => this.startGame());\n        }\n\n        if (pauseBtn) {\n            pauseBtn.addEventListener('click', () => this.togglePause());\n        }\n\n        if (resetBtn) {\n            resetBtn.addEventListener('click', () => this.resetGame());\n        }\n    }\n\n    /**\n     * Load map data from DOM (passed from PHP)\n     */\n    loadMapFromDOM() {\n        // Look for map data in a script tag or data attribute\n        const mapDataScript = document.getElementById('mapData');\n        if (mapDataScript) {\n            try {\n                this.currentMap = JSON.parse(mapDataScript.textContent);\n                this.loadMap(this.currentMap);\n            } catch (e) {\n                console.error('Failed to parse map data:', e);\n            }\n        } else {\n            // Fallback: look for global window variable\n            if (window.gameMapData) {\n                this.currentMap = window.gameMapData;\n                this.loadMap(this.currentMap);\n            } else {\n                console.warn('No map data found. Using test map.');\n                this.loadTestMap();\n            }\n        }\n    }\n\n    /**\n     * Load a map into the renderer\n     * @param {object} mapData - Map data from database\n     */\n    loadMap(mapData) {\n        if (!mapData || !mapData.design) {\n            console.error('Invalid map data');\n            return;\n        }\n\n        console.log('Loading map:', mapData.name);\n\n        // Load map into renderer\n        this.mapRenderer.loadMap(mapData.design, mapData.width, mapData.height);\n\n        // Render the map\n        this.mapRenderer.render();\n\n        // Update UI\n        this.updateUI();\n    }\n\n    /**\n     * Load a test map for development\n     */\n    loadTestMap() {\n        const testMap = {\n            name: 'Test Map',\n            width: 19,\n            height: 21,\n            design: `1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1\n1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1\n1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1\n1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,2,1\n1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1\n1,1,1,1,2,1,1,1,0,1,0,1,1,1,2,1,1,1,1\n0,0,0,1,2,1,0,0,0,0,0,0,0,1,2,1,0,0,0\n1,1,1,1,2,1,0,1,3,3,3,1,0,1,2,1,1,1,1\n4,0,0,0,2,0,0,1,0,0,0,1,0,0,2,0,0,0,4\n1,1,1,1,2,1,0,1,1,1,1,1,0,1,2,1,1,1,1\n0,0,0,1,2,1,0,0,0,0,0,0,0,1,2,1,0,0,0\n1,1,1,1,2,1,1,1,0,1,0,1,1,1,2,1,1,1,1\n1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1\n1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1\n1,2,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1\n1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1\n1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1\n1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1\n1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1`\n        };\n\n        this.currentMap = testMap;\n        this.loadMap(testMap);\n    }\n\n    /**\n     * Start the game\n     */\n    startGame() {\n        if (this.gameState === 'stopped') {\n            this.gameState = 'playing';\n            this.updateUI();\n            console.log('Game started');\n\n            // TODO: Initialize player and ghosts\n        } else if (this.gameState === 'paused') {\n            this.gameState = 'playing';\n            this.updateUI();\n            console.log('Game resumed');\n        }\n    }\n\n    /**\n     * Toggle pause state\n     */\n    togglePause() {\n        if (this.gameState === 'playing') {\n            this.gameState = 'paused';\n            console.log('Game paused');\n        } else if (this.gameState === 'paused') {  \n            this.gameState = 'playing';\n            console.log('Game resumed');\n        }\n        this.updateUI();\n    }\n\n    /**\n     * Reset the game\n     */\n    resetGame() {\n        this.gameState = 'stopped';\n        this.score = settings.score;\n        this.lives = settings.lives;\n\n        // Reset input handler\n        this.inputHandler.reset();\n\n        // Reload current map\n        if (this.currentMap) {\n            this.loadMap(this.currentMap);\n        }\n\n        this.updateUI();\n        console.log('Game reset');\n    }\n\n    /**\n     * Handle direction changes from input\n     * @param {string} direction - New movement direction\n     */\n    handleDirectionChange(direction) {\n        if (this.gameState !== 'playing') return;\n\n        console.log('Direction changed:', direction);\n        // TODO: Update player movement direction\n    }\n\n    /**\n     * Update UI elements\n     */\n    updateUI() {\n        // Update score\n        const scoreElement = document.getElementById('score');\n        if (scoreElement) {\n            scoreElement.textContent = this.score;\n        }\n\n        // Update lives\n        const livesElement = document.getElementById('lives');\n        if (livesElement) {\n            livesElement.textContent = this.lives;\n        }\n\n        // Update button states\n        const startBtn = document.getElementById('startBtn');\n        const pauseBtn = document.getElementById('pauseBtn');\n\n        if (startBtn) {\n            startBtn.textContent = this.gameState === 'stopped' ? 'Start Game' : 'Resume';\n            startBtn.disabled = this.gameState === 'playing';\n        }\n\n        if (pauseBtn) {\n            pauseBtn.textContent = this.gameState === 'paused' ? 'Resume' : 'Pause';\n            pauseBtn.disabled = this.gameState === 'stopped';\n        }\n    }\n\n    /**\n     * Get current game state\n     * @returns {string} Current game state\n     */\n    getGameState() {\n        return this.gameState;\n    }\n\n    /**\n     * Get current map data\n     * @returns {object} Current map data\n     */\n    getCurrentMap() {\n        return this.currentMap;\n    }\n\n    /**\n     * Initialize player entity\n     * @param {array} mapData - Map data\n     * @param {number} tileSize - Tile size\n     */\n    initPlayer(mapData, tileSize) {\n        // Find ghost pen tiles\n        let penTiles = [];\n        for (let r = 0; r < mapData.length; r++) {\n            for (let c = 0; c < mapData[0].length; c++) {\n                if (mapData[r][c] === this.mapRenderer.TILES.GHOST_SPAWN) {\n                    penTiles.push({col: c, row: r});\n                }\n            }\n        }\n        // Find center-most tile below the pen that is EMPTY\n        let playerStart = { col: 1, row: 1 };\n        if (penTiles.length > 0) {\n            // Compute center col of pen\n            let penCols = penTiles.map(t => t.col);\n            let penRows = penTiles.map(t => t.row);\n            let minCol = Math.min(...penCols), maxCol = Math.max(...penCols);\n            let maxRow = Math.max(...penRows);\n            let centerCol = Math.round((minCol + maxCol) / 2);\n            // Search downward from just below pen, only at centerCol\n            for (let r = maxRow + 1; r < mapData.length-1; r++) {\n                if (mapData[r][centerCol] === this.mapRenderer.TILES.EMPTY) {\n                    playerStart = {col: centerCol, row: r};\n                    break;\n                }\n            }\n        } else {\n            // fallback to old logic\n            outer: for (let r = 1; r < mapData.length-1; r++) {\n                for (let c = 1; c < mapData[0].length-1; c++) {\n                    if (mapData[r][c] === 0) {\n                        playerStart = { col: c, row: r };\n                        break outer;\n                    }\n                }\n            }\n        }\n        const speed = 2;\n        this.player = new PlayerEntity(playerStart.col, playerStart.row, tileSize, mapData, settings);\n        if (this.inputHandler && typeof this.inputHandler.setCallbacks === 'function') {\n            this.inputHandler.setCallbacks({\n                onDirectionChange: dir => {\n                    if (this.player) this.player.setDirection(dir);\n                }\n            });\n        }\n    }\n\n    /**\n     * Check for item collision and emit event\n     */\n    checkPlayerTile() {\n        if (!this.player) return;\n        const { col, row } = this.player;\n        // Check for dot collision\n        if (this.dots) {\n            for (const dot of this.dots) {\n                if (dot.active && dot.col === col && dot.row === row) {\n                    dot.active = false;\n                    // Fire window event for points (from dot.options.points)\n                    window.dispatchEvent(new CustomEvent('player-dot', { detail: { col, row, points: dot.options.points || 10 } }));\n                    break;\n                }\n            }\n        }\n        // Check for fruit collision\n        if (this.fruit) {\n            for (const fruit of this.fruit) {\n                if (fruit.active && fruit.col === col && fruit.row === row) {\n                    fruit.active = false;\n                    // Fire window event for fruit pickup (include image/type/points)\n                    window.dispatchEvent(new CustomEvent('player-fruit', { detail: {\n                        col, row,\n                        points: fruit.options.points || 100,\n                        type: fruit.options.type || 'fruit',\n                        image: fruit.options.image || null\n                    }}));\n                    break;\n                }\n            }\n        }\n        // Existing logic...\n        const tile = this.mapRenderer.mapData[row][col];\n\n        if (tile ===this.mapRenderer.TILES.EMPTY) {\n        } else if ([this.mapRenderer.TILES.PELLET, this.mapRenderer.TILES.SUPER_DOT].includes(tile)) {\n            this.tileEventEmitter.emit({\n                type: tile === 1 ? 'pellet' : 'superdot',\n                col, row\n            });\n            // Remove item from map\n            this.mapRenderer.mapData[row][col] = 0;\n        } else  {\n            console.log(tile);\n\n\n        }\n        // TODO: fruit, other items\n    }\n\n    /**\n     * Spawn a ghost at a random ghost spawn tile INSIDE THE PEN\n     */\n    spawnGhost() {\n        if (this.ghosts.length >= this.maxGhosts) return;\n\n        // Find all ghost spawn tiles inside the pen (classic: 2 rows x 4 cols above door)\n        const spawns = [];\n        const data = this.mapRenderer.mapData;\n        for (let r = 0; r < data.length; r++) {\n            for (let c = 0; c < data[0].length; c++) {\n                if (data[r][c] === this.mapRenderer.TILES.GHOST_SPAWN) spawns.push({col: c, row: r});\n            }\n        }\n        if (spawns.length === 0) return;\n        // Pick a random pen tile for each new ghost\n        const idx = Math.floor(Math.random() * spawns.length);\n        const spawn = spawns[idx];\n        const usedNames = this.activeGhosts.map(g => g.name);\n        const available = this.ghostPool.filter(g => !usedNames.includes(g.name));\n        if (available.length === 0 || this.ghosts.length >= this.maxGhosts) return;\n        const ghostConfig = available[Math.floor(Math.random() * available.length)];\n        const ghostSpeed = 2;\n        const ghostColor = ghostConfig.color || '#FF0000';\n        const ghost = new GhostEntity(\n            spawn.col,\n            spawn.row,\n            this.mapRenderer.tileSize,\n            this.mapRenderer.mapData,\n            ghostSpeed,\n            ghostColor,\n            this.mapRenderer.TILES\n        );\n        ghost.image = ghostConfig.image;\n        ghost.displayName = ghostConfig.name;\n        this.ghosts.push(ghost);\n        this.activeGhosts.push(ghostConfig);\n    }\n\n    /**\n     * Move ghosts with pathfinding to a random destination outside the pen\n     */\n    moveGhosts() {\n        const data = this.mapRenderer.mapData;\n        const penTiles = [];\n        for (let r = 0; r < data.length; r++) {\n            for (let c = 0; c < data[0].length; c++) {\n                if (data[r][c] === this.mapRenderer.TILES.GHOST_SPAWN) penTiles.push(`${c},${r}`);\n            }\n        }\n        for (const ghost of this.ghosts) {\n            if (ghost.state === 'in_pen') {\n                // Move randomly within pen\n                const dirs = ['up','down','left','right'].filter(dir => ghost.canMove(dir));\n                if (dirs.length > 0) {\n                    const dir = dirs[Math.floor(Math.random()*dirs.length)];\n                    ghost.setDirection(dir);\n                }\n                // Fallback: force-evict after timeout\n                const t = this.ghostPenTimers.get(ghost) || 0;\n                this.ghostPenTimers.set(ghost, t + 1);\n                if (t + 1 > this.ghostPenTimeout) {\n                    ghost.setState('exiting');\n                    this.ghostPenTimers.delete(ghost);\n                    // Pick a destination OUTSIDE the pen ONLY if not already set\n                    if (!ghost.destination) {\n                        let candidates = [];\n                        for (let r = 0; r < data.length; r++) {\n                            for (let c = 0; c < data[0].length; c++) {\n                                const tile = data[r][c];\n                                if ((tile === this.mapRenderer.TILES.EMPTY || tile === this.mapRenderer.TILES.DOT || tile === this.mapRenderer.TILES.SUPER_DOT)\n                                    && !penTiles.includes(`${c},${r}`)\n                                    && !(ghost.col === c && ghost.row === r)) {\n                                    candidates.push({col: c, row: r});\n                                }\n                            }\n                        }\n                        if (candidates.length > 0) {\n                            const dest = candidates[Math.floor(Math.random()*candidates.length)];\n                            ghost.setDestination(dest, data);\n                        }\n                    }\n                    ghost.moveToDestination();\n                } else {\n                    ghost.move();\n                }\n            } else if (ghost.state === 'exiting') {\n                // Always move to destination if exiting\n                ghost.moveToDestination();\n                if (ghost.atDestination() && !penTiles.includes(`${ghost.col},${ghost.row}`)) {\n                    ghost.setState('active');\n                }\n            } else if (ghost.state === 'active') {\n                // If ghost is active and has no destination or has reached its destination, pick a new one\n                if (!ghost.destination || ghost.atDestination()) {\n                    let candidates = [];\n                    for (let r = 0; r < data.length; r++) {\n                        for (let c = 0; c < data[0].length; c++) {\n                            const tile = data[r][c];\n                            if ((tile === this.mapRenderer.TILES.EMPTY || tile === this.mapRenderer.TILES.DOT || tile === this.mapRenderer.TILES.SUPER_DOT)\n                                && !penTiles.includes(`${c},${r}`)) {\n                                candidates.push({col: c, row: r});\n                            }\n                        }\n                    }\n                    if (candidates.length > 0) {\n                        const dest = candidates[Math.floor(Math.random()*candidates.length)];\n                        ghost.setDestination(dest, data);\n                    }\n                }\n                ghost.moveToDestination();\n            } else {\n                this.ghostPenTimers.delete(ghost);\n                ghost.move();\n            }\n        }\n    }\n\n    /**\n     * Game loop\n     */\n    gameLoop() {\n        this.mapRenderer.render();\n        this.renderCollectibles(this.mapRenderer.ctx);\n        if (this.player) {\n            this.player.move();\n            this.player.render(this.mapRenderer.ctx);\n            this.checkPlayerTile();\n        }\n        this.moveGhosts();\n        for (const ghost of this.ghosts) ghost.render(this.mapRenderer.ctx);\n        // Ghost release logic\n        this.ghostReleaseTimer++;\n        if (this.ghostReleaseTimer >= this.ghostReleaseInterval) {\n            this.spawnGhost();\n            this.ghostReleaseTimer = 0;\n        }\n        // Check collisions for player\n        if (this.player) {\n            this.checkCollisions(this.player);\n        }\n        \n        // Check collisions for all ghosts\n        for (const ghost of this.ghosts) {\n            this.checkCollisions(ghost);\n        }\n        \n        // Update collision cooldowns\n        this.updateCollisionCooldowns();\n        \n        requestAnimationFrame(() => this.gameLoop());\n    }\n\n    renderCollectibles(ctx) {\n        if (this.dots) this.dots.forEach(dot => dot.render(ctx, this.mapRenderer.tileSize));\n        if (this.fruit) this.fruit.forEach(fruit => fruit.render(ctx, this.mapRenderer.tileSize, this.mapRenderer.entityArt));\n    }\n\n    /**\n     * Check what any entity is hitting at their current position\n     * Call this when an entity moves to a new coordinate\n     */\n    checkCollisions(entity) {\n        if (!entity || entity.col === undefined || entity.row === undefined) return;\n\n        const { col, row } = entity;\n        const collisions = this.getWhatIsAt(col, row);\n        \n        // Fire collision events only once per collision\n        this.fireCollisionEvents(entity, collisions);\n    }\n\n    /**\n     * Get everything at a specific coordinate\n     */\n    getWhatIsAt(col, row) {\n        const result = {\n            tile: this.mapRenderer.mapData[row] ? this.mapRenderer.mapData[row][col] : null,\n            entities: []\n        };\n\n        // Check for other entities at this position\n        if (this.player && this.player.col === col && this.player.row === row) {\n            result.entities.push({ type: 'player', entity: this.player });\n        }\n\n        for (const ghost of this.ghosts) {\n            if (ghost.col === col && ghost.row === row) {\n                result.entities.push({ type: 'ghost', entity: ghost });\n            }\n        }\n\n        if (this.pellets) {\n            for (const pellet of this.pellets) {\n                if (pellet.col === col && pellet.row === row) {\n                    result.entities.push({ type: 'pellet', entity: pellet });\n                }\n            }\n        }\n\n        if (this.fruits) {\n            for (const fruit of this.fruits) {\n                if (fruit.col === col && fruit.row === row) {\n                    result.entities.push({ type: 'fruit', entity: fruit });\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Fire collision events for entity hitting something\n     */\n    fireCollisionEvents(entity, collisions) {\n        const entityType = this.getEntityType(entity);\n        \n        // Handle entity vs entity collisions\n        for (const collision of collisions.entities) {\n            if (collision.entity === entity) continue; // Don't collide with self\n            \n            const key = `${entityType}:${collision.type}:${collision.entity.id || collision.entity.displayName || collision.entity.color}`;\n            \n            if (this.shouldFireEvent(key)) {\n                this.collisionEmitter.emit(`${entityType}-${collision.type}`, {\n                    [entityType]: entity,\n                    [collision.type]: collision.entity\n                });\n                this.setEventCooldown(key);\n            }\n        }\n\n        // Handle tile collisions (portals, collectibles on map)\n        if (collisions.tile) {\n            this.handleTileCollision(entity, collisions.tile, entity.col, entity.row);\n        }\n    }\n\n    /**\n     * Handle when an entity hits a map tile\n     */\n    handleTileCollision(entity, tile, col, row) {\n        const entityType = this.getEntityType(entity);\n        \n        // Handle portals for any entity (player or ghost)\n        if (tile === this.mapRenderer.TILES.PORTAL) {\n            const portalKey = `${entityType}:portal:${col},${row}`;\n            const cooldown = this.portalCooldowns.get(portalKey) || 0;\n            \n            if (cooldown === 0) {\n                const dest = this.findOppositePortal(col, row);\n                if (dest) {\n                    // Set cooldown for both entry and exit portal\n                    const destKey = `${entityType}:portal:${dest.col},${dest.row}`;\n                    this.portalCooldowns.set(portalKey, this.portalCooldownFrames);\n                    this.portalCooldowns.set(destKey, this.portalCooldownFrames);\n                    // Move entity one block away from portal exit toward map center\n                    let dCol = 0, dRow = 0;\n                    const centerCol = Math.floor(this.mapRenderer.mapData[0].length / 2);\n                    if (dest.col < centerCol) dCol = 1;\n                    else if (dest.col > centerCol) dCol = -1;\n                    // If vertical tunnel, bias row\n                    const centerRow = Math.floor(this.mapRenderer.mapData.length / 2);\n                    if (dest.row < centerRow) dRow = 1;\n                    else if (dest.row > centerRow) dRow = -1;\n                    let newCol = dest.col + dCol;\n                    let newRow = dest.row + dRow;\n                    // Only move if new tile is walkable\n                    const walkable = [this.mapRenderer.TILES.EMPTY, this.mapRenderer.TILES.DOT, this.mapRenderer.TILES.SUPER_DOT];\n                    if (\n                        newCol >= 0 && newCol < this.mapRenderer.mapData[0].length &&\n                        newRow >= 0 && newRow < this.mapRenderer.mapData.length &&\n                        walkable.includes(this.mapRenderer.mapData[newRow][newCol])\n                    ) {\n                        this.teleportEntity(entity, {col: newCol, row: newRow});\n                        // Set cooldown for the ejection tile as well\n                        const ejectionKey = `${entityType}:portal:${newCol},${newRow}`;\n                        this.portalCooldowns.set(ejectionKey, this.portalCooldownFrames);\n                    } else {\n                        this.teleportEntity(entity, dest);\n                    }\n                    // Emit appropriate event\n                    if (entityType === 'player') {\n                        this.collisionEmitter.emit('player-portal', {\n                            player: entity,\n                            from: { col, row },\n                            to: dest\n                        });\n                    } else if (entityType === 'ghost') {\n                        this.collisionEmitter.emit('ghost-portal', {\n                            ghost: entity,\n                            from: { col, row },\n                            to: dest\n                        });\n                        // After using a portal, clear destination so ghost picks a new one\n                        entity.destination = null;\n                        entity.path = null;\n                        entity.pathStep = 0;\n                    }\n                }\n            }\n        }\n        \n        // Handle collectible tiles (only for player)\n        if (entityType === 'player') {\n            const key = `${entityType}:tile:${col},${row}`;\n            \n            if (tile === this.mapRenderer.TILES.DOT && this.shouldFireEvent(key)) {\n                this.collisionEmitter.emit('player-dot', { \n                    player: entity, \n                    col, row \n                });\n                this.mapRenderer.mapData[row][col] = this.mapRenderer.TILES.EMPTY;\n                this.setEventCooldown(key);\n            }\n            \n            if (tile === this.mapRenderer.TILES.SUPER_DOT && this.shouldFireEvent(key)) {\n                this.collisionEmitter.emit('player-mega-pellet', { \n                    player: entity, \n                    col, row \n                });\n                this.mapRenderer.mapData[row][col] = this.mapRenderer.TILES.EMPTY;\n                this.setEventCooldown(key);\n            }\n        }\n    }\n\n    /**\n     * Teleport entity to destination\n     */\n    teleportEntity(entity, dest) {\n        entity.col = dest.col;\n        entity.row = dest.row;\n        entity.x = dest.col * entity.tileSize;\n        entity.y = dest.row * entity.tileSize;\n        entity.targetX = entity.x;\n        entity.targetY = entity.y;\n        entity.moving = false;\n    }\n\n    /**\n     * Get entity type string\n     */\n    getEntityType(entity) {\n        if (entity === this.player) return 'player';\n        if (this.ghosts.includes(entity)) return 'ghost';\n        return 'unknown';\n    }\n\n    /**\n     * Check if event should fire (not in cooldown)\n     */\n    shouldFireEvent(key) {\n        const cooldown = this.collisionCooldowns.get(key) || 0;\n        return cooldown === 0;\n    }\n\n    /**\n     * Set event cooldown\n     */\n    setEventCooldown(key) {\n        this.collisionCooldowns.set(key, this.collisionCooldownFrames);\n    }\n\n    /**\n     * Update collision cooldowns each frame\n     */\n    updateCollisionCooldowns() {\n        // Decrement collision cooldowns\n        for (const [key, value] of this.collisionCooldowns.entries()) {\n            if (value > 0) {\n                this.collisionCooldowns.set(key, value - 1);\n            }\n        }\n        // Decrement portal cooldowns\n        for (const [key, value] of this.portalCooldowns.entries()) {\n            if (value > 0) {\n                this.portalCooldowns.set(key, value - 1);\n            }\n        }\n    }\n\n    // Find the portal/tunnel tile on the opposite side\n    findOppositePortal(col, row) {\n        const portals = [];\n        const map = this.mapRenderer.mapData;\n        for (let r = 0; r < map.length; r++) {\n            for (let c = 0; c < map[0].length; c++) {\n                if (map[r][c] === this.mapRenderer.TILES.PORTAL && (c !== col || r !== row)) {\n                    portals.push({ col: c, row: r });\n                }\n            }\n        }\n        if (portals.length === 0) return null;\n        if (portals.length === 1) return portals[0];\n        // Try to match by row (left/right tunnels)\n        for (const p of portals) {\n            if (p.row === row) return p;\n        }\n        // If not found, try to match by column (top/bottom tunnels)\n        for (const p of portals) {\n            if (p.col === col) return p;\n        }\n        // Fallback: pick the farthest (classic Pac-Man: left/right edge)\n        let maxDist = -1, best = null;\n        for (const p of portals) {\n            const dist = Math.abs(p.col - col) + Math.abs(p.row - row);\n            if (dist > maxDist) {\n                maxDist = dist;\n                best = p;\n            }\n        }\n        return best;\n    }\n\n    // Helper: bounding-box collision for entities\n    isEntityColliding(a, b) {\n        const size = Math.min(a.tileSize, b.tileSize) * 0.6; // 60% of tile size for hitbox\n        return (\n            Math.abs(a.x - b.x) < size &&\n            Math.abs(a.y - b.y) < size\n        );\n    }\n}\n\n// Utility to convert mapData to PathFinding.js grid format\nfunction makePFGrid(mapData, walkableTiles) {\n    const grid = [];\n    for (let r = 0; r < mapData.length; r++) {\n        const row = [];\n        for (let c = 0; c < mapData[0].length; c++) {\n            // 0 = walkable, 1 = blocked\n            row.push(walkableTiles.includes(mapData[r][c]) ? 0 : 1);\n        }\n        grid.push(row);\n    }\n    return new PF.Grid(grid);\n}\n\n// Add event emitter for tile events\nclass TileEventEmitter {\n    constructor() {\n        this.listeners = [];\n    }\n    on(cb) { this.listeners.push(cb); }\n    emit(event) { this.listeners.forEach(cb => cb(event)); }\n}\n\n// Initialize game when script loads\nconst game = new Game();","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there are no obstacles.\r\n */\r\nfunction JPFMoveDiagonallyIfNoObstacles(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            // return [x, y];\r\n        // }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if (dx !== 0) {\r\n            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n                return [x, y];\r\n            }\r\n            // When moving vertically, must check for horizontal jump points\r\n            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n                // return [x, y];\r\n            // }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            var isNextWalkable;\r\n            if (dx !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x + dx, y);\r\n                var isTopWalkable = grid.isWalkableAt(x, y + 1);\r\n                var isBottomWalkable = grid.isWalkableAt(x, y - 1);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (isTopWalkable) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (isBottomWalkable) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n                if (isTopWalkable) {\r\n                    neighbors.push([x, y + 1]);\r\n                }\r\n                if (isBottomWalkable) {\r\n                    neighbors.push([x, y - 1]);\r\n                }\r\n            }\r\n            else if (dy !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x, y + dy);\r\n                var isRightWalkable = grid.isWalkableAt(x + 1, y);\r\n                var isLeftWalkable = grid.isWalkableAt(x - 1, y);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (isRightWalkable) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (isLeftWalkable) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n                if (isRightWalkable) {\r\n                    neighbors.push([x + 1, y]);\r\n                }\r\n                if (isLeftWalkable) {\r\n                    neighbors.push([x - 1, y]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfNoObstacles;\r\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  if (typeof module !== \"undefined\" && module !== null ? module.exports : void 0) {\n    module.exports = Heap;\n  } else {\n    window.Heap = Heap;\n  }\n\n}).call(this);\n","/**\r\n * @author aniero / https://github.com/aniero\r\n */\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\nvar JPFNeverMoveDiagonally = require('./JPFNeverMoveDiagonally');\r\nvar JPFAlwaysMoveDiagonally = require('./JPFAlwaysMoveDiagonally');\r\nvar JPFMoveDiagonallyIfNoObstacles = require('./JPFMoveDiagonallyIfNoObstacles');\r\nvar JPFMoveDiagonallyIfAtMostOneObstacle = require('./JPFMoveDiagonallyIfAtMostOneObstacle');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm\r\n * @param {Object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal\r\n *      movement will be allowed.\r\n */\r\nfunction JumpPointFinder(opt) {\r\n    opt = opt || {};\r\n    if (opt.diagonalMovement === DiagonalMovement.Never) {\r\n        return new JPFNeverMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.Always) {\r\n        return new JPFAlwaysMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        return new JPFMoveDiagonallyIfNoObstacles(opt);\r\n    } else {\r\n        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);\r\n    }\r\n}\r\n\r\nmodule.exports = JumpPointFinder;\r\n","/**\r\n * A node in grid. \r\n * This class holds some basic information about a node and custom \r\n * attributes may be added, depending on the algorithms' needs.\r\n * @constructor\r\n * @param {number} x - The x coordinate of the node on the grid.\r\n * @param {number} y - The y coordinate of the node on the grid.\r\n * @param {boolean} [walkable] - Whether this node is walkable.\r\n */\r\nfunction Node(x, y, walkable) {\r\n    /**\r\n     * The x coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.x = x;\r\n    /**\r\n     * The y coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.y = y;\r\n    /**\r\n     * Whether this node can be walked through.\r\n     * @type boolean\r\n     */\r\n    this.walkable = (walkable === undefined ? true : walkable);\r\n}\r\n\r\nmodule.exports = Node;\r\n","var Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * A* path-finder.\r\n * based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction BiAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\r\n    //It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var cmp = function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        },\r\n        startOpenList = new Heap(cmp),\r\n        endOpenList = new Heap(cmp),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng,\r\n        BY_START = 1, BY_END = 2;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    // and push it into the start open list\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n    startOpenList.push(startNode);\r\n    startNode.opened = BY_START;\r\n\r\n    // set the `g` and `f` value of the end node to be 0\r\n    // and push it into the open open list\r\n    endNode.g = 0;\r\n    endNode.f = 0;\r\n    endOpenList.push(endNode);\r\n    endNode.opened = BY_END;\r\n\r\n    // while both the open lists are not empty\r\n    while (!startOpenList.empty() && !endOpenList.empty()) {\r\n\r\n        // pop the position of start node which has the minimum `f` value.\r\n        node = startOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_END) {\r\n                return Util.biBacktrace(node, neighbor);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    startOpenList.push(neighbor);\r\n                    neighbor.opened = BY_START;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    startOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n\r\n\r\n        // pop the position of end node which has the minimum `f` value.\r\n        node = endOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_START) {\r\n                return Util.biBacktrace(neighbor, node);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - startX), abs(y - startY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    endOpenList.push(neighbor);\r\n                    neighbor.opened = BY_END;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    endOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiAStarFinder;\r\n","var Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar Node       = require('../core/Node');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Iterative Deeping A Star (IDA*) path-finder.\r\n *\r\n * Recursion based on:\r\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\r\n *\r\n * Path retracing based on:\r\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\r\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\r\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\r\n *\r\n * @author Gerard Meier (www.gerardmeier.com)\r\n *\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n * @param {boolean} opt.trackRecursion Whether to track recursion for\r\n *     statistical purposes.\r\n * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\r\n */\r\nfunction IDAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.trackRecursion = opt.trackRecursion || false;\r\n    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    // admissible, it should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path. When an empty array is returned, either\r\n * no path is possible, or the maximum execution time is reached.\r\n *\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nIDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    // Used for statistics:\r\n    var nodesVisited = 0;\r\n\r\n    // Execution time limitation:\r\n    var startTime = new Date().getTime();\r\n\r\n    // Heuristic helper:\r\n    var h = function(a, b) {\r\n        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\r\n    }.bind(this);\r\n\r\n    // Step cost from a to b:\r\n    var cost = function(a, b) {\r\n        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;\r\n    };\r\n\r\n    /**\r\n     * IDA* search implementation.\r\n     *\r\n     * @param {Node} The node currently expanding from.\r\n     * @param {number} Cost to reach the given node.\r\n     * @param {number} Maximum search depth (cut-off value).\r\n     * @param {Array<Array<number>>} The found route.\r\n     * @param {number} Recursion depth.\r\n     *\r\n     * @return {Object} either a number with the new optimal cut-off depth,\r\n     * or a valid node instance, in which case a path was found.\r\n     */\r\n    var search = function(node, g, cutoff, route, depth) {\r\n        nodesVisited++;\r\n\r\n        // Enforce timelimit:\r\n        if (this.timeLimit > 0 &&\r\n            new Date().getTime() - startTime > this.timeLimit * 1000) {\r\n            // Enforced as \"path-not-found\".\r\n            return Infinity;\r\n        }\r\n\r\n        var f = g + h(node, end) * this.weight;\r\n\r\n        // We've searched too deep for this iteration.\r\n        if (f > cutoff) {\r\n            return f;\r\n        }\r\n\r\n        if (node == end) {\r\n            route[depth] = [node.x, node.y];\r\n            return node;\r\n        }\r\n\r\n        var min, t, k, neighbour;\r\n\r\n        var neighbours = grid.getNeighbors(node, this.diagonalMovement);\r\n\r\n        // Sort the neighbours, gives nicer paths. But, this deviates\r\n        // from the original algorithm - so I left it out.\r\n        //neighbours.sort(function(a, b){\r\n        //    return h(a, end) - h(b, end);\r\n        //});\r\n\r\n        \r\n        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment\r\n        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\r\n        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment\r\n            if (this.trackRecursion) {\r\n                // Retain a copy for visualisation. Due to recursion, this\r\n                // node may be part of other paths too.\r\n                neighbour.retainCount = neighbour.retainCount + 1 || 1;\r\n\r\n                if(neighbour.tested !== true) {\r\n                    neighbour.tested = true;\r\n                }\r\n            }\r\n\r\n            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\r\n\r\n            if (t instanceof Node) {\r\n                route[depth] = [node.x, node.y];\r\n\r\n                // For a typical A* linked list, this would work:\r\n                // neighbour.parent = node;\r\n                return t;\r\n            }\r\n\r\n            // Decrement count, then determine whether it's actually closed.\r\n            if (this.trackRecursion && (--neighbour.retainCount) === 0) {\r\n                neighbour.tested = false;\r\n            }\r\n\r\n            if (t < min) {\r\n                min = t;\r\n            }\r\n        }\r\n\r\n        return min;\r\n\r\n    }.bind(this);\r\n\r\n    // Node instance lookups:\r\n    var start = grid.getNodeAt(startX, startY);\r\n    var end   = grid.getNodeAt(endX, endY);\r\n\r\n    // Initial search depth, given the typical heuristic contraints,\r\n    // there should be no cheaper route possible.\r\n    var cutOff = h(start, end);\r\n\r\n    var j, route, t;\r\n\r\n    // With an overflow protection.\r\n    for (j = 0; true; ++j) {\r\n\r\n        route = [];\r\n\r\n        // Search till cut-off depth:\r\n        t = search(start, 0, cutOff, route, 0);\r\n\r\n        // Route not possible, or not found in time limit.\r\n        if (t === Infinity) {\r\n            return [];\r\n        }\r\n\r\n        // If t is a node, it's also the end node. Route is now\r\n        // populated with a valid path to the end node.\r\n        if (t instanceof Node) {\r\n            return route;\r\n        }\r\n\r\n        // Try again, this time with a deeper cut-off. The t score\r\n        // is the closest we got to the end node.\r\n        cutOff = t;\r\n    }\r\n\r\n    // This _should_ never to be reached.\r\n    return [];\r\n};\r\n\r\nmodule.exports = IDAStarFinder;\r\n","/**\r\n * @namespace PF.Heuristic\r\n * @description A collection of heuristic functions.\r\n */\r\nmodule.exports = {\r\n\r\n  /**\r\n   * Manhattan distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} dx + dy\r\n   */\r\n  manhattan: function(dx, dy) {\r\n      return dx + dy;\r\n  },\r\n\r\n  /**\r\n   * Euclidean distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy)\r\n   */\r\n  euclidean: function(dx, dy) {\r\n      return Math.sqrt(dx * dx + dy * dy);\r\n  },\r\n\r\n  /**\r\n   * Octile distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy) for grids\r\n   */\r\n  octile: function(dx, dy) {\r\n      var F = Math.SQRT2 - 1;\r\n      return (dx < dy) ? F * dx + dy : F * dy + dx;\r\n  },\r\n\r\n  /**\r\n   * Chebyshev distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} max(dx, dy)\r\n   */\r\n  chebyshev: function(dx, dy) {\r\n      return Math.max(dx, dy);\r\n  }\r\n\r\n};\r\n","var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Bi-directional Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiBreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        startOpenList = [], endOpenList = [],\r\n        neighbors, neighbor, node,\r\n        diagonalMovement = this.diagonalMovement,\r\n        BY_START = 0, BY_END = 1,\r\n        i, l;\r\n\r\n    // push the start and end nodes into the queues\r\n    startOpenList.push(startNode);\r\n    startNode.opened = true;\r\n    startNode.by = BY_START;\r\n\r\n    endOpenList.push(endNode);\r\n    endNode.opened = true;\r\n    endNode.by = BY_END;\r\n\r\n    // while both the queues are not empty\r\n    while (startOpenList.length && endOpenList.length) {\r\n\r\n        // expand start open list\r\n\r\n        node = startOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                // if this node has been inspected by the reversed search,\r\n                // then a path is found.\r\n                if (neighbor.by === BY_END) {\r\n                    return Util.biBacktrace(node, neighbor);\r\n                }\r\n                continue;\r\n            }\r\n            startOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_START;\r\n        }\r\n\r\n        // expand end open list\r\n\r\n        node = endOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                if (neighbor.by === BY_START) {\r\n                    return Util.biBacktrace(neighbor, node);\r\n                }\r\n                continue;\r\n            }\r\n            endOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_END;\r\n        }\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiBreadthFirstFinder;\r\n","var AStarFinder = require('./AStarFinder');\r\n\r\n/**\r\n * Best-First-Search path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BestFirstFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBestFirstFinder.prototype = new AStarFinder();\r\nBestFirstFinder.prototype.constructor = BestFirstFinder;\r\n\r\nmodule.exports = BestFirstFinder;\r\n","var Node = require('./Node');\r\nvar DiagonalMovement = require('./DiagonalMovement');\r\n\r\n/**\r\n * The Grid class, which serves as the encapsulation of the layout of the nodes.\r\n * @constructor\r\n * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix\r\n * @param {number} height Number of rows of the grid.\r\n * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix\r\n *     representing the walkable status of the nodes(0 or false for walkable).\r\n *     If the matrix is not supplied, all the nodes will be walkable.  */\r\nfunction Grid(width_or_matrix, height, matrix) {\r\n    var width;\r\n\r\n    if (typeof width_or_matrix !== 'object') {\r\n        width = width_or_matrix;\r\n    } else {\r\n        height = width_or_matrix.length;\r\n        width = width_or_matrix[0].length;\r\n        matrix = width_or_matrix;\r\n    }\r\n\r\n    /**\r\n     * The number of columns of the grid.\r\n     * @type number\r\n     */\r\n    this.width = width;\r\n    /**\r\n     * The number of rows of the grid.\r\n     * @type number\r\n     */\r\n    this.height = height;\r\n\r\n    /**\r\n     * A 2D array of nodes.\r\n     */\r\n    this.nodes = this._buildNodes(width, height, matrix);\r\n}\r\n\r\n/**\r\n * Build and return the nodes.\r\n * @private\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing\r\n *     the walkable status of the nodes.\r\n * @see Grid\r\n */\r\nGrid.prototype._buildNodes = function(width, height, matrix) {\r\n    var i, j,\r\n        nodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        nodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            nodes[i][j] = new Node(j, i);\r\n        }\r\n    }\r\n\r\n\r\n    if (matrix === undefined) {\r\n        return nodes;\r\n    }\r\n\r\n    if (matrix.length !== height || matrix[0].length !== width) {\r\n        throw new Error('Matrix size does not fit');\r\n    }\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        for (j = 0; j < width; ++j) {\r\n            if (matrix[i][j]) {\r\n                // 0, false, null will be walkable\r\n                // while others will be un-walkable\r\n                nodes[i][j].walkable = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n};\r\n\r\n\r\nGrid.prototype.getNodeAt = function(x, y) {\r\n    return this.nodes[y][x];\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the node at the given position is walkable.\r\n * (Also returns false if the position is outside the grid.)\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @return {boolean} - The walkability of the node.\r\n */\r\nGrid.prototype.isWalkableAt = function(x, y) {\r\n    return this.isInside(x, y) && this.nodes[y][x].walkable;\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the position is inside the grid.\r\n * XXX: `grid.isInside(x, y)` is wierd to read.\r\n * It should be `(x, y) is inside grid`, but I failed to find a better\r\n * name for this method.\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nGrid.prototype.isInside = function(x, y) {\r\n    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);\r\n};\r\n\r\n\r\n/**\r\n * Set whether the node on the given position is walkable.\r\n * NOTE: throws exception if the coordinate is not inside the grid.\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @param {boolean} walkable - Whether the position is walkable.\r\n */\r\nGrid.prototype.setWalkableAt = function(x, y, walkable) {\r\n    this.nodes[y][x].walkable = walkable;\r\n};\r\n\r\n\r\n/**\r\n * Get the neighbors of the given node.\r\n *\r\n *     offsets      diagonalOffsets:\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 0 |   |    | 0 |   | 1 |\r\n *  +---+---+---+    +---+---+---+\r\n *  | 3 |   | 1 |    |   |   |   |\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 2 |   |    | 3 |   | 2 |\r\n *  +---+---+---+    +---+---+---+\r\n *\r\n *  When allowDiagonal is true, if offsets[i] is valid, then\r\n *  diagonalOffsets[i] and\r\n *  diagonalOffsets[(i + 1) % 4] is valid.\r\n * @param {Node} node\r\n * @param {DiagonalMovement} diagonalMovement\r\n */\r\nGrid.prototype.getNeighbors = function(node, diagonalMovement) {\r\n    var x = node.x,\r\n        y = node.y,\r\n        neighbors = [],\r\n        s0 = false, d0 = false,\r\n        s1 = false, d1 = false,\r\n        s2 = false, d2 = false,\r\n        s3 = false, d3 = false,\r\n        nodes = this.nodes;\r\n\r\n    // ↑\r\n    if (this.isWalkableAt(x, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x]);\r\n        s0 = true;\r\n    }\r\n    // →\r\n    if (this.isWalkableAt(x + 1, y)) {\r\n        neighbors.push(nodes[y][x + 1]);\r\n        s1 = true;\r\n    }\r\n    // ↓\r\n    if (this.isWalkableAt(x, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x]);\r\n        s2 = true;\r\n    }\r\n    // ←\r\n    if (this.isWalkableAt(x - 1, y)) {\r\n        neighbors.push(nodes[y][x - 1]);\r\n        s3 = true;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.Never) {\r\n        return neighbors;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        d0 = s3 && s0;\r\n        d1 = s0 && s1;\r\n        d2 = s1 && s2;\r\n        d3 = s2 && s3;\r\n    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {\r\n        d0 = s3 || s0;\r\n        d1 = s0 || s1;\r\n        d2 = s1 || s2;\r\n        d3 = s2 || s3;\r\n    } else if (diagonalMovement === DiagonalMovement.Always) {\r\n        d0 = true;\r\n        d1 = true;\r\n        d2 = true;\r\n        d3 = true;\r\n    } else {\r\n        throw new Error('Incorrect value of diagonalMovement');\r\n    }\r\n\r\n    // ↖\r\n    if (d0 && this.isWalkableAt(x - 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x - 1]);\r\n    }\r\n    // ↗\r\n    if (d1 && this.isWalkableAt(x + 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x + 1]);\r\n    }\r\n    // ↘\r\n    if (d2 && this.isWalkableAt(x + 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x + 1]);\r\n    }\r\n    // ↙\r\n    if (d3 && this.isWalkableAt(x - 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x - 1]);\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\n\r\n/**\r\n * Get a clone of this grid.\r\n * @return {Grid} Cloned grid.\r\n */\r\nGrid.prototype.clone = function() {\r\n    var i, j,\r\n\r\n        width = this.width,\r\n        height = this.height,\r\n        thisNodes = this.nodes,\r\n\r\n        newGrid = new Grid(width, height),\r\n        newNodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        newNodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);\r\n        }\r\n    }\r\n\r\n    newGrid.nodes = newNodes;\r\n\r\n    return newGrid;\r\n};\r\n\r\nmodule.exports = Grid;\r\n","var BiAStarFinder = require('./BiAStarFinder');\r\n\r\n/**\r\n * Bi-direcitional Best-First-Search path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BiBestFirstFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBiBestFirstFinder.prototype = new BiAStarFinder();\r\nBiBestFirstFinder.prototype.constructor = BiBestFirstFinder;\r\n\r\nmodule.exports = BiBestFirstFinder;\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there is at most one obstacle.\r\n */\r\nfunction JPFMoveDiagonallyIfAtMostOneObstacle(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (!grid.isWalkableAt(x + 1, y)) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x - 1, y)) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (!grid.isWalkableAt(x, y + 1)) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x, y - 1)) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n","module.exports = require('./lib/heap');\n","var BiAStarFinder = require('./BiAStarFinder');\r\n\r\n/**\r\n * Bi-directional Dijkstra path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiDijkstraFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nBiDijkstraFinder.prototype = new BiAStarFinder();\r\nBiDijkstraFinder.prototype.constructor = BiDijkstraFinder;\r\n\r\nmodule.exports = BiDijkstraFinder;\r\n","var DiagonalMovement = {\r\n    Always: 1,\r\n    Never: 2,\r\n    IfAtMostOneObstacle: 3,\r\n    OnlyWhenNoObstacles: 4\r\n};\r\n\r\nmodule.exports = DiagonalMovement;","var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = [],\r\n        diagonalMovement = this.diagonalMovement,\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        neighbors, neighbor, node, i, l;\r\n\r\n    // push the start pos into the queue\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the queue is not empty\r\n    while (openList.length) {\r\n        // take the front node from the queue\r\n        node = openList.shift();\r\n        node.closed = true;\r\n\r\n        // reached the end position\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            // skip this neighbor if it has been inspected before\r\n            if (neighbor.closed || neighbor.opened) {\r\n                continue;\r\n            }\r\n\r\n            openList.push(neighbor);\r\n            neighbor.opened = true;\r\n            neighbor.parent = node;\r\n        }\r\n    }\r\n    \r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BreadthFirstFinder;\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Base class for the Jump Point Search algorithm\r\n * @param {object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction JumpPointFinderBase(opt) {\r\n    opt = opt || {};\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.trackJumpRecursion = opt.trackJumpRecursion || false;\r\n}\r\n\r\n/**\r\n * Find and return the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nJumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = this.openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = this.startNode = grid.getNodeAt(startX, startY),\r\n        endNode = this.endNode = grid.getNodeAt(endX, endY), node;\r\n\r\n    this.grid = grid;\r\n\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        if (node === endNode) {\r\n            return Util.expandPath(Util.backtrace(endNode));\r\n        }\r\n\r\n        this._identifySuccessors(node);\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\n/**\r\n * Identify successors for the given node. Runs a jump point search in the\r\n * direction of each available neighbor, adding any points found to the open\r\n * list.\r\n * @protected\r\n */\r\nJumpPointFinderBase.prototype._identifySuccessors = function(node) {\r\n    var grid = this.grid,\r\n        heuristic = this.heuristic,\r\n        openList = this.openList,\r\n        endX = this.endNode.x,\r\n        endY = this.endNode.y,\r\n        neighbors, neighbor,\r\n        jumpPoint, i, l,\r\n        x = node.x, y = node.y,\r\n        jx, jy, dx, dy, d, ng, jumpNode,\r\n        abs = Math.abs, max = Math.max;\r\n\r\n    neighbors = this._findNeighbors(node);\r\n    for(i = 0, l = neighbors.length; i < l; ++i) {\r\n        neighbor = neighbors[i];\r\n        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\r\n        if (jumpPoint) {\r\n\r\n            jx = jumpPoint[0];\r\n            jy = jumpPoint[1];\r\n            jumpNode = grid.getNodeAt(jx, jy);\r\n\r\n            if (jumpNode.closed) {\r\n                continue;\r\n            }\r\n\r\n            // include distance, as parent may not be immediately adjacent:\r\n            d = Heuristic.octile(abs(jx - x), abs(jy - y));\r\n            ng = node.g + d; // next `g` value\r\n\r\n            if (!jumpNode.opened || ng < jumpNode.g) {\r\n                jumpNode.g = ng;\r\n                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\r\n                jumpNode.f = jumpNode.g + jumpNode.h;\r\n                jumpNode.parent = node;\r\n\r\n                if (!jumpNode.opened) {\r\n                    openList.push(jumpNode);\r\n                    jumpNode.opened = true;\r\n                } else {\r\n                    openList.updateItem(jumpNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = JumpPointFinderBase;\r\n","module.exports = {\r\n    'Heap'                      : require('heap'),\r\n    'Node'                      : require('./core/Node'),\r\n    'Grid'                      : require('./core/Grid'),\r\n    'Util'                      : require('./core/Util'),\r\n    'DiagonalMovement'          : require('./core/DiagonalMovement'),\r\n    'Heuristic'                 : require('./core/Heuristic'),\r\n    'AStarFinder'               : require('./finders/AStarFinder'),\r\n    'BestFirstFinder'           : require('./finders/BestFirstFinder'),\r\n    'BreadthFirstFinder'        : require('./finders/BreadthFirstFinder'),\r\n    'DijkstraFinder'            : require('./finders/DijkstraFinder'),\r\n    'BiAStarFinder'             : require('./finders/BiAStarFinder'),\r\n    'BiBestFirstFinder'         : require('./finders/BiBestFirstFinder'),\r\n    'BiBreadthFirstFinder'      : require('./finders/BiBreadthFirstFinder'),\r\n    'BiDijkstraFinder'          : require('./finders/BiDijkstraFinder'),\r\n    'IDAStarFinder'             : require('./finders/IDAStarFinder'),\r\n    'JumpPointFinder'           : require('./finders/JumpPointFinder'),\r\n};\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which always moves\r\n * diagonally irrespective of the number of obstacles.\r\n */\r\nfunction JPFAlwaysMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y + dy)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x + 1, y)) {\r\n                    neighbors.push([x + 1, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x - 1, y)) {\r\n                    neighbors.push([x - 1, y + dy]);\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y + 1)) {\r\n                    neighbors.push([x + dx, y + 1]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y - 1)) {\r\n                    neighbors.push([x + dx, y - 1]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFAlwaysMoveDiagonally;\r\n","var Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * A* path-finder. Based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching \r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction AStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    //admissible. It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        // if reached the end position, construct the path and return it\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    openList.push(neighbor);\r\n                    neighbor.opened = true;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    openList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = AStarFinder;\r\n","var AStarFinder = require('./AStarFinder');\r\n\r\n/**\r\n * Dijkstra path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction DijkstraFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nDijkstraFinder.prototype = new AStarFinder();\r\nDijkstraFinder.prototype.constructor = DijkstraFinder;\r\n\r\nmodule.exports = DijkstraFinder;\r\n","module.exports = require('./src/PathFinding');\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t556: 0,\n\t237: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunklaraconman\"] = self[\"webpackChunklaraconman\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\n__webpack_require__.O(undefined, [237], () => (__webpack_require__(214)))\nvar __webpack_exports__ = __webpack_require__.O(undefined, [237], () => (__webpack_require__(966)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","ReflectOwnKeys","R","Reflect","ReflectApply","apply","target","receiver","args","Function","prototype","call","ownKeys","Object","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","value","EventEmitter","init","this","module","exports","once","emitter","name","Promise","resolve","reject","errorListener","err","removeListener","resolver","slice","arguments","eventTargetAgnosticAddListener","handler","flags","on","addErrorHandlerIfEventEmitter","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","type","prepend","m","events","existing","warning","create","newListener","emit","unshift","push","length","warned","w","Error","String","count","console","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","Array","i","unwrapListeners","arrayClone","listenerCount","n","copy","addEventListener","wrapListener","arg","removeEventListener","defineProperty","enumerable","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","message","context","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","key","keys","rawListeners","eventNames","JumpPointFinderBase","DiagonalMovement","JPFNeverMoveDiagonally","opt","constructor","_jump","x","y","px","py","grid","dx","dy","isWalkableAt","trackJumpRecursion","getNodeAt","tested","endNode","_findNeighbors","node","neighborNodes","neighborNode","l","parent","neighbors","Math","max","abs","getNeighbors","Never","backtrace","path","reverse","interpolate","x0","y0","x1","y1","sx","sy","e2","line","biBacktrace","nodeA","nodeB","pathA","pathB","pathLength","a","b","sum","sqrt","expandPath","coord0","coord1","interpolated","interpolatedLen","j","expanded","smoothenPath","newPath","coord","testCoord","blocked","lastValidCoord","compressPath","lx","ly","ldx","ldy","sq","compressed","score","lives","level","moveInc","speed","gameTime","mazeSource","basicVision","resetModeOnResetGame","excludeReverseDirectionInRandomMode","fx","extras","ghostPenTimeout","megaPelletDuration","maxGhosts","playerSpeed","playerSize","playerSuperSpeed","playerSuperSize","dotPoints","superDotPoints","fruitTypes","points","image","InputHandler","_classCallCheck","currentDirection","queuedDirection","DIRECTIONS","UP","DOWN","LEFT","RIGHT","keyMap","callbacks","onDirectionChange","onKeyPress","onPause","onReset","setupEventListeners","_objectSpread","_this","document","e","code","handleDirectionInput","direction","MapRenderer","canvas","tileSize","config","ctx","getContext","mapData","rawMapData","width","height","TILES","WALL","DOT","GHOST_DOOR","TUNNEL","EMPTY","CORNER","GHOST_SPAWN","PORTAL","SUPER_DOT","colors","wall","dot","ghostDoor","tunnel","background","corner","ghostSpawn","portal","superDot","applyConfig","csvData","raw","trim","split","map","row","cell","mapTileCode","parseInt","portalColsTop","portalColsBottom","portalRowsLeft","portalRowsRight","c","r","topRow","includes","bottomRow","log","h","fillStyle","fillRect","col","tileType","renderTile","isEdge","renderWall","renderPath","renderDot","renderGhostDoor","renderCorner","renderGhostSpawn","renderPortal","renderSuperDot","strokeStyle","lineWidth","strokeRect","centerX","centerY","radius","beginPath","arc","PI","fill","moveTo","lineTo","stroke","worldX","worldY","floor","positions","PlayerEntity","startCol","startRow","settings","nextDirection","defaultSpeed","superSpeed","targetX","targetY","moving","dir","_PlayerEntity$directi2","_slicedToArray","directionDelta","dCol","dRow","nCol","nRow","canMove","_PlayerEntity$directi4","nextCol","nextRow","_PlayerEntity$directi6","angle","atan2","cos","sin","isSuper","save","scale","translate","restore","GhostEntity","color","tiles","exitTarget","destination","pathStep","lastPosition","_GhostEntity$directio2","some","Boolean","_GhostEntity$directio4","_GhostEntity$directio6","img","_artImg","Image","src","complete","drawImage","onload","dest","pfGrid","walkableTiles","PF","makePFGrid","pathArr","findPath","_ref","_ref2","bfsPath","next","nextType","setDirection","move","start","goal","queue","visited","Set","add","_path","_i","_arr","_arr$_i","nc","nr","k","has","_toConsumableArray","size","CollectibleEntity","options","active","art","fruit","CollectibleSpawner","tileTypes","dots","occupied","fruitType","random","fruitLocations","_pickRandomValidTile","_step","_iterator","_createForOfIteratorHelper","s","done","loc","f","_isInPen","_isInPortalOrTunnel","valid","Game","_defineProperty","mapRenderer","inputHandler","gameState","currentMap","player","setCallbacks","event","readyState","tileEventEmitter","TileEventEmitter","ghostReleaseTimer","ghostReleaseInterval","ghostPool","entityArt","activeGhosts","collisionEmitter","ghost","displayName","pellet","_ref3","ghostPenTimers","Map","ghostExitTimers","ghostExitTimeout","collisionCooldowns","collisionCooldownFrames","ghostPositions","ghostStuckCounters","ghostStuckThreshold","portalCooldowns","portalCooldownFrames","setSuperState","setTimeout","ghosts","usedSpots","forEach","idx","tries","dist","min","round","setDestination","moveToDestination","_createClass","getElementById","csv","window","laraconmanMazeCsv","_mapArray$","mapArray","parseAndAdaptMazeCsv","normalizedCsv","join","loadMap","render","initPlayer","initCollectibles","gameLoop","_spawner$spawnCollect","spawnCollectibles","_this2","startBtn","pauseBtn","resetBtn","startGame","togglePause","resetGame","mapDataScript","JSON","parse","textContent","gameMapData","loadTestMap","design","updateUI","testMap","reset","scoreElement","livesElement","disabled","_this3","penTiles","playerStart","penCols","t","penRows","minCol","maxCol","maxRow","centerCol","outer","_this$player","dispatchEvent","CustomEvent","detail","_step2","_iterator2","tile","PELLET","spawns","data","spawn","usedNames","g","available","filter","ghostConfig","ghostColor","_this4","_step3","_iterator3","_loop","dirs","setState","candidates","atDestination","_this5","renderCollectibles","checkPlayerTile","moveGhosts","_step4","_iterator4","spawnGhost","checkCollisions","_step5","_iterator5","updateCollisionCooldowns","requestAnimationFrame","_this6","entity","collisions","getWhatIsAt","fireCollisionEvents","result","entities","_step6","_iterator6","pellets","_step7","_iterator7","fruits","_step8","_iterator8","_step9","entityType","getEntityType","_iterator9","collision","id","shouldFireEvent","setEventCooldown","handleTileCollision","portalKey","findOppositePortal","destKey","centerRow","newCol","newRow","walkable","teleportEntity","ejectionKey","from","to","_step0","_iterator0","entries","_step0$value","_step1","_iterator1","_step1$value","portals","_portals","p","_i2","_portals2","maxDist","best","_i3","_portals3","csvString","val","cb","JPFMoveDiagonallyIfNoObstacles","isNextWalkable","isTopWalkable","isBottomWalkable","isRightWalkable","isLeftWalkable","OnlyWhenNoObstacles","Heap","defaultCmp","heapify","heappop","heappush","heappushpop","heapreplace","insort","nlargest","nsmallest","updateItem","_siftdown","_siftup","lo","hi","cmp","mid","splice","array","item","lastelt","returnitem","_len","_ref1","_results","_results1","_j","pos","indexOf","elem","sort","los","startpos","newitem","parentpos","childpos","endpos","rightpos","nodes","replace","pushpop","peek","contains","clear","empty","clone","heap","toArray","insert","top","front","JPFAlwaysMoveDiagonally","JPFMoveDiagonallyIfAtMostOneObstacle","diagonalMovement","Always","Util","Heuristic","BiAStarFinder","allowDiagonal","dontCrossCorners","heuristic","manhattan","weight","IfAtMostOneObstacle","octile","startX","startY","endX","endY","neighbor","ng","startOpenList","endOpenList","startNode","SQRT2","opened","closed","Node","IDAStarFinder","trackRecursion","timeLimit","Infinity","route","startTime","Date","getTime","cost","search","cutoff","depth","neighbour","end","neighbours","retainCount","cutOff","euclidean","F","chebyshev","BiBreadthFirstFinder","by","AStarFinder","BestFirstFinder","orig","Grid","width_or_matrix","matrix","_buildNodes","isInside","setWalkableAt","s0","d0","s1","d1","s2","d2","s3","d3","thisNodes","newGrid","newNodes","BiBestFirstFinder","BiDijkstraFinder","BreadthFirstFinder","openList","_identifySuccessors","jumpPoint","jx","jy","d","jumpNode","DijkstraFinder","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","loaded","__webpack_modules__","O","chunkIds","fn","priority","notFulfilled","fulfilled","every","getter","__esModule","definition","o","obj","prop","hasOwnProperty","nmd","paths","children","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","chunkLoadingGlobal","self","__webpack_exports__"],"sourceRoot":""}